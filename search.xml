<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[39-滑块元素和视频音量]]></title>
    <url>%2Fposts%2F98c8260c%2F</url>
    <content type="text"><![CDATA[滑块元素和视频音量 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263&lt;!DOCTYPE html&gt;&lt;html lang="en"&gt;&lt;head&gt; &lt;meta charset="UTF-8"&gt; &lt;meta name="viewport" content="width=device-width, initial-scale=1.0"&gt; &lt;meta http-equiv="X-UA-Compatible" content="ie=edge"&gt; &lt;title&gt;Document&lt;/title&gt;&lt;/head&gt;&lt;body&gt; &lt;!-- 要修改滑块的值就用value属性 默认最大值是100，最小值是0 max修改最大值 min修改最小值 --&gt; &lt;input type="range" max="10" min="0"&gt; &lt;video src="video/movie01.mp4" controls&gt;&lt;/video&gt; &lt;input type="button" value="提高音量到1" id="btn1"&gt; &lt;input type="button" value="减少音量到0" id="btn2"&gt; &lt;input type="button" value="减少音量到10" id="btn3"&gt; &lt;input type="button" value="减少音量到0.5" id="btn4"&gt;&lt;/body&gt;&lt;/html&gt;&lt;script&gt; document.querySelector('input').onchange = function () &#123; console.log(this.value); &#125;; //找到video var video = document.querySelector('video'); document.getElementById('btn1').onclick = function () &#123; //只在0-1之间 video.volume = 1; &#125; document.getElementById('btn3').onclick = function()&#123; video.volume = 10; &#125; document.getElementById('btn2').onclick = function () &#123; video.volume = 0; &#125; document.getElementById('btn4').onclick = function()&#123; video.volume = 0.5; &#125;&lt;/script&gt;]]></content>
      <categories>
        <category>HTML/CSS</category>
        <category>HTML5/CSS3</category>
      </categories>
      <tags>
        <tag>HTML</tag>
        <tag>HTML5</tag>
        <tag>CSS3</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[38-自定义视频播放器]]></title>
    <url>%2Fposts%2F8435e11c%2F</url>
    <content type="text"><![CDATA[自定义视频播放器 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188&lt;!DOCTYPE html&gt;&lt;html lang="en"&gt;&lt;head&gt; &lt;meta charset="UTF-8"&gt; &lt;meta name="viewport" content="width=device-width, initial-scale=1.0"&gt; &lt;meta http-equiv="X-UA-Compatible" content="ie=edge"&gt; &lt;title&gt;Document&lt;/title&gt; &lt;!-- 跟视频/音频有关的方法： play()：播放 pause()：暂停 --&gt; &lt;link rel="stylesheet" href="css/font-awesome.min.css"&gt; &lt;style&gt; body &#123; background-color: #000; &#125; .player &#123; width: 600px; height: 450px; border: 1px solid #fff; margin: 100px auto; display: flex; flex-direction: column; &#125; video &#123; height: 90%; &#125; .controls &#123; /* 代表用主轴剩余的大小，现在主轴是Y轴，相当于用父元素剩余的高度 */ flex: 1; /* 让它的子元素用弹性布局 */ display: flex; &#125; .controls a &#123; width: 60px; text-decoration: none; color: white; display: flex; justify-content: center; align-items: center; font-size: 23px; &#125; .controls .progress &#123; /* 用主轴剩余的大小，现在主轴是x轴，所以是给剩余的宽度 */ flex: 1; background-color: #fff; &#125; /* 显示进度条的值 */ .son &#123; background-color: gray; height: 100%; width: 0%; &#125; &lt;/style&gt;&lt;/head&gt;&lt;body&gt; &lt;div class="player"&gt; &lt;video src="video/movie01.mp4"&gt;&lt;/video&gt; &lt;div class="controls"&gt; &lt;a class="play fa fa-play" href="javascript:void(0);"&gt;&lt;/a&gt; &lt;div class="progress"&gt; &lt;div class="son"&gt;&lt;/div&gt; &lt;/div&gt; &lt;input id="range" type="range" max="10" value="10"&gt; &lt;a class="full fa fa-expand" href="javascript:void(0);"&gt;&lt;/a&gt; &lt;/div&gt; &lt;/div&gt;&lt;/body&gt;&lt;/html&gt;&lt;script&gt; //需要找到video var video = document.querySelector('video'); //找到显示进度条值的子元素div var son = document.querySelector('.son'); // 播放的点击事件 document.querySelector('.play').onclick = function () &#123; //如果有，代表当前显示的是播放图标 if (this.classList.contains('fa-play')) &#123; video.play(); //还要把图标换成暂停的图标 this.classList.remove('fa-play'); this.classList.add('fa-pause'); &#125; else &#123; //暂停 video.pause(); this.classList.remove('fa-pause'); this.classList.add('fa-play'); &#125; &#125;; //全屏的点击事件 document.querySelector('.full').onclick = function()&#123; // 这个方法是实验室中的方法，现在没有加入到标准文档里面，但是准备加在下一代的标准里面 // 但是现在还没有正式启用，只是浏览器厂商先加入这个功能来测试是否正确，等到下一个版本发布时再正式启用 // 如果是实验室中的方法，那么就需要加浏览器前缀，代表调用这个浏览器的私有方法 // video.requestFullscreen(); // video.webkitRequestFullScreen(); // video.webkitRequestFullscreen(); //火狐的 // video.mozRequestFullScreen(); //IE的 // video.msRequestFullscreen(); if(video.webkitRequestFullScreen)&#123; video.webkitRequestFullScreen(); &#125;else if(video.mozRequestFullScreen)&#123; video.mozRequestFullScreen(); &#125;else&#123; video.msRequestFullscreen(); &#125; &#125;; //视频的播放时间更新事件,相当于是视频每播放一秒都来触发一次的事件了 video.ontimeupdate = function()&#123; // console.log(video.currentTime,video.duration); //在这个事件里不断的计算进度条的值 //算法： 用视频当前播放的时间 / 视频总时长 // var per = video.currentTime / video.duration * 100 + "%"; // console.log(per); son.style.width = video.currentTime / video.duration * 100 + "%"; &#125; // 进度条的点击事件 document.querySelector('.progress').onclick = function(e)&#123; //思路：要获得点击的那个点相对于进度条左上角的x值，用这个值除以进度条的总宽度 //就得到百分比，再用这个百分比乘以视频的总时长，就得到视频应该跳到的时间 e = e || window.event; //计算相对于自身的x var x = e.clientX - this.getBoundingClientRect().left; //用计算的结果赋值给视频的播放时间 video.currentTime = x / this.offsetWidth * video.duration; &#125;; document.getElementById('range').onchange = function()&#123; video.volume = this.value / 10; &#125;&lt;/script&gt;]]></content>
      <categories>
        <category>HTML/CSS</category>
        <category>HTML5/CSS3</category>
      </categories>
      <tags>
        <tag>HTML</tag>
        <tag>HTML5</tag>
        <tag>CSS3</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[37-极其无聊的flex-basis属性]]></title>
    <url>%2Fposts%2F3f7e1d7a%2F</url>
    <content type="text"><![CDATA[极其无聊的flex-basis属性 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152&lt;!DOCTYPE html&gt;&lt;html lang="en"&gt;&lt;head&gt; &lt;meta charset="UTF-8"&gt; &lt;meta name="viewport" content="width=device-width, initial-scale=1.0"&gt; &lt;meta http-equiv="X-UA-Compatible" content="ie=edge"&gt; &lt;title&gt;Document&lt;/title&gt; &lt;!-- 本文件知识点： flex-basis:设置子元素在主轴方向的大小，可能是宽（x为主轴），也可能是高(y为主轴) 下面这三个属性都是设置在子元素上的 align-self flex: flex-basis： --&gt; &lt;style&gt; ul&#123; padding: 0; list-style: none; width: 600px; height: 600px; border: 1px solid #000; display: flex; flex-direction: column; &#125; li&#123; width: 150px; /* 设置子元素在主轴方向的大小，可能是设置的宽，也可能设置的是高 */ /* flex-basis: 180px; */ height: 150px; background-color: yellowgreen; &#125; &lt;/style&gt;&lt;/head&gt;&lt;body&gt; &lt;ul&gt; &lt;li&gt;1&lt;/li&gt; &lt;li&gt;2&lt;/li&gt; &lt;li&gt;3&lt;/li&gt; &lt;/ul&gt;&lt;/body&gt;&lt;/html&gt;]]></content>
      <categories>
        <category>HTML/CSS</category>
        <category>HTML5/CSS3</category>
      </categories>
      <tags>
        <tag>HTML</tag>
        <tag>HTML5</tag>
        <tag>CSS3</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[36-设置子元素在主轴的占比]]></title>
    <url>%2Fposts%2F5830b0f1%2F</url>
    <content type="text"><![CDATA[设置子元素在主轴的占比 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465&lt;!DOCTYPE html&gt;&lt;html lang="en"&gt;&lt;head&gt; &lt;meta charset="UTF-8"&gt; &lt;meta name="viewport" content="width=device-width, initial-scale=1.0"&gt; &lt;meta http-equiv="X-UA-Compatible" content="ie=edge"&gt; &lt;title&gt;Document&lt;/title&gt; &lt;!-- 本文件知识点： flex:设置的是在主轴方向的占比 如果大家占比的值都一样，就代表平分 flex这个属性永远计算的是主轴方向剩余的大小 --&gt; &lt;style&gt; ul&#123; padding: 0; list-style: none; width: 600px; height: 600px; border: 1px solid #000; display: flex; /* flex-direction: column; */ &#125; li&#123; /* width: 150px; */ /* flex:99; */ height: 150px; background-color: yellowgreen; &#125; li:nth-child(1)&#123; /* 在主轴方向占2份 */ /* flex:2; */ width:100px; &#125; li:nth-child(2)&#123; /* 在主轴方向占4份 */ flex:4; &#125; li:nth-child(3)&#123; /* 在主轴方向占4份 */ flex:4; &#125; &lt;/style&gt;&lt;/head&gt;&lt;body&gt; &lt;ul&gt; &lt;li&gt;1&lt;/li&gt; &lt;li&gt;2&lt;/li&gt; &lt;li&gt;3&lt;/li&gt; &lt;/ul&gt;&lt;/body&gt;&lt;/html&gt;]]></content>
      <categories>
        <category>HTML/CSS</category>
        <category>HTML5/CSS3</category>
      </categories>
      <tags>
        <tag>HTML</tag>
        <tag>HTML5</tag>
        <tag>CSS3</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[35-单独设置某个子元素在副轴排列]]></title>
    <url>%2Fposts%2F20fa5a2b%2F</url>
    <content type="text"><![CDATA[单独设置某个子元素在副轴排列 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354&lt;!DOCTYPE html&gt;&lt;html lang="en"&gt;&lt;head&gt; &lt;meta charset="UTF-8"&gt; &lt;meta name="viewport" content="width=device-width, initial-scale=1.0"&gt; &lt;meta http-equiv="X-UA-Compatible" content="ie=edge"&gt; &lt;title&gt;Document&lt;/title&gt; &lt;!-- 本文件知识点： align-self：单独设置某个子元素在副轴的排列 它的取值跟align-items是一样的 也就是说也有 stretch flex-start flex-end center --&gt; &lt;style&gt; ul&#123; padding: 0; list-style: none; width: 600px; height: 600px; border: 1px solid #000; display: flex; /* 统一设置所有子元素在副轴排列方式 */ /* align-items: center; */ &#125; li&#123; width: 150px; height: 150px; background-color: yellowgreen; &#125; li:nth-child(2)&#123; /* 单独设置自己在副轴的排列 */ /* 这个属性的取值跟align-items是一样的，区别在于，align-self仅仅只是设置某一个子元素 */ align-self: center; &#125; &lt;/style&gt;&lt;/head&gt;&lt;body&gt; &lt;ul&gt; &lt;li&gt;1&lt;/li&gt; &lt;li&gt;2&lt;/li&gt; &lt;li&gt;3&lt;/li&gt; &lt;/ul&gt;&lt;/body&gt;&lt;/html&gt;]]></content>
      <categories>
        <category>HTML/CSS</category>
        <category>HTML5/CSS3</category>
      </categories>
      <tags>
        <tag>HTML</tag>
        <tag>HTML5</tag>
        <tag>CSS3</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[34-弹性布局中的换行]]></title>
    <url>%2Fposts%2F6a30895e%2F</url>
    <content type="text"><![CDATA[弹性布局中的换行 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950&lt;!DOCTYPE html&gt;&lt;html lang="en"&gt;&lt;head&gt; &lt;meta charset="UTF-8"&gt; &lt;meta name="viewport" content="width=device-width, initial-scale=1.0"&gt; &lt;meta http-equiv="X-UA-Compatible" content="ie=edge"&gt; &lt;title&gt;Document&lt;/title&gt; &lt;style&gt; ul &#123; padding: 0; list-style: none; width: 600px; height: 600px; border: 1px solid #000; display: flex; /* 允许换行 开启换行后，弹性布局会计算出你一共有多少行 例如计算出有2行，那么它会把父元素的大小平分成2块区域 */ flex-wrap: wrap; /* 设置在副轴方向的排列 设置的是在自己区域的副轴排列 */ /*align-items: center;*/ &#125; li &#123; width: 250px; height: 150px; background-color: yellowgreen; &#125; &lt;/style&gt;&lt;/head&gt;&lt;body&gt; &lt;ul&gt; &lt;li&gt;1&lt;/li&gt; &lt;li&gt;2&lt;/li&gt; &lt;li&gt;3&lt;/li&gt; &lt;/ul&gt;&lt;/body&gt;&lt;/html&gt;]]></content>
      <categories>
        <category>HTML/CSS</category>
        <category>HTML5/CSS3</category>
      </categories>
      <tags>
        <tag>HTML</tag>
        <tag>HTML5</tag>
        <tag>CSS3</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[33-弹性布局统一设置子元素在副轴排列]]></title>
    <url>%2Fposts%2F4db84cfc%2F</url>
    <content type="text"><![CDATA[弹性布局统一设置子元素在副轴排列 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465&lt;!DOCTYPE html&gt;&lt;html lang="en"&gt;&lt;head&gt; &lt;meta charset="UTF-8"&gt; &lt;meta name="viewport" content="width=device-width, initial-scale=1.0"&gt; &lt;meta http-equiv="X-UA-Compatible" content="ie=edge"&gt; &lt;title&gt;Document&lt;/title&gt; &lt;!-- 弹性布局：相当于可以把子元素转为行内块元素 默认情况下：如果不给子元素副轴方向上的大小，它会占满父盒子的副轴方向 它的根本原因是：没有设置align-items，它的默认值是stretch --&gt; &lt;style&gt; ul&#123; padding: 0; list-style: none; width: 600px; height: 600px; border: 1px solid #000; /* 给谁加弹性布局，就是代表让子元素用弹性布局 */ display: flex; /* 设置在主轴居中 */ justify-content: center; /* 修改主轴方向 */ flex-direction: column; /* 设置在副轴的排列方式 主要用到的是三个： stretch：默认值，也是在副轴起点对齐，但是如果没有设置副轴大小，它会拉伸元素在副轴的方向铺满 flex-start：仅仅就是在副轴起点对齐，如果没有设置副轴大小，就用内容的大小 所以：如果有设置副轴上的大小，上面两个值是一样的 flex-end：在副轴终点对齐 center：在副轴居中 */ align-items: center; &#125; li&#123; width: 150px; height: 150px; background-color: yellowgreen; &#125; /* span&#123; width: 100px; height: 100px; background-color: #f00; &#125; */ &lt;/style&gt;&lt;/head&gt;&lt;body&gt; &lt;ul&gt; &lt;!-- &lt;span&gt;我是span&lt;/span&gt; --&gt; &lt;li&gt;1&lt;/li&gt; &lt;li&gt;2&lt;/li&gt; &lt;li&gt;3&lt;/li&gt; &lt;/ul&gt;&lt;/body&gt;&lt;/html&gt;]]></content>
      <categories>
        <category>HTML/CSS</category>
        <category>HTML5/CSS3</category>
      </categories>
      <tags>
        <tag>HTML</tag>
        <tag>HTML5</tag>
        <tag>CSS3</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[32-弹性布局基本使用]]></title>
    <url>%2Fposts%2F522c85ef%2F</url>
    <content type="text"><![CDATA[弹性布局基本使用 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273&lt;!DOCTYPE html&gt;&lt;html lang="en"&gt;&lt;head&gt; &lt;meta charset="UTF-8"&gt; &lt;meta name="viewport" content="width=device-width, initial-scale=1.0"&gt; &lt;meta http-equiv="X-UA-Compatible" content="ie=edge"&gt; &lt;title&gt;Document&lt;/title&gt; &lt;!-- 弹性布局：会让子元素在主轴方向依次排列 justify-content:设置元素在主轴方向的排列方式 flex-start:在主轴起点对齐 flex-end：在主轴终点对齐 center：在主轴居中 space-around：元素和元素之间有间距，两边也有间距 space-between：元素和元素之间有间距，两边没有间距 flex-direction：设置主轴为哪个轴 row：默认值，代表x轴为主轴 column：代表y为主轴 row-reverse：还是以x为主轴，起点和终点会调换 一般不会用 column-reverse：还是以y为主轴，起点和终点会调换 一般不会用 --&gt; &lt;style&gt; ul&#123; list-style: none; padding: 0; width: 600px; height: 550px; border: 1px solid #000; /* 让子元素用弹性布局 */ display: flex; /* 设置子元素在主轴方向上的排列方式（对齐方式） flex-start：默认值，在主轴起点对齐 center：在主轴居中 flex-end：在主轴终点对齐 space-around:元素和元素之间有间距，并且两边也有间距 space-between：元素和元素之间有间距，但是两边没有间距 */ justify-content: flex-start; /* 修改主轴方向 row:默认值，就是以x轴为主轴 column：用y轴为主轴 row-reverse：还是以x为主轴，起点和终点会调换 一般不会用 column-reverse：还是以y为主轴，起点和终点会调换 一般不会用 */ flex-direction: column; &#125; li&#123; width: 150px; height: 150px; background: yellowgreen; &#125; &lt;/style&gt;&lt;/head&gt;&lt;body&gt; &lt;ul&gt; &lt;li&gt;1&lt;/li&gt; &lt;li&gt;2&lt;/li&gt; &lt;li&gt;3&lt;/li&gt; &lt;/ul&gt;&lt;/body&gt;&lt;/html&gt;]]></content>
      <categories>
        <category>HTML/CSS</category>
        <category>HTML5/CSS3</category>
      </categories>
      <tags>
        <tag>HTML</tag>
        <tag>HTML5</tag>
        <tag>CSS3</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[31-弹性布局介绍]]></title>
    <url>%2Fposts%2F5299ef1f%2F</url>
    <content type="text"><![CDATA[弹性布局介绍 12345678910111213141516171819202122232425262728293031323334353637383940414243444546&lt;!DOCTYPE html&gt;&lt;html lang="en"&gt;&lt;head&gt; &lt;meta charset="UTF-8"&gt; &lt;meta name="viewport" content="width=device-width, initial-scale=1.0"&gt; &lt;meta http-equiv="X-UA-Compatible" content="ie=edge"&gt; &lt;title&gt;Document&lt;/title&gt; &lt;!-- 弹性布局：也叫伸缩布局 体现在“弹性两个字” 特点：如果用了弹性布局，子元素绝对不会超出父元素的主轴方向，如果你设置的值超出了，会自动缩小子元素 主要可以用在移动端，因为移动端的屏幕有大有小 --&gt; &lt;style&gt; ul&#123; list-style: none; padding: 0; width: 600px; height: 550px; border: 1px solid #000; /* 让子元素用弹性布局 */ display: flex; justify-content: center; &#125; li&#123; width: 250px; height: 150px; background: yellowgreen; &#125; &lt;/style&gt;&lt;/head&gt;&lt;body&gt; &lt;ul&gt; &lt;li&gt;1&lt;/li&gt; &lt;li&gt;2&lt;/li&gt; &lt;li&gt;3&lt;/li&gt; &lt;/ul&gt;&lt;/body&gt;&lt;/html&gt;]]></content>
      <categories>
        <category>HTML/CSS</category>
        <category>HTML5/CSS3</category>
      </categories>
      <tags>
        <tag>HTML</tag>
        <tag>HTML5</tag>
        <tag>CSS3</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[30-animation详解]]></title>
    <url>%2Fposts%2F7f95cd09%2F</url>
    <content type="text"><![CDATA[animation详解 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182&lt;!DOCTYPE html&gt;&lt;html lang="en"&gt;&lt;head&gt; &lt;meta charset="UTF-8"&gt; &lt;meta name="viewport" content="width=device-width, initial-scale=1.0"&gt; &lt;meta http-equiv="X-UA-Compatible" content="ie=edge"&gt; &lt;title&gt;Document&lt;/title&gt; &lt;!-- alternate:代表让元素复原时也有动画， 它占用一次动画效果 forwords：停在动画最终效果上 running:默认值，播放动画 paused：暂停动画 --&gt; &lt;style&gt; .box&#123; width: 100px; height: 100px; background-color: #f00; /* 参数1：剧本的名字（动画名） 参数2：动画时长 参数3：延迟时间 参数4：运动曲线 linear匀速 steps()分步骤 参数5：动画次数，如果为infinite代表无限次 参数6：默认动画结束后会复原，forwards代表停留在动画最终效果上 参数7：如果动画次数有N次的时候，在动画完了进行下一次动画之前会闪现回原来的样子没有动画效果 加一个alternate可以让复原时也有动画效果，但是它会占用动画次数 参数8：代表动画播放状态，默认是running（播放动画） 以上参数不用特意去记顺序，因为它们随便写顺序都可以，但是先写的时间一定是动画时长，后写的是延迟时间 因为它们没有顺序，所以以后需要什么效果，想到什么就写什么 例如：我想无限，我就写一个infinite 我想复原时也有动画，就写一个alternat reverse：代表反转（先闪现到动画最终样子，然后用动画效果复原到自己本身的值） alternate-reverse：还是反转，只是如果有多次动画，返回时也会有动画效果 normal：默认值，就是动画该怎样就怎样，相当于你没写参数 我想最终停在动画最终的效果，就写一个forwards */ animation: bigger 1s 0.5s linear 2 forwards alternate; /* animation-name: 动画名 */ /* animation-duration: 动画时长 */ /* animation-delay: 延迟时间 */ /* animation-timing-function: 运动曲线 */ /* animation-iteration-count: 动画次数 */ /* animation-fill-mode: 填充模式，只要记住，代表动画要不要以最终动画效果显示 */ /* animation-direction: 设置复原时要不要有动画效果 */ /* animation-play-state: 播放状态 */ /* animation: alternate forwards 2s bigger 5 .5s; */ /*animation:bigger 2s;*/ &#125; @keyframes bigger&#123; /* 我希望让元素以什么样子开始动画，就在from里写,如果不写就是以元素自身的样式开始 */ from&#123; /* width: 600px; height: 600px; background-color: #0f0; */ &#125; to&#123; width: 300px; height: 300px; &#125; &#125; &lt;/style&gt;&lt;/head&gt;&lt;body&gt; &lt;div class="box"&gt;&lt;/div&gt;&lt;/body&gt;&lt;/html&gt;]]></content>
      <categories>
        <category>HTML/CSS</category>
        <category>HTML5/CSS3</category>
      </categories>
      <tags>
        <tag>HTML</tag>
        <tag>HTML5</tag>
        <tag>CSS3</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[29-3D盒子]]></title>
    <url>%2Fposts%2Fb98edd7c%2F</url>
    <content type="text"><![CDATA[3D盒子 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107&lt;!DOCTYPE html&gt;&lt;html lang="en"&gt;&lt;head&gt; &lt;meta charset="UTF-8"&gt; &lt;meta name="viewport" content="width=device-width, initial-scale=1.0"&gt; &lt;meta http-equiv="X-UA-Compatible" content="ie=edge"&gt; &lt;title&gt;Document&lt;/title&gt; &lt;!-- 视距要加在不会动的那个父元素上要好一点 最简单的办法：一级一级往上加，直到可以就行了 --&gt; &lt;style&gt; body&#123; perspective: 1100px; &#125; ul &#123; padding: 0; list-style: none; width: 200px; height: 200px; border: 1px solid #000; margin: 220px auto; position: relative; /* 浏览器默认没有开启元素的3D显示，要开启3D */ transform-style: preserve-3d; transition: all 50s; &#125; li &#123; width: 100%; height: 100%; position: absolute; background: url(img/girl1.jpg) no-repeat left top/cover; &#125; li:nth-child(1) &#123; left: -200px; background-color: red; transform-origin: right; transform: rotateY(90deg); &#125; li:nth-child(2) &#123; top: -200px; background-color: #0f0; transform-origin: bottom; transform: rotateX(-90deg); &#125; li:nth-child(3) &#123; right: -200px; background-color: #00f; transform-origin: left; transform: rotateY(-90deg); &#125; li:nth-child(4) &#123; bottom: -200px; background-color: hotpink; transform-origin: top; transform: rotateX(90deg); &#125; li:nth-child(5) &#123; background-color: black; &#125; li:nth-child(6) &#123; background-color: purple; transform: translateZ(200px); &#125; ul:hover&#123; transform: rotateX(3600deg) rotateY(3600deg); &#125; &lt;/style&gt;&lt;/head&gt;&lt;body&gt; &lt;ul&gt; &lt;li&gt;&lt;/li&gt; &lt;li&gt;&lt;/li&gt; &lt;li&gt;&lt;/li&gt; &lt;li&gt;&lt;/li&gt; &lt;li&gt;&lt;/li&gt; &lt;li&gt;&lt;/li&gt; &lt;/ul&gt;&lt;/body&gt;&lt;/html&gt;]]></content>
      <categories>
        <category>HTML/CSS</category>
        <category>HTML5/CSS3</category>
      </categories>
      <tags>
        <tag>HTML</tag>
        <tag>HTML5</tag>
        <tag>CSS3</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[28-视距加在自身和加在父元素的区别]]></title>
    <url>%2Fposts%2F1cab4822%2F</url>
    <content type="text"><![CDATA[视距加在自身和加在父元素的区别 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576&lt;!DOCTYPE html&gt;&lt;html lang="en"&gt;&lt;head&gt; &lt;meta charset="UTF-8"&gt; &lt;meta name="viewport" content="width=device-width, initial-scale=1.0"&gt; &lt;meta http-equiv="X-UA-Compatible" content="ie=edge"&gt; &lt;title&gt;Document&lt;/title&gt; &lt;!-- 总结：视距要加在父元素身上会更像真实看到的场景 --&gt; &lt;style&gt; ul&#123; width: 600px; height: 200px; list-style: none; padding: 0; margin: 50px auto; border: 1px solid #000; &#125; li&#123; width: 180px; height: 180px; background-color: yellowgreen; margin-left: 15px; margin-top: 10px; float: left; transition: all 1s; &#125; /* 先给第一个ul里所有的li加默认视距 视距加在子元素上 , 哪么就相当于每个子元素都有一个前面都有一双眼睛 */ ul:nth-child(1) li&#123; transform: perspective(600px); &#125; /* 当第一个ul在hover的时候，改它里面的li */ ul:nth-child(1):hover li&#123; transform: perspective(600px) rotateY(90deg); &#125; /* 第二个ul是把视距加在父元素的Ul上 哪么就相当于,一双眼睛在ul中,看到周围物体就是通过余光看的 */ ul:nth-child(2)&#123; /* 如果视距是加在父元素身上，不能用transform加，而应该直接用perspetive加视距 */ perspective: 600px; &#125; ul:nth-child(2):hover li&#123; transform: rotateY(90deg); &#125; &lt;/style&gt;&lt;/head&gt;&lt;body&gt; &lt;!-- 每个li都加一个视距 --&gt; &lt;ul&gt; &lt;li&gt;&lt;/li&gt; &lt;li&gt;&lt;/li&gt; &lt;li&gt;&lt;/li&gt; &lt;/ul&gt; &lt;!-- 把视距加在这个ul身上 --&gt; &lt;ul&gt; &lt;li&gt;&lt;/li&gt; &lt;li&gt;&lt;/li&gt; &lt;li&gt;&lt;/li&gt; &lt;/ul&gt;&lt;/body&gt;&lt;/html&gt;]]></content>
      <categories>
        <category>HTML/CSS</category>
        <category>HTML5/CSS3</category>
      </categories>
      <tags>
        <tag>HTML</tag>
        <tag>HTML5</tag>
        <tag>CSS3</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[27-视距是什么]]></title>
    <url>%2Fposts%2F89984939%2F</url>
    <content type="text"><![CDATA[视距是什么 12345678910111213141516171819202122232425262728&lt;!DOCTYPE html&gt;&lt;html lang="en"&gt;&lt;head&gt; &lt;meta charset="UTF-8"&gt; &lt;meta name="viewport" content="width=device-width, initial-scale=1.0"&gt; &lt;meta http-equiv="X-UA-Compatible" content="ie=edge"&gt; &lt;title&gt;Document&lt;/title&gt; &lt;!-- 视距：其实就是相当于模拟出一个“眼睛”到物体的距离，所以距离越大，证明你的眼睛到物体的距离就远，远的话效果就小，近的话效果就大 验证一下视距就是模拟眼睛到物体的距离 所以加一个视距就相当于加一个“眼睛”去看它 --&gt; &lt;style&gt; img&#123; display: block; margin: 100px auto; transform: perspective(1000px) translateZ(0px); &#125; &lt;/style&gt;&lt;/head&gt;&lt;body&gt; &lt;img src="img/dog2.jpg" alt=""&gt;&lt;/body&gt;&lt;/html&gt;]]></content>
      <categories>
        <category>HTML/CSS</category>
        <category>HTML5/CSS3</category>
      </categories>
      <tags>
        <tag>HTML</tag>
        <tag>HTML5</tag>
        <tag>CSS3</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[26-三维旋转]]></title>
    <url>%2Fposts%2F1117735f%2F</url>
    <content type="text"><![CDATA[三维旋转 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374&lt;!DOCTYPE html&gt;&lt;html lang="en"&gt;&lt;head&gt; &lt;meta charset="UTF-8"&gt; &lt;meta name="viewport" content="width=device-width, initial-scale=1.0"&gt; &lt;meta http-equiv="X-UA-Compatible" content="ie=edge"&gt; &lt;title&gt;Document&lt;/title&gt; &lt;!-- 不管是三维还是二维，改的都是transform 如果想要效果明显一点就要加一个视距，而且视距遵循近大远小的特点，距离越近，效果越明显，距离越远效果越不明显 X轴旋转：上下旋转，想到单杠 Y轴旋转：左右旋转，想到钢管舞 Z轴旋转：顺时针或者逆时针旋转，想到大风车 --&gt; &lt;style&gt; ul&#123; width: 600px; height: 200px; padding: 0; list-style: none; border: 1px solid #000; margin: 100px auto; &#125; li&#123; width: 180px; height: 180px; margin-left: 15px; margin-top: 10px; float: left; background-color: yellowgreen; transition: all 1s; /* 默认也加一个视距 因为如果不加,哪么在过渡的时候视距也会从0到响应的值,可能出现bug */ transform: perspective(300px); &#125; li:nth-child(1):hover&#123; /* 沿着x轴旋转 */ transform: perspective(300px) rotateX(45deg); &#125; li:nth-child(2):hover&#123; /* 沿着y轴旋转 */ transform:perspective(300px) rotateY(45deg); &#125; li:nth-child(3):hover&#123; /* 沿着z轴旋转 */ transform:perspective(600px) rotate(45deg); /* 其实rotate就是沿着z轴旋转 */ /* transform: rotateZ(45deg); */ &#125; &lt;/style&gt;&lt;/head&gt;&lt;body&gt; &lt;ul&gt; &lt;li&gt;x轴旋转&lt;/li&gt; &lt;li&gt;y轴旋转&lt;/li&gt; &lt;li&gt;z轴旋转&lt;/li&gt; &lt;/ul&gt;&lt;/body&gt;&lt;/html&gt;]]></content>
      <categories>
        <category>HTML/CSS</category>
        <category>HTML5/CSS3</category>
      </categories>
      <tags>
        <tag>HTML</tag>
        <tag>HTML5</tag>
        <tag>CSS3</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[25-三维坐标系]]></title>
    <url>%2Fposts%2F6bd1e7e7%2F</url>
    <content type="text"><![CDATA[三维坐标系 123456二维坐标：x和y轴三维坐标：x和y,z轴，三个轴 x：水平方向（左右） 平移就是左右平移 y：垂直方向（上下） 平移就是上下平移 z：前后方向（远近） 平移就是前后平移]]></content>
      <categories>
        <category>HTML/CSS</category>
        <category>HTML5/CSS3</category>
      </categories>
      <tags>
        <tag>HTML</tag>
        <tag>HTML5</tag>
        <tag>CSS3</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[24-拖拽图片到浏览器并预览]]></title>
    <url>%2Fposts%2F759712a5%2F</url>
    <content type="text"><![CDATA[拖拽图片到浏览器并预览 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960&lt;!DOCTYPE html&gt;&lt;html lang="en"&gt;&lt;head&gt; &lt;meta charset="UTF-8"&gt; &lt;meta name="viewport" content="width=device-width, initial-scale=1.0"&gt; &lt;meta http-equiv="X-UA-Compatible" content="ie=edge"&gt; &lt;title&gt;Document&lt;/title&gt; &lt;style&gt; html,body&#123; height:100%; &#125; body&#123; border:10px dashed black; &#125; &lt;/style&gt;&lt;/head&gt;&lt;body&gt; &lt;h1&gt;拖拽图片到虚线内&lt;/h1&gt;&lt;/body&gt;&lt;/html&gt;&lt;!-- 网页有一个默认的drop事件的行为，默认drop事件的行为就是打开这个文件 --&gt;&lt;script&gt; //要用drop还必须先要用dragover事件 document.body.ondragover = function(e)&#123; e = e || window.event; e.preventDefault(); &#125; //给网页加一个drop（可以给body也可以给document） document.body.ondrop = function(e)&#123; e = e || window.event; // console.log('...'); //这个事件它有没有默认的行为？？有 //什么行为？是打开你拖拽的文件（相对于要离开你的网页） e.preventDefault(); //咱们要把拖拽进来的图片给预览一下 //首先就要找到这个图片，然后转成URL //拖拽进来的图片在事件对象的dataTransfer属性的files里面，取下标0就是我们那个图片 // console.log(e.dataTransfer.files[0]); //转成临时URL var url = URL.createObjectURL(e.dataTransfer.files[0]); //给body document.body.style.background = "url(" + url +") no-repeat"; //如果要拖拽上传文件，其实就是把文件加到FormData里，再用ajax提交到服务器就可以了 // var fm = new FormData(); // fm.append('icon',e.dataTransfer.files[0]); &#125;&lt;/script&gt;]]></content>
      <categories>
        <category>HTML/CSS</category>
        <category>HTML5/CSS3</category>
      </categories>
      <tags>
        <tag>HTML</tag>
        <tag>HTML5</tag>
        <tag>CSS3</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[23-跟目标元素（容器元素）有关的拖拽]]></title>
    <url>%2Fposts%2F55ec7be6%2F</url>
    <content type="text"><![CDATA[跟目标元素（容器元素）有关的拖拽 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990&lt;!DOCTYPE html&gt;&lt;html lang="en"&gt;&lt;head&gt; &lt;meta charset="UTF-8"&gt; &lt;meta name="viewport" content="width=device-width, initial-scale=1.0"&gt; &lt;meta http-equiv="X-UA-Compatible" content="ie=edge"&gt; &lt;title&gt;Document&lt;/title&gt; &lt;!-- 跟目标元素有关的事件： ondragenter：代表有元素拖进来触发，只触发一次，进来一次触发一次 ondragleave：代表有元素从我这离开触发，只触发一次，出去一次触发一次 ondragover： 代表有元素在我的范围内不断触发（一般用这个事件只是为了配合ondrop使用，在里面阻止事件默认行为让元素允许能被拖进来） ondrop：有元素拖拽到我的范围内松手触发的事件。但是这个事件要想能被触发，必须先写ondragover事件，并且再over事件里阻止事件默认行为 --&gt; &lt;style&gt; .box&#123; width: 100px; height: 100px; background-color: #f00; &#125; .container&#123; width: 400px; height: 500px; border: 1px solid #000; position: absolute; right:20px; top:10px; &#125; &lt;/style&gt;&lt;/head&gt;&lt;body&gt; &lt;div class="box" draggable="true"&gt;&lt;/div&gt; &lt;div class="container"&gt;&lt;/div&gt;&lt;/body&gt;&lt;/html&gt;&lt;script&gt; //找到两个div var box = document.querySelector('.box'); var container = document.querySelector('.container'); //给红div加一个拖拽结束事件 // box.ondragend = function()&#123; // //把box加到container里面 // container.appendChild(box); // &#125; //当有元素拖拽到我的范围内触发的事件 拖拽进来触发的事件 container.ondragenter = function()&#123; console.log('有元素进来了'); // container.appendChild(box); &#125; //当有元素拖拽离开时触发 container.ondragleave = function()&#123; console.log('有元素出去了'); &#125; container.ondragover = function(e)&#123; //只要有元素拖拽到我的范围内而且还没松手时不断触发的事件 console.log('over'); e.preventDefault(); &#125; //这个事件是当有元素拖进来，并且在我的范围内松开才触发的事件 //这个事件有点特殊：如果想它能被触发，还要先写另外一个事件叫ondragover事件，并且在dragover这个事件里阻止事件的默认行为 //原因：是因为容器（目标元素）默认都不允许别的元素拖拽进来，所以你要在范围内里先阻止这个默认行为，才能触发我们这个drop事件 container.ondrop = function()&#123; // console.log('....'); container.appendChild(box); &#125;&lt;/script&gt;]]></content>
      <categories>
        <category>HTML/CSS</category>
        <category>HTML5/CSS3</category>
      </categories>
      <tags>
        <tag>HTML</tag>
        <tag>HTML5</tag>
        <tag>CSS3</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[22-计算相对于自身的x和y]]></title>
    <url>%2Fposts%2F29d3571a%2F</url>
    <content type="text"><![CDATA[计算相对于自身的x和y 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566&lt;!DOCTYPE html&gt;&lt;html lang="en"&gt;&lt;head&gt; &lt;meta charset="UTF-8"&gt; &lt;meta name="viewport" content="width=device-width, initial-scale=1.0"&gt; &lt;meta http-equiv="X-UA-Compatible" content="ie=edge"&gt; &lt;title&gt;Document&lt;/title&gt; &lt;!-- 最新计算相对于自身左上角的x和y的算法是 先获取盒子相对于可视区域的x和y 怎么获取？ 元素.getBoundingClientRect(); 算法是： x = e.clientX - 盒子可视区域的x - 左边框宽度 y = e.clientY - 盒子可视区域的y - 上边框宽度 --&gt; &lt;style&gt; .box&#123; width: 100px; height: 100px; background-color: #f00; /* border:10px solid black; */ position: absolute; left:0; top:1500px; background:radial-gradient() &#125; &lt;/style&gt;&lt;/head&gt;&lt;body&gt; &lt;div class="father"&gt; &lt;div class="box" &gt;&lt;/div&gt; &lt;/div&gt;&lt;/body&gt;&lt;/html&gt;&lt;script&gt; var box = document.querySelector('.box'); box.onmousedown = function(e)&#123; //offsetLeft是获取到自身左外边框到定位父级元素的内边框的位置 // var x = e.pageX - box.offsetLeft; // var y = e.pageY - box.offsetTop; // console.log(x,y); e = e || window.event; // console.log(e.screenX,e.screenY); // console.log(e.pageX,e.pageY); // // 获取可视区域的x和y // console.log(e.clientX,e.clientY); //获得自身盒子到可视区域的一个距离（但是得到的是一个对象） var rect = box.getBoundingClientRect(); console.log(rect); var x = e.clientX - rect.x - box.clientLeft; var y = e.clientY - rect.y - box.clientTop; console.log(x,y); &#125;&lt;/script&gt;]]></content>
      <categories>
        <category>HTML/CSS</category>
        <category>HTML5/CSS3</category>
      </categories>
      <tags>
        <tag>HTML</tag>
        <tag>HTML5</tag>
        <tag>CSS3</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[21-拖拽]]></title>
    <url>%2Fposts%2F5f0b1282%2F</url>
    <content type="text"><![CDATA[拖拽 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980&lt;!DOCTYPE html&gt;&lt;html lang="en"&gt;&lt;head&gt; &lt;meta charset="UTF-8"&gt; &lt;meta name="viewport" content="width=device-width, initial-scale=1.0"&gt; &lt;meta http-equiv="X-UA-Compatible" content="ie=edge"&gt; &lt;title&gt;Document&lt;/title&gt; &lt;!-- 元素不是你想拖，想拖就能拖 强行拖：给元素加一个draggable属性，值等于true就可以了 拖拽的三个事件： ondragstart 拖拽开始 ondrag 拖拽中 ondragend 拖拽结束 --&gt; &lt;style&gt; img&#123; width: 200px; height: 300px; &#125; .box&#123; width: 100px; height: 100px; background-color: #f00; position: absolute; &#125; &lt;/style&gt;&lt;/head&gt;&lt;body&gt; &lt;img src="img/girl1.jpg" alt=""&gt; &lt;div class="box" draggable="true"&gt;&lt;/div&gt;&lt;/body&gt;&lt;/html&gt;&lt;script&gt; var box = document.querySelector('.box'); //拖拽开始事件 box.ondragstart = function()&#123; console.log('start'); &#125; //拖拽中触发的事件 box.ondrag = function()&#123; console.log('拖拽ing'); &#125; //拖拽结束的事件:所有事件触发时的信息都在事件对象里面 box.ondragend = function(e)&#123; // console.log('end'); e = e || window.event; // console.log(e); box.style.left = e.pageX -x + "px"; box.style.top = e.pageY -y + "px"; &#125; var x,y; //鼠标按下事件 box.onmousedown = function(e)&#123; //不建议使用，因为不是标准语法，可能有bug 测试可用 console.log(e.offsetX,e.offsetY); x = e.offsetX; y = e.offsetY; &#125;&lt;/script&gt;]]></content>
      <categories>
        <category>HTML/CSS</category>
        <category>HTML5/CSS3</category>
      </categories>
      <tags>
        <tag>HTML</tag>
        <tag>HTML5</tag>
        <tag>CSS3</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[20-sessionStorage]]></title>
    <url>%2Fposts%2F7dd67539%2F</url>
    <content type="text"><![CDATA[sessionStorage 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354&lt;!DOCTYPE html&gt;&lt;html lang="en"&gt;&lt;head&gt; &lt;meta charset="UTF-8"&gt; &lt;meta name="viewport" content="width=device-width, initial-scale=1.0"&gt; &lt;meta http-equiv="X-UA-Compatible" content="ie=edge"&gt; &lt;title&gt;Document&lt;/title&gt; &lt;!-- sessionStorage跟session没有半毛钱关系，它们仅仅是名字很像 sessionStorage的用法跟localStorage的用法是一样一样的！ sessionStorage可以理解为是一个短命版的localStorage localStorage是只要自己不删就一直存在，而sessionStroage是关掉浏览器就没有了 有一些数据如果需要临时保存一下就可以用sessionStorage --&gt;&lt;/head&gt;&lt;body&gt; &lt;input type="button" value="保存数据" id="btn1"&gt; &lt;input type="button" value="读取数据" id="btn2"&gt; &lt;input type="button" value="删除数据" id="btn3"&gt; &lt;input type="button" value="清空数据" id="btn4"&gt;&lt;/body&gt;&lt;/html&gt;&lt;script&gt; document.getElementById('btn1').onclick = function()&#123; sessionStorage.setItem('name','jack'); sessionStorage.setItem('age',16); sessionStorage.setItem('height',160); &#125; document.getElementById('btn2').onclick = function()&#123; var res = sessionStorage.getItem('name'); console.log(res); &#125; document.getElementById('btn3').onclick = function()&#123; sessionStorage.removeItem('name'); &#125; document.getElementById('btn4').onclick = function()&#123; sessionStorage.clear(); &#125;&lt;/script&gt;]]></content>
      <categories>
        <category>HTML/CSS</category>
        <category>HTML5/CSS3</category>
      </categories>
      <tags>
        <tag>HTML</tag>
        <tag>HTML5</tag>
        <tag>CSS3</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[19-localStorage本地存储]]></title>
    <url>%2Fposts%2F5e986dca%2F</url>
    <content type="text"><![CDATA[localStorage本地存储 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126&lt;!DOCTYPE html&gt;&lt;html lang="en"&gt;&lt;head&gt; &lt;meta charset="UTF-8"&gt; &lt;meta name="viewport" content="width=device-width, initial-scale=1.0"&gt; &lt;meta http-equiv="X-UA-Compatible" content="ie=edge"&gt; &lt;title&gt;Document&lt;/title&gt; &lt;!-- localStorage：本地存储 把数据存储在浏览器端的技术 它没有有效期，也就是说只要你自己不手动删除（包括自己清浏览器数据，自己写代码删除），它就会一直存在 它不会自动发送给服务器，除非你自己写代码取出来 localStorage是按域名来存的，所以不同的网站之间不能访问到彼此的本地存储 cookie也是存在浏览器端 cookie存在有效期，有效期一到就自动删除 如果浏览器端存的是cookie，那么每次访问这个网站，都会自动把cookie发送给服务器 使用的方法 setItem() 存储一个数据，要传入key和value getItem() 读取一个数据，要传入key removerItem() 删除一个数据，要传入key clear() 清空所有数据，毛都不传 localStorage只能存储基本数据类型，如果传入的是复杂类型，它会先调用复杂类型的toString()方法，然后再存储 这样不好，所以如果要存复杂类型，那么可以先把复杂类型转成JSON字符串再来保存 取出来的时候，就可以把这个JSON字符串再转成JS的复杂类型就行了 它可以做本地缓存，有些数据就没必要存在服务器了，直接存在每个浏览器里做一个缓存了 --&gt;&lt;/head&gt;&lt;body&gt; &lt;input type="button" value="存储一个数据" id="btn1"&gt; &lt;input type="button" value="读取一个数据" id="btn2"&gt; &lt;input type="button" value="删除一个数据" id="btn3"&gt; &lt;input type="button" value="清空所有数据" id="btn4"&gt; &lt;input type="button" value="存储一个数组" id="btn5"&gt; &lt;input type="button" value="读取一个数组" id="btn6"&gt; &lt;input type="button" value="存储一个对象" id="btn7"&gt; &lt;input type="button" value="读取一个对象" id="btn8"&gt;&lt;/body&gt;&lt;/html&gt;&lt;script&gt; //当我点击这个按钮，我就存储一个数据到localStorage document.getElementById('btn1').onclick = function()&#123; //存储一个数据 //参数1：key //参数2：value localStorage.setItem('name','jack'); localStorage.setItem('age','16'); localStorage.setItem('height','1765'); localStorage.setItem('width','40kg'); &#125; //读取出数据 document.getElementById('btn2').onclick = function()&#123; //读取出的数据会当返回值返回 var res = localStorage.getItem('name'); console.log(res); &#125; //删除数据 document.getElementById('btn3').onclick = function()&#123; //根据key来删 localStorage.removeItem('name'); &#125; //清空数据 document.getElementById('btn4').onclick = function()&#123; localStorage.clear(); &#125; //存数组 document.getElementById('btn5').onclick = function()&#123; var arr = [10,20,30,40,50]; // console.log(arr.toString()); //先转成JSON再存储 var json = JSON.stringify(arr); localStorage.setItem('arr',json); &#125; //取数组 document.getElementById('btn6').onclick = function()&#123; var res = localStorage.getItem('arr'); var arr = JSON.parse(res); console.log(arr); &#125; //存对象 document.getElementById('btn7').onclick = function()&#123; var obj = &#123; name:"jack",age:16 &#125;; // console.log(obj.toString()); var json = JSON.stringify(obj); localStorage.setItem('obj',json); &#125; //取对象 document.getElementById('btn8').onclick = function()&#123; var res = localStorage.getItem('obj'); var obj = JSON.parse(res); console.log(obj); &#125;&lt;/script&gt;]]></content>
      <categories>
        <category>HTML/CSS</category>
        <category>HTML5/CSS3</category>
      </categories>
      <tags>
        <tag>HTML</tag>
        <tag>HTML5</tag>
        <tag>CSS3</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[18-地理定位]]></title>
    <url>%2Fposts%2Fee64ee8c%2F</url>
    <content type="text"><![CDATA[地理定位 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354&lt;!DOCTYPE html&gt;&lt;html lang="en"&gt;&lt;head&gt; &lt;meta charset="UTF-8"&gt; &lt;meta name="viewport" content="width=device-width, initial-scale=1.0"&gt; &lt;meta http-equiv="X-UA-Compatible" content="ie=edge"&gt; &lt;title&gt;Document&lt;/title&gt; &lt;!-- 地理定位：获取你当前在地球上的经纬度 究竟JS里如何获取经纬度？ 定位的技术： GPS定位： 首先设备上要装GPS模块，然后如果有这个模块就可以连接卫星，连接卫星，卫星就可以定位到你这个信号源所在的经纬度 它的精确度是最高的 电脑没有GPS模块 WIFI定位： 利用的是服务器的大数据。 例：有一天你在星巴克喝了咖啡，刚好又连了星巴克的wifi，再然后刚好你又打开了百度地图。那么这个时候百度地图会收集到你当前的定位位置，和这个星巴克WIFI的MAC地址，就把这些信息记录到服务器了 那么下一次，假如说李四带着笔记本来这家星巴克上网，连了wifi，虽然它的笔记本没有GPS，但是百度依然知道它在哪。 WIFI定位其实也可以用来辅助GPS定位，让定位更精确。 你只要打开wifi功能后，就会搜索附近的wifi信号，而信号有强有弱，它就根据你这些wifi信号大致推断你在哪个位置 网络基站定位： 只要你能联网，都要通过运营商的基站去上网。 因为类似于WIFI定位，服务器上存了你基站的位置，然后发现你上网的时候是通过这个基站发出的上网请求，所以就能够推断你大致在哪 因为一个片区都是用基站上网，所以它获取经纬度的误差是最大的 --&gt;&lt;/head&gt;&lt;body&gt; &lt;/body&gt;&lt;/html&gt;&lt;script&gt; // 获取经纬度 // 如果获取到经纬度了，那么会调用这个回调函数，而且会把经纬度的信息当做形参传进来 navigator.geolocation.getCurrentPosition(function(loc)&#123; console.log("纬度是：" + loc.coords.latitude + "经度是:" + loc.coords.longitude); &#125;);&lt;/script&gt;]]></content>
      <categories>
        <category>HTML/CSS</category>
        <category>HTML5/CSS3</category>
      </categories>
      <tags>
        <tag>HTML</tag>
        <tag>HTML5</tag>
        <tag>CSS3</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[17-先旋转后平移的影响]]></title>
    <url>%2Fposts%2F87ba6748%2F</url>
    <content type="text"><![CDATA[先旋转后平移的影响 1234567891011121314151617181920212223242526272829303132333435363738&lt;!DOCTYPE html&gt;&lt;html lang="en"&gt;&lt;head&gt; &lt;meta charset="UTF-8"&gt; &lt;meta name="viewport" content="width=device-width, initial-scale=1.0"&gt; &lt;meta http-equiv="X-UA-Compatible" content="ie=edge"&gt; &lt;title&gt;Document&lt;/title&gt; &lt;!-- 如果要写多个形变，用空格隔开，千万不能用逗号，用逗号不会生效 如果先旋转再平移，那么坐标轴会发生变化，你平移的位置也是旋转后的位置来平移的 建议先平移后接旋转,比较符合常规坐标 --&gt; &lt;style&gt; .box&#123; width: 200px; height: 200px; background-color: yellowgreen; margin: 100px auto; transition: all 1s; &#125; .box:hover&#123; /* 代表先旋转45度，再往右平移400像素 */ transform: rotate(45deg) translate(400px); &#125; &lt;/style&gt;&lt;/head&gt;&lt;body&gt; &lt;div class="box"&gt;&lt;/div&gt;&lt;/body&gt;&lt;/html&gt;]]></content>
      <categories>
        <category>HTML/CSS</category>
        <category>HTML5/CSS3</category>
      </categories>
      <tags>
        <tag>HTML</tag>
        <tag>HTML5</tag>
        <tag>CSS3</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[16-2D变换]]></title>
    <url>%2Fposts%2Ff5cd5b38%2F</url>
    <content type="text"><![CDATA[2D变换 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879&lt;!DOCTYPE html&gt;&lt;html lang="en"&gt;&lt;head&gt; &lt;meta charset="UTF-8"&gt; &lt;meta name="viewport" content="width=device-width, initial-scale=1.0"&gt; &lt;meta http-equiv="X-UA-Compatible" content="ie=edge"&gt; &lt;title&gt;Document&lt;/title&gt; &lt;style&gt; /* 任何变换都是改的transform属性，哪怕后天我们要学的3D变换也是改transform属性 */ ul&#123; width: 300px; height: 300px; padding: 0; list-style: none; margin: 100px auto; &#125; li&#123; width: 140px; height: 140px; background-color: yellowgreen; float: left; margin-left: 10px; margin-top:10px; transition: all 1s; &#125; li:nth-child(1):hover&#123; /* 传入角度单位是deg，给正是顺时针旋转，给负是逆时针旋转 */ transform: rotate(-45deg); &#125; li:nth-child(2):hover&#123; /* 参数1：x轴方向的平移,正往右，负往左 参数2：y轴方向的平移，正往下，负往上 如果只给一个参数，那么只平移x轴 */ transform: translate(-200px,-200px); &#125; li:nth-child(3):hover&#123; /* 传的是倍数，不用带单位 参数1：x轴方向缩放（宽度的缩放） 参数2：y轴方向缩放（高度的缩放） */ /* transform: scale(.2,2.5); */ /* 如果只给一个参数：宽高都影响 */ transform: scale(1.5); &#125; li:nth-child(4):hover&#123; /* 倾斜(平行四边形) 传入的也是角度 */ transform: skew(-15deg); &#125; &lt;/style&gt;&lt;/head&gt;&lt;body&gt; &lt;ul&gt; &lt;li&gt;旋转&lt;/li&gt; &lt;li&gt;平移&lt;/li&gt; &lt;li&gt;缩放&lt;/li&gt; &lt;li&gt;扭曲（倾斜）&lt;/li&gt; &lt;/ul&gt;&lt;/body&gt;&lt;/html&gt;]]></content>
      <categories>
        <category>HTML/CSS</category>
        <category>HTML5/CSS3</category>
      </categories>
      <tags>
        <tag>HTML</tag>
        <tag>HTML5</tag>
        <tag>CSS3</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[15-径向渐变]]></title>
    <url>%2Fposts%2Fed1f2a00%2F</url>
    <content type="text"><![CDATA[径向渐变 1234567891011121314151617181920212223242526272829303132333435&lt;!DOCTYPE html&gt;&lt;html lang="en"&gt;&lt;head&gt; &lt;meta charset="UTF-8"&gt; &lt;meta name="viewport" content="width=device-width, initial-scale=1.0"&gt; &lt;meta http-equiv="X-UA-Compatible" content="ie=edge"&gt; &lt;title&gt;Document&lt;/title&gt; &lt;style&gt; .box&#123; width: 300px; height: 300px; border: 1px solid #000; margin: 100px auto; /* 不管是线性渐变还是径向渐变，都是相当于当做背景图片来处理的 */ /* 参数1：指定圆的大小和圆心的位置 参数2：颜色1 参数3：颜色2 至少需要2个颜色，多了不限。 圆的大小外面部分是用最后一个颜色填充 第一个颜色给百分比代表什么位置结束 后面每个颜色给百分比代表什么位置开始，如果需要给后面的颜色结束位置，需要再写一个颜色，指定百分比，这个百分比就是结束的位置 */ background-image: radial-gradient(100px at center,red 30%,green 30%,green 60%,blue 60%); &#125; &lt;/style&gt;&lt;/head&gt;&lt;body&gt; &lt;div class="box"&gt;&lt;/div&gt;&lt;/body&gt;&lt;/html&gt;]]></content>
      <categories>
        <category>HTML/CSS</category>
        <category>HTML5/CSS3</category>
      </categories>
      <tags>
        <tag>HTML</tag>
        <tag>HTML5</tag>
        <tag>CSS3</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[14-线性渐变]]></title>
    <url>%2Fposts%2F3264c222%2F</url>
    <content type="text"><![CDATA[线性渐变 12345678910111213141516171819202122232425262728293031323334353637383940414243444546&lt;!DOCTYPE html&gt;&lt;html lang="en"&gt;&lt;head&gt; &lt;meta charset="UTF-8"&gt; &lt;meta name="viewport" content="width=device-width, initial-scale=1.0"&gt; &lt;meta http-equiv="X-UA-Compatible" content="ie=edge"&gt; &lt;title&gt;Document&lt;/title&gt; &lt;style&gt; .box&#123; width: 300px; height: 200px; border: 1px solid #000; /* 把渐变色不是当背景颜色，而是当背景图片，所以要给background属性 参数1：渐变的方向 to right： 从左到右 to top： 从下到上 to bottom： 从上到下 to left： 从右到左 to right top： 从左下到右上 to right bottom： 从左上到右下 to left top： 从右下到左上 to left bottom： 从右上到左下 除了可以写上面的方向，也可以传入角度,0deg是从下面开始 越大，就越顺时针旋转方向 参数2：第一个颜色 可以写一个百分比，意思是代表在哪个位置结束 参数3：第二个颜色 写可以写一个百分比，代表在哪个位置开始 如果要指定第二个颜色在哪结束，那么就需要再写一个这样的颜色,然后写一个百分比就代表它在哪个位置结束了 至少2个颜色，最多有n个颜色 只有第一个颜色写百分比是代表结束，后面每个颜色写百分比都代表开始，如果要让后面的颜色指定结束，就需要写一个相同的颜色再写一个百分比，指定它的结束位置 */ /* background-image: linear-gradient(to left bottom,red,blue,green,hotpink,orange); */ /* background-image: linear-gradient(0deg,red,blue,green,hotpink,orange); */ background-image: linear-gradient(to right,red 30%,blue 30%, blue 60%, green 60%); &#125; &lt;/style&gt;&lt;/head&gt;&lt;body&gt; &lt;div class="box"&gt;&lt;/div&gt;&lt;/body&gt;&lt;/html&gt;]]></content>
      <categories>
        <category>HTML/CSS</category>
        <category>HTML5/CSS3</category>
      </categories>
      <tags>
        <tag>HTML</tag>
        <tag>HTML5</tag>
        <tag>CSS3</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[13-background详解]]></title>
    <url>%2Fposts%2F723cb6d3%2F</url>
    <content type="text"><![CDATA[background详解 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566&lt;!DOCTYPE html&gt;&lt;html lang="en"&gt;&lt;head&gt; &lt;meta charset="UTF-8"&gt; &lt;meta name="viewport" content="width=device-width, initial-scale=1.0"&gt; &lt;meta http-equiv="X-UA-Compatible" content="ie=edge"&gt; &lt;title&gt;Document&lt;/title&gt; &lt;style&gt; .box&#123; width: 1000px; height: 1000px; border: 1px solid #000; margin: 100px auto; /* 参数1：背景图片的路径，路径包不包引号都无所谓 参数2：是否平铺，默认是repeat代表水平和垂直都平铺 no-repeat：代表不平铺，常用 repeat-x：水平方向平铺 repeat-y：垂直方向平铺 参数3：背景图片偏移位置 它需要写两个，第一个代表水平对齐，第二个代表垂直对齐 水平对齐：left,right,center 垂直对齐：top,bottom,center 如果希望水平和垂直都居中，可以只写一个center 除了写这几个单词外，还可以写偏移的像素位置 水平写负代表向左，写正代表向右 垂直写负代表向上，写正代表向下 除了写像素外，还可以写百分比,用的少 写正百分比代表向左和向上，给负代表向右和向下 写百分比跟像素的方向是相反的 参数4：指定图片的大小，它一定要写在参数3的后面，而且要加一个/ 可以给具体的像素，也可以给盒子的百分比，第一个代表宽，第二个代表高 还有特殊的两个值： cover：它一定会让图片覆盖整个盒子，图片可能会超出 contain：它一定会让盒子包含住图片，图片不会超出 图片一定不会变形，都是按比例缩放 参数5：背景颜色：注意，如果是多张背景图片，那么颜色一定要写在最后 如果多张背景图片，用逗号隔开，另外，最先写的背景图片层级最高，越后面写的层级越低 */ /* background: url("images/dog3.jpg") no-repeat 0px 0px / contain , url(images/lq.png) no-repeat 0px 0px / 100px 100px red; /* background: red; */ /* background-image: 图片路径 */ /* background-repeat: 是否平铺 */ /* background-position-x: 图片偏移位置 background-position-y: 图片偏移位置 */ /* background-size: 图片大小 */ &#125; &lt;/style&gt;&lt;/head&gt;&lt;body&gt; &lt;div class="box"&gt;&lt;/div&gt;&lt;/body&gt;&lt;/html&gt;]]></content>
      <categories>
        <category>HTML/CSS</category>
        <category>HTML5/CSS3</category>
      </categories>
      <tags>
        <tag>HTML</tag>
        <tag>HTML5</tag>
        <tag>CSS3</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[12-文字阴影]]></title>
    <url>%2Fposts%2Fe5399d92%2F</url>
    <content type="text"><![CDATA[文字阴影 12345678910111213141516171819202122232425262728293031323334353637383940&lt;!DOCTYPE html&gt;&lt;html lang="en"&gt;&lt;head&gt; &lt;meta charset="UTF-8"&gt; &lt;meta name="viewport" content="width=device-width, initial-scale=1.0"&gt; &lt;meta http-equiv="X-UA-Compatible" content="ie=edge"&gt; &lt;title&gt;Document&lt;/title&gt; &lt;style&gt; body&#123; background-color: #000; &#125; p&#123; color:white; font-size: 200px; text-align: center; transition: all 1.5s; &#125; p:hover&#123; /* 参数1：水平偏移 参数2：垂直偏移 参数3：模糊度 参数4：阴影颜色 它的阴影大小是跟文字一样大的！不可以改阴影大小，除非改文字大小 */ text-shadow: -5px -5px 10px green,-10px -10px 10px red,-15px -15px 10px yellow; &#125; &lt;/style&gt;&lt;/head&gt;&lt;body&gt; &lt;p&gt;抽利群&lt;/p&gt;&lt;/body&gt;&lt;/html&gt;]]></content>
      <categories>
        <category>HTML/CSS</category>
        <category>HTML5/CSS3</category>
      </categories>
      <tags>
        <tag>HTML</tag>
        <tag>HTML5</tag>
        <tag>CSS3</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[11-盒子阴影]]></title>
    <url>%2Fposts%2Fcd49cd03%2F</url>
    <content type="text"><![CDATA[盒子阴影 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647&lt;!DOCTYPE html&gt;&lt;html lang="en"&gt;&lt;head&gt; &lt;meta charset="UTF-8"&gt; &lt;meta name="viewport" content="width=device-width, initial-scale=1.0"&gt; &lt;meta http-equiv="X-UA-Compatible" content="ie=edge"&gt; &lt;title&gt;Document&lt;/title&gt; &lt;style&gt; body&#123; background-color: #000; &#125; .box&#123; width: 200px; height: 300px; background-color: #f00; margin: 50px auto; /* 盒子阴影 参数1：水平偏移位置 参数2：垂直偏移位置 参数3：模糊度，值越大越模糊 参数4：阴影的宽度,哪怕宽度为0其实阴影也有宽度，只不过是跟盒子一样宽，这个宽度其实是设置阴影四周再加多少宽度 参数5：阴影的颜色 参数6：是否为内阴影，加一个inset就是内阴影，不加就是外阴影 inset也可以加在最前面，建议加最后 多个阴影之间，用逗号隔开，先写的阴影，层级最高 */ box-shadow: 0px 0px 10px 10px gold,0px 0px 10px 20px blue; &#125; img&#123; display: block; margin: 20px auto; box-shadow: 0px 0px 10px 10px white; &#125; &lt;/style&gt;&lt;/head&gt;&lt;body&gt; &lt;div class="box"&gt;&lt;/div&gt; &lt;img src="images/lq.png" alt=""&gt;&lt;/body&gt;&lt;/html&gt;]]></content>
      <categories>
        <category>HTML/CSS</category>
        <category>HTML5/CSS3</category>
      </categories>
      <tags>
        <tag>HTML</tag>
        <tag>HTML5</tag>
        <tag>CSS3</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[10-伪类选择器之xxx-of-type]]></title>
    <url>%2Fposts%2F12c0de6f%2F</url>
    <content type="text"><![CDATA[伪类选择器之xxx-of-type 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778&lt;!DOCTYPE html&gt;&lt;html lang="en"&gt;&lt;head&gt; &lt;meta charset="UTF-8"&gt; &lt;meta name="viewport" content="width=device-width, initial-scale=1.0"&gt; &lt;meta http-equiv="X-UA-Compatible" content="ie=edge"&gt; &lt;title&gt;Document&lt;/title&gt; &lt;!-- :xxx-of-type： 用法跟xxx-child是一样一样的 但是xxx-child必须满足在父元素中也是第几个子元素 而xxx-of-type就是找到第几个，不要求满足在父元素中是第几个 --&gt; &lt;style&gt; /* 在那个区域里找到第一个li,不需要是在父元素中是第一个子元素 */ li:first-of-type&#123; color:red; &#125; /* 找到最后一个li，不需要在父元素中是最后一个子元素 */ li:last-of-type&#123; color:blue; &#125; /* 你写3，它就是找到第三个li，不要求是父元素中的第三个子元素 */ li:nth-of-type(3)&#123; color:green; &#125; /*从第五个li开始，但是要除掉第八个以外的li */ li:nth-of-type(n+5):not(:nth-of-type(8))&#123; /* even odd 都可以，7n可以 n也可以，跟nth-child用法是一样的，只是效果略微不一样 */ font-size: 20px; &#125; &lt;/style&gt;&lt;/head&gt;&lt;body&gt; &lt;ul&gt; &lt;span&gt;我是span&lt;/span&gt; &lt;li&gt;隔壁老王1&lt;/li&gt; &lt;li&gt;隔壁老王2&lt;/li&gt; &lt;li&gt;隔壁老王3&lt;/li&gt; &lt;li&gt;隔壁老王4&lt;/li&gt; &lt;li&gt;隔壁老王5&lt;/li&gt; &lt;li&gt;隔壁老王6&lt;/li&gt; &lt;li&gt;隔壁老王7&lt;/li&gt; &lt;li&gt;隔壁老王8&lt;/li&gt; &lt;li&gt;隔壁老王9&lt;/li&gt; &lt;li&gt;隔壁老王10&lt;/li&gt; &lt;span&gt;我在最后&lt;/span&gt; &lt;/ul&gt; &lt;ul&gt; &lt;li&gt;隔壁老周1&lt;/li&gt; &lt;li&gt;隔壁老周2&lt;/li&gt; &lt;li&gt;隔壁老周3&lt;/li&gt; &lt;li&gt;隔壁老周4&lt;/li&gt; &lt;li&gt;隔壁老周5&lt;/li&gt; &lt;li&gt;隔壁老周6&lt;/li&gt; &lt;li&gt;隔壁老周7&lt;/li&gt; &lt;li&gt;隔壁老周8&lt;/li&gt; &lt;li&gt;隔壁老周9&lt;/li&gt; &lt;li&gt;隔壁老周10&lt;/li&gt; &lt;/ul&gt;&lt;/body&gt;&lt;/html&gt;]]></content>
      <categories>
        <category>HTML/CSS</category>
        <category>HTML5/CSS3</category>
      </categories>
      <tags>
        <tag>HTML</tag>
        <tag>HTML5</tag>
        <tag>CSS3</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[09-伪类选择器]]></title>
    <url>%2Fposts%2F12c0de6f%2F</url>
    <content type="text"><![CDATA[伪类选择器 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101&lt;!DOCTYPE html&gt;&lt;html lang="en"&gt;&lt;head&gt; &lt;meta charset="UTF-8"&gt; &lt;meta name="viewport" content="width=device-width, initial-scale=1.0"&gt; &lt;meta http-equiv="X-UA-Compatible" content="ie=edge"&gt; &lt;title&gt;Document&lt;/title&gt; &lt;!-- :hover：悬停样式 :link：未点击时的样式 :active：点击时的样式 :visited：访问后的样式 这是a标签的四种状态样式，但是上面这四个伪类，一般都是给a用的，只有hover所有元素都用 伪类选择器前面一点有一个冒号 :xxx-child：必须保证在父元素中是第几个子元素 :first-child：找到第一个子元素，它在父元素中也必须是第一个子元素 :last-child：找到最后一个子元素，它在父元素中也必须是最后一个子元素 :nth-child：找到某个子元素 nth-child里可以写任意数字，就代表找到第几个 也可以写n：代表找到所有 还可以写n+m：代表找到从m开始以及后面所有 例：n+3 从3开始 还可以写mn: 代表m的倍数 3n 代表3的倍数 还可以写mn-1: 代表m的倍数前一位 3n-1 代表3的倍数的前一位 还可以写even：代表偶数 还可以写odd：代表奇数 --&gt; &lt;style&gt; li:first-child&#123; color:red; &#125; li:last-child&#123; color:blue; &#125; /* 找到第三个子元素li */ li:nth-child(3)&#123; font-style: italic; &#125; /* n就代表所有 */ li:nth-child(n)&#123; border:1px solid black; &#125; /* 3的倍数 */ li:nth-child(3n)&#123; color:hotpink; &#125; /* 3的倍数前一位 */ li:nth-child(3n-1)&#123; color:purple; &#125; /* 从3开始以及后面所有 */ li:nth-child(n+3)&#123; font-size: 20px; &#125; /* 偶数 */ li:nth-child(even)&#123; background-color: yellowgreen; &#125; /* 奇数 */ li:nth-child(odd)&#123; background-color: skyblue; &#125; &lt;/style&gt;&lt;/head&gt;&lt;body&gt; &lt;ul&gt; &lt;span&gt;我是span&lt;/span&gt; &lt;li&gt;隔壁老王1&lt;/li&gt; &lt;li&gt;隔壁老王2&lt;/li&gt; &lt;li&gt;隔壁老王3&lt;/li&gt; &lt;li&gt;隔壁老王4&lt;/li&gt; &lt;li&gt;隔壁老王5&lt;/li&gt; &lt;li&gt;隔壁老王6&lt;/li&gt; &lt;li&gt;隔壁老王7&lt;/li&gt; &lt;li&gt;隔壁老王8&lt;/li&gt; &lt;li&gt;隔壁老王9&lt;/li&gt; &lt;span&gt;我在最后&lt;/span&gt; &lt;/ul&gt;&lt;/body&gt;&lt;/html&gt;]]></content>
      <categories>
        <category>HTML/CSS</category>
        <category>HTML5/CSS3</category>
      </categories>
      <tags>
        <tag>HTML</tag>
        <tag>HTML5</tag>
        <tag>CSS3</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[08-box-sizing初见]]></title>
    <url>%2Fposts%2F84ffbeb1%2F</url>
    <content type="text"><![CDATA[box-sizing初见 123456789101112131415161718192021222324252627282930313233343536&lt;!DOCTYPE html&gt;&lt;html lang="en"&gt;&lt;head&gt; &lt;meta charset="UTF-8"&gt; &lt;meta name="viewport" content="width=device-width, initial-scale=1.0"&gt; &lt;meta http-equiv="X-UA-Compatible" content="ie=edge"&gt; &lt;title&gt;Document&lt;/title&gt; &lt;!-- 默认情况下，加边框和内边距都是往外扩，那么会增大盒子占的范围 美工出的设计图告诉你说盒子总共占100*100，而且有边框，那么如果你按照默认形式写，会超出。所以我们的解决办法是：把宽和高减去border的宽高 这样做很麻烦 所以有个属性叫box-sizing,可以让我们让边框和内边距不要往外扩 --&gt; &lt;style&gt; .box&#123; width: 100px; height: 100px; background-color: #f00; border:10px solid black; padding: 10px; /* border-box:让边框和内边距都是内聚，而不是外扩 content-box：默认值，代表外扩 */ box-sizing: border-box; &#125; &lt;/style&gt;&lt;/head&gt;&lt;body&gt; &lt;div class="box"&gt;&lt;/div&gt;&lt;/body&gt;&lt;/html&gt;]]></content>
      <categories>
        <category>HTML/CSS</category>
        <category>HTML5/CSS3</category>
      </categories>
      <tags>
        <tag>HTML</tag>
        <tag>HTML5</tag>
        <tag>CSS3</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[07-用JS加transition动画]]></title>
    <url>%2Fposts%2F8a12b85b%2F</url>
    <content type="text"><![CDATA[用JS加transition动画 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263&lt;!DOCTYPE html&gt;&lt;html lang="en"&gt;&lt;head&gt; &lt;meta charset="UTF-8"&gt; &lt;meta name="viewport" content="width=device-width, initial-scale=1.0"&gt; &lt;meta http-equiv="X-UA-Compatible" content="ie=edge"&gt; &lt;title&gt;Document&lt;/title&gt; &lt;!-- 以后如果要用纯JS代码做动画，一般都是先写好一个类，再用JS加上这个类就行了 --&gt; &lt;style&gt; .box&#123; width: 100px; height: 100px; background-color: #f00; &#125; .box.animation&#123; width: 300px; height: 300px; background-color: #0f0; transition: all 1s; &#125; &lt;/style&gt;&lt;/head&gt;&lt;body&gt; &lt;div class="box"&gt;&lt;/div&gt; &lt;input type="button" value="用动画变大" id="btn1"&gt; &lt;input type="button" value="复原" id="btn2"&gt; &lt;input type="button" value="切换" id="btn3"&gt;&lt;/body&gt;&lt;/html&gt;&lt;script&gt; var box = document.querySelector('.box'); //点击事件 document.getElementById('btn1').onclick = function()&#123; // box.style.width = "300px"; // box.style.height = "300px"; // box.style.transition = "all 1s"; box.classList.add('animation'); &#125; document.getElementById('btn2').onclick = function()&#123; box.classList.remove('animation'); &#125; document.getElementById('btn3').onclick = function()&#123; box.classList.toggle('animation'); &#125;&lt;/script&gt;]]></content>
      <categories>
        <category>HTML/CSS</category>
        <category>HTML5/CSS3</category>
      </categories>
      <tags>
        <tag>HTML</tag>
        <tag>HTML5</tag>
        <tag>CSS3</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[06-js中的classList属性]]></title>
    <url>%2Fposts%2F9f9158f6%2F</url>
    <content type="text"><![CDATA[js中的classList属性 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106&lt;!DOCTYPE html&gt;&lt;html lang="en"&gt;&lt;head&gt; &lt;meta charset="UTF-8"&gt; &lt;meta name="viewport" content="width=device-width, initial-scale=1.0"&gt; &lt;meta http-equiv="X-UA-Compatible" content="ie=edge"&gt; &lt;title&gt;Document&lt;/title&gt; &lt;!-- JS里新增了一个专门操作类的属性叫classList 能够让我们添加一个类、删除一个类、切换一个类没那么麻烦了 classList是一个伪数组，它可以获取到所有的类，每个类都是一个数组的一个元素 从取值的角度就比以前className要方便 add:添加一个类 remove:删除一个类 toggle：切换一个类：原来没有这个类就加上，原来有这个类就去掉 contains：判断是否有某个类，如果有返回true，如果没有返回false --&gt; &lt;style&gt; .box&#123; width: 100px; height: 100px; border: 1px solid #000; &#125; .red&#123; background-color: #f00; &#125; &lt;/style&gt;&lt;/head&gt;&lt;body&gt; &lt;div class="box test"&gt;&lt;/div&gt; &lt;input type="button" value="加颜色" id="btn1"&gt; &lt;input type="button" value="去掉颜色" id="btn2"&gt; &lt;input type="button" value="切换颜色" id="btn3"&gt; &lt;input type="button" value="打印classList" id="btn4"&gt; &lt;input type="button" value="判断是否存在red这个类" id="btn5"&gt;&lt;/body&gt;&lt;/html&gt;&lt;script&gt; //找到box var box = document.querySelector('.box'); document.getElementById('btn1').onclick = function()&#123; // 添加一个类的时候很麻烦：因为要用+=以外，还要记得加空格 // box.className += " red"; // 添加一个类 box.classList.add("red"); &#125; document.getElementById('btn2').onclick = function()&#123; // 去掉一个类的时候也麻烦：因为需要把原来的类在这里都写上 // box.className = "box test"; //删除一个类 box.classList.remove('red'); &#125; document.getElementById('btn3').onclick = function()&#123; // console.log(box.className); //如果原来没有red这个类，我就给你加上，否则就去掉 // if(box.className.indexOf('red') != -1)&#123; // box.className = "box"; // &#125;else&#123; // //代表没有 // box.className += " red"; // &#125; //如果没有red这个类就加上，有就去掉 box.classList.toggle('red'); &#125; document.getElementById('btn4').onclick = function()&#123; console.log(box.classList); console.log(box.classList[0]); &#125; document.getElementById('btn5').onclick = function()&#123; //判断有没有red这个类 console.log(box.classList.contains('red')); &#125;&lt;/script&gt;]]></content>
      <categories>
        <category>HTML/CSS</category>
        <category>HTML5/CSS3</category>
      </categories>
      <tags>
        <tag>HTML</tag>
        <tag>HTML5</tag>
        <tag>CSS3</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[05-transition初见]]></title>
    <url>%2Fposts%2Ff5d680d4%2F</url>
    <content type="text"><![CDATA[transition初见 123456789101112131415161718192021222324252627282930313233343536373839404142&lt;!DOCTYPE html&gt;&lt;html lang="en"&gt;&lt;head&gt; &lt;meta charset="UTF-8"&gt; &lt;meta name="viewport" content="width=device-width, initial-scale=1.0"&gt; &lt;meta http-equiv="X-UA-Compatible" content="ie=edge"&gt; &lt;title&gt;Document&lt;/title&gt; &lt;style&gt; .box&#123; width: 100px; height: 100px; background-color: #f00; /* 让元素变化的时候有动画效果（过渡效果） */ /* 参数1：参与过渡的属性，一般写all，代表所有属性都参与过渡，也可以写其他的，写什么就代表什么属性参与过渡 */ /* 参数2：过渡的持续时间，记得要加单位s代表多少秒 */ /* 参数3：代表延迟几秒执行（延迟时间） */ /* 参数4：运动曲线 linear匀速 steps(n):分n个步骤 如果需要用其他运动曲线,可以考虑配合easing插件使用*/ /* transition加在hover里代表只有悬停时才有过渡效果，写在默认样式里代表悬停和移出恢复时都有过渡效果 */ /* transition: all 2s .5s linear; */ /* 过渡其实是一个复合属性，由多个属性连写的 */ /* transition-property: 参与过渡的属性，写all之类的 */ /* transition-duration: 过渡的持续时间 */ /* transition-delay: 过渡的延迟时间 */ /* transition-timing-function: 运动曲线 */ &#125; .box:hover&#123; width: 300px; height: 300px; background-color: #0f0; &#125; &lt;/style&gt;&lt;/head&gt;&lt;body&gt; &lt;div class="box"&gt;&lt;/div&gt;&lt;/body&gt;&lt;/html&gt;]]></content>
      <categories>
        <category>HTML/CSS</category>
        <category>HTML5/CSS3</category>
      </categories>
      <tags>
        <tag>HTML</tag>
        <tag>HTML5</tag>
        <tag>CSS3</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[05-h5中的自定义属性]]></title>
    <url>%2Fposts%2F1ce648c9%2F</url>
    <content type="text"><![CDATA[h5中的自定义属性 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061&lt;!DOCTYPE html&gt;&lt;html lang="en"&gt;&lt;head&gt; &lt;meta charset="UTF-8"&gt; &lt;meta name="viewport" content="width=device-width, initial-scale=1.0"&gt; &lt;meta http-equiv="X-UA-Compatible" content="ie=edge"&gt; &lt;title&gt;Document&lt;/title&gt; &lt;!-- 什么叫自定义属性？ 就是标签原本没有的属性，你写上了，那么这个属性就是自定义属性 以前怎么用JS取到自定义属性？ 以前写自定义属性的缺点： 1.自定义属性在行内区分的不明显 2.用JS取值的时候太复杂 在H5里面解决了上述两个问题： 1.区分的更明显 2.用JS取值更方便 H5里面要求，你写自定义属性的时候，前面都要加一个前缀:data- 只要是按这种形式写的自定义属性，那么都可以在JS里通过 元素.dataset[属性名]取到 注意：属性名不用加data-了，它会自动去掉 如果data-后面还有-，会去掉-，并把-后面的首字母大写，但是data-后面的首字母不会大写 简单来说：就是从第二个-后面开始的每个首字母大写 遵循的是驼峰命名法 --&gt;&lt;/head&gt;&lt;body&gt; &lt;div id="box" data-shengao="185cm" data-tizhong="45kg" data-user-login-name="andy"&gt;&lt;/div&gt;&lt;/body&gt;&lt;/html&gt;&lt;script&gt; var box = document.getElementById('box'); // console.log(box.getAttribute('shengao')); // console.log(box.getAttribute('tizhong')); //只要你是按H5要求的形式写的自定义属性，那么你可以通过元素.dataset方便的取到每个自定义属性 console.log(box.dataset); console.log(box.dataset.shengao); console.log(box.dataset['shengao']); console.log(box.dataset['userLoginName']); //遍历方式 // for(var key in box.dataset)&#123; // console.log(box.dataset[key]); // &#125; &lt;/script&gt;]]></content>
      <categories>
        <category>HTML/CSS</category>
        <category>HTML5/CSS3</category>
      </categories>
      <tags>
        <tag>HTML</tag>
        <tag>HTML5</tag>
        <tag>CSS3</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[03-js做新标签兼容的原理]]></title>
    <url>%2Fposts%2Fccca7402%2F</url>
    <content type="text"><![CDATA[js做新标签兼容的原理 12345678910111213141516171819202122232425262728293031323334353637383940414243444546&lt;!DOCTYPE html&gt;&lt;html lang="en"&gt;&lt;head&gt; &lt;meta charset="UTF-8"&gt; &lt;meta name="viewport" content="width=device-width, initial-scale=1.0"&gt; &lt;meta http-equiv="X-UA-Compatible" content="ie=edge"&gt; &lt;title&gt;Document&lt;/title&gt; &lt;!-- 哪怕你写了一个非标准的标签，浏览器依然能够把它解析成dom元素 只不过，你写的如果不是标准标签，而是你自己瞎写的浏览器不认识的标签，那么浏览器会把它当做行内元素来解析（可以理解为当span来解析） 如果你写的标签，浏览器认识，会按这个标签本身的特点来解析 但如果浏览器不认识，会把它当行内元素(span)来解析 所以，你只要用JS创建一个header标签，这个标签在IE8和之前浏览器不认识，会解析成行内元素， 但是你只要继续把创建出来的标签的display改成block，就会变成块级元素， 那么这样子这段代码在任何浏览器里，都能得到一个块级的header标签内容 --&gt; &lt;style&gt; header&#123; width: 100px; height: 100px; border: 1px solid black; background-color: #f00; &#125; &lt;/style&gt;&lt;/head&gt;&lt;body&gt; &lt;!-- &lt;header&gt;这是一个&lt;/header&gt; --&gt; &lt;p&gt;Lorem ipsum, dolor sit amet consectetur adipisicing elit. Sit exercitationem unde, aliquam, voluptate repellendus sint ducimus incidunt, dolore dolorum quae sequi corporis consequuntur harum perspiciatis aliquid error cumque quod omnis.&lt;/p&gt;&lt;/body&gt;&lt;/html&gt;&lt;script&gt; //JS创建标签，谷歌认识，所以创建出来一个块级元素 //但是IE8不认识，会把它当做行内元素来解析 var header = document.createElement('header'); header.style.display = "block"; header.innerHTML = "我是header"; document.body.appendChild(header);&lt;/script&gt;]]></content>
      <categories>
        <category>HTML/CSS</category>
        <category>HTML5/CSS3</category>
      </categories>
      <tags>
        <tag>HTML</tag>
        <tag>HTML5</tag>
        <tag>CSS3</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[02-h5新标签的兼容]]></title>
    <url>%2Fposts%2Feab618be%2F</url>
    <content type="text"><![CDATA[h5新标签的兼容 1234567891011121314151617181920212223242526272829303132333435&lt;!DOCTYPE html&gt;&lt;html lang="en"&gt;&lt;head&gt; &lt;meta charset="UTF-8"&gt; &lt;meta name="viewport" content="width=device-width, initial-scale=1.0"&gt; &lt;meta http-equiv="X-UA-Compatible" content="ie=edge"&gt; &lt;title&gt;Document&lt;/title&gt; &lt;!-- 新标签在IE8和之前的浏览器里不支持 兼容方法：引入插件，就行了 但是：新浏览器，没必要导入，否则会造成流量的浪费，解决办法：用css hack技术，让它只在IE8和IE8之前的浏览器里导入就行了 快捷键：cc:ie --&gt; &lt;style&gt; header&#123; width: 100px; height: 100px; background-color: #f00; &#125; &lt;/style&gt; &lt;!--[if lte IE 8]&gt; &lt;script src="./html5shiv.js"&gt;&lt;/script&gt; &lt;![endif]--&gt; &lt;/head&gt;&lt;body&gt; &lt;header&gt;&lt;/header&gt;&lt;/body&gt;&lt;/html&gt;]]></content>
      <categories>
        <category>HTML/CSS</category>
        <category>HTML5/CSS3</category>
      </categories>
      <tags>
        <tag>HTML</tag>
        <tag>HTML5</tag>
        <tag>CSS3</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[01-html5新增了这些布局的标签]]></title>
    <url>%2Fposts%2F8b07fa81%2F</url>
    <content type="text"><![CDATA[html5新增了这些布局的标签 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139&lt;!DOCTYPE html&gt;&lt;html lang="en"&gt;&lt;head&gt; &lt;meta charset="UTF-8"&gt; &lt;meta name="viewport" content="width=device-width, initial-scale=1.0"&gt; &lt;meta http-equiv="X-UA-Compatible" content="ie=edge"&gt; &lt;title&gt;Document&lt;/title&gt; &lt;!-- 本文件知识点： header:头部区域 nav: 导航区域 main： 主体区域 section:小区域 aside：边栏 article：正文 footer： 页尾区域 以上标签其实就是div，只不过比div更加具备语义化，是H5中专门用来表示网页布局结构的标签 是HTML5的规范出来以后才有的，那么就意味着会有兼容性问题，IE8和之前的浏览器不支持 --&gt; &lt;style&gt; header &#123; height: 200px; background-color: #f00; &#125; nav &#123; height: 100px; background-color: orange; &#125; main &#123; margin-top: 10px; height: 600px; background-color: #0f0; &#125; section &#123; height: 180px; margin-top: 15px; background-color: purple; &#125; aside &#123; float: left; width: 30%; height: 100%; background-color: peru; &#125; article &#123; float: left; width: 70%; height: 100%; background-color: olivedrab; &#125; footer &#123; margin-top: 10px; height: 100px; background-color: #00f; &#125; /* div： 没有语义，不利于SEO（搜索引擎优化） 要让他们布局必须要给样式，为了区分每一个区域，我们给的是类名来区分，但是类名可以随便写，没有一套严格规定 H5新增了一些专门用来做网页布局结构的标签：它就是用来解决上述两个问题 1.这些标签语义化更强 2.解决了不能乱写的问题，可读性更强 除了上面这两个，这些新标签没有任何其他特点了，可以这么说，它其实就是一个div，只不过比div更加具备语义化，这些div是专门用来做区分网页布局结构的 */ &lt;/style&gt;&lt;/head&gt;&lt;body&gt; &lt;!-- 头部区域：又有导航区域 --&gt; &lt;header&gt; &lt;nav&gt;&lt;/nav&gt; &lt;/header&gt; &lt;!-- 主体区域：好多小区域 --&gt; &lt;main&gt; &lt;section&gt; &lt;!-- 边栏 --&gt; &lt;aside&gt;&lt;/aside&gt; &lt;!-- 正文 --&gt; &lt;article&gt;&lt;/article&gt; &lt;/section&gt; &lt;section&gt; &lt;!-- 边栏 --&gt; &lt;aside&gt;&lt;/aside&gt; &lt;!-- 正文 --&gt; &lt;article&gt;&lt;/article&gt; &lt;/section&gt; &lt;section&gt; &lt;!-- 边栏 --&gt; &lt;aside&gt;&lt;/aside&gt; &lt;!-- 正文 --&gt; &lt;article&gt;&lt;/article&gt; &lt;/section&gt; &lt;/main&gt; &lt;!-- 页尾区域 --&gt; &lt;footer&gt;&lt;/footer&gt;&lt;/body&gt;&lt;script&gt; for ( var i = 0 ; i &lt; arr.length - 1 ; i ++ ) &#123;//1.外层循环决定比较的轮数 for ( var j = 0 ; j &lt; arr.length - 1 - i ; j ++ ) &#123;//2.内层循环决定每一轮比较的次数 if ( arr[ j ] &gt; arr[ j + 1 ] ) &#123;//3.交换相邻元素：比较两个相邻数字的大小 var temp = arr[ j ]; arr[ j ] = arr[ j + 1 ]; arr[ j + 1 ] = temp; &#125; &#125; &#125;&lt;/script&gt;&lt;/html&gt;]]></content>
      <categories>
        <category>HTML/CSS</category>
        <category>HTML5/CSS3</category>
      </categories>
      <tags>
        <tag>HTML</tag>
        <tag>HTML5</tag>
        <tag>CSS3</tag>
      </tags>
  </entry>
</search>
