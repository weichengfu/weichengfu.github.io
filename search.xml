<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[禁止分享和微信分享]]></title>
    <url>%2Fposts%2F160e87%2F</url>
    <content type="text"><![CDATA[禁止分享和微信分享 微信禁止分享写法:123456789101112131415&lt;script&gt;function onBridgeReady() &#123; WeixinJSBridge.call('hideOptionMenu');&#125; if (typeof WeixinJSBridge == "undefined") &#123; if (document.addEventListener) &#123; document.addEventListener('WeixinJSBridgeReady', onBridgeReady, false); &#125; else if (document.attachEvent) &#123; document.attachEvent('WeixinJSBridgeReady', onBridgeReady); document.attachEvent('onWeixinJSBridgeReady', onBridgeReady); &#125;&#125; else &#123; onBridgeReady();&#125; 微信分享写法：12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576// 分享var shareAppMessage=&#123; title: '我正在参与吃鸡答题游戏', desc: '庆祝光大证券上市十周年，吃鸡答题游戏脑力狂欢中', logo: location.origin +'/brain-king-cj/resource/assets/icons/icon_0.jpg', link: location.origin +`/brain-king-cj/pk-share.html`,&#125;initWechatShare(function()&#123; configWechatShare(shareAppMessage)&#125;);function initWechatShare(fn) &#123; var url = location.href.split('#')[0] $.ajax(&#123; url: '/chicken-server/intf/h5/user/getParamForWeChatConfig', data: &#123; currentUrl: url, _v: Date.now() &#125;, success: function (rep) &#123; var data = rep.result if (0 == rep.ret) &#123; wx.config(&#123; debug: false, appId: data.appId, timestamp: data.timeStamp, nonceStr: data.nonceStr, signature: data.signaTure, jsApiList: [ 'checkJsApi', 'onMenuShareTimeline', 'onMenuShareAppMessage', 'hideOptionMenu' ] &#125;); fn &amp;&amp; fn.call(null) &#125; else &#123; mgui.message(rep.msg) &#125; &#125; &#125;)&#125;function configWechatShare(config) &#123; wx.ready(function () &#123; wx.onMenuShareTimeline(&#123; title: config.title, link: config.link, imgUrl: config.logo, desc: config.desc, success: function () &#123; config.fn &amp;&amp; config.fn.call(null, config) &#125;, cancel: function () &#123; &#125; &#125;) wx.onMenuShareAppMessage(&#123; title: config.title, link: config.link, imgUrl: config.logo, desc: config.desc, success: function () &#123; config.fn &amp;&amp; config.fn.call(null, config) &#125;, cancel: function () &#123; &#125; &#125;); &#125;);&#125;]]></content>
      <categories>
        <category>js</category>
      </categories>
      <tags>
        <tag>js</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[关于取反运算符"!"和"!!"]]></title>
    <url>%2Fposts%2F160eddd%2F</url>
    <content type="text"><![CDATA[关于取反运算符”!”和”!!” “!” 一个叹号在JS中表示取反的意思，通常使用在判断中使用，如果不是布尔值，都会对应的转化为相对应的布尔值之后取反，那么基本规则如下：取反返回true的如下： 123456!undefined!null!0!false!""!NaN 除此之外其他任何数据取反都返回false “!!” ——两个叹号表示把目标值转化为布尔值，相当于使用Boolean()方法例如： 12!!"123" 相当于是 Boolean("123") //true!!&#123;a:1&#125; 相当于是 Boolean(&#123;a:1&#125;) //true]]></content>
      <categories>
        <category>js</category>
      </categories>
      <tags>
        <tag>js</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[img标签-srcset属性]]></title>
    <url>%2Fposts%2F160e333%2F</url>
    <content type="text"><![CDATA[img标签-srcset属性 img标签有个陌生的srcset属性，如下： 11 &lt;img class="Avatar" src="https://pic3.zhimg.com/8622a8eea_s.jpg" srcset="https://pic3.zhimg.com/8622a8eea_xs.jpg 2x" alt="测试用户1"&gt; 其作用是：以最合适的src去匹配不同屏幕（高分屏低分屏如Retina；大屏小屏）。 使用如下： 12&lt;img src="source.jpg" srcset="source_2x.jpg 2x, source_3x.jpg 3x"&gt;&lt;img src="source.jpg" width="100%" srcset="source_400.jpg 400w, source_600.jpg 600w, source_1280.jpg 1280w"&gt; 2x、3x 表示目标屏幕的像素密度；400w、600w表示目标浏览器的宽度的限度，如浏览器宽度550w时，匹配600w的src。]]></content>
      <categories>
        <category>js</category>
      </categories>
      <tags>
        <tag>js</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[一维数组数据和树形结构的数据的相互转换]]></title>
    <url>%2Fposts%2F160e8177%2F</url>
    <content type="text"><![CDATA[一维数组数据和树形结构的数据的相互转换 一维数组数据转为树形结构的数据123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104&lt;!DOCTYPE html&gt;&lt;html lang="en"&gt;&lt;head&gt; &lt;meta charset="UTF-8"&gt; &lt;meta name="viewport" content="width=device-width, initial-scale=1.0"&gt; &lt;meta http-equiv="X-UA-Compatible" content="ie=edge"&gt; &lt;title&gt;Document&lt;/title&gt;&lt;/head&gt;&lt;body&gt; &lt;script&gt; // 1.数组转树形结构 var data = [&#123; "id": 1, "name": "全国", "pid": "" &#125;, &#123; "id": 2, "name": "广东省", "pid": 1 &#125;, &#123; "id": 3, "name": "广西省", "pid": 1 &#125;, &#123; "id": 4, "name": "深圳市", "pid": 2 &#125;, &#123; "id": 5, "name": "南宁市", "pid": 3 &#125;, &#123; "id": 6, "name": "南山区", "pid": 4 &#125;, &#123; "id": 7, "name": "武鸣区", "pid": 5 &#125; ]; // 2.数组转树形结构数据（原理即为通过设置id为key值，再通过pid去找这个key是否一样，一样则为这数据的子级数据） // 注意:这里只要找到最外层级的对象,放入一个空数组,然后利用赋值数据类型的特性,赋值是赋值的地址,值还在堆中,修改堆中的值, //引用的数据也会改变,从而得到新的数组,为了不改变原来的数据,可以考虑深拷贝 function arrayToTree(treeArray) &#123; var r = []; var tmpMap = &#123;&#125;;// 新建临时对象 // 第一次遍历 生成一个临时对象 // &#123;1:&#123;"id": 1,"name": "全国", "pid": ""&#125;, // 2:&#123;"id": 2,"name": "广东", "pid": "1"&#125;...&#125; for (var i = 0, l = treeArray.length; i &lt; l; i++) &#123; // 以每条数据的id作为obj的key值，数据作为value值存入到一个临时对象里面 tmpMap[treeArray[i]["id"]] = treeArray[i]; &#125; // 第二次遍历 确定父子关系 for (i = 0, l = treeArray.length; i &lt; l; i++) &#123; //循环每一条数据的pid，判断父id的值 假如这个临时对象有这个key值，就代表这个key对应的数据有children，需要Push进去 //如果这一项数据属于哪个数据的子级 var key = tmpMap[treeArray[i]["pid"]];// &#123;"id": 1,"name": "全国", "pid": ""&#125; //如果在临时数组里面能够找到对应的pid的键值key if (key) &#123; // 如果这个数据没有children if (!key["children"]) &#123; key["children"] = [];// 动态新建一个children键,值为空数组 key["children"].push(treeArray[i]);// 将数据放入到children数组中,成为它的子数据 // 如果这个数据有children &#125; else &#123; key["children"].push(treeArray[i]); &#125; &#125; else &#123; //如果没有这个Key值，就代表找不到属于哪个数据，那就代表没有父级,直接放在最外层 r.push(treeArray[i]); &#125; &#125; return r &#125; // 3.方法的调用与验证 var aa = arrayToTree(data) document.write(JSON.stringify(aa)) console.log('数组转树形结构', aa) &lt;/script&gt;&lt;/body&gt;&lt;/html&gt; 结果 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647[ &#123; "id":1, "name":"全国", "pid":"", "children":[ &#123; "id":2, "name":"广东省", "pid":1, "children":[ &#123; "id":4, "name":"深圳市", "pid":2, "children":[ &#123; "id":6, "name":"南山区", "pid":4 &#125; ] &#125; ] &#125;, &#123; "id":3, "name":"广西省", "pid":1, "children":[ &#123; "id":5, "name":"南宁市", "pid":3, "children":[ &#123; "id":7, "name":"武鸣区", "pid":5 &#125; ] &#125; ] &#125; ] &#125;] 树形结构转为一维数组数据的数据123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384&lt;!DOCTYPE html&gt;&lt;html lang="en"&gt;&lt;head&gt; &lt;meta charset="UTF-8"&gt; &lt;meta name="viewport" content="width=device-width, initial-scale=1.0"&gt; &lt;meta http-equiv="X-UA-Compatible" content="ie=edge"&gt; &lt;title&gt;Document&lt;/title&gt;&lt;/head&gt;&lt;body&gt; &lt;script&gt; // 树形数据 var treeArr = [&#123; "id": 1, "name": "全国", "pid": "", "children": [&#123; "id": 2, "name": "广东省", "pid": 1, "children": [&#123; "id": 4, "name": "深圳市", "pid": 2, "children": [&#123; "id": 6, "name": "南山区", "pid": 4 &#125;] &#125;] &#125;, &#123; "id": 3, "name": "广西省", "pid": 1, "children": [&#123; "id": 5, "name": "南宁市", "pid": 3, "children": [&#123; "id": 7, "name": "武鸣区", "pid": 5 &#125;] &#125;] &#125; ] &#125;]; // 树形结构数据转一维数组形式 function treeToArray(nodes) &#123; var r = []; // 定义一个空数组 // 判断传入的值是否是数组 if (Array.isArray(nodes)) &#123; // 遍历传入的树形数组 for (var i = 0, l = nodes.length; i &lt; l; i++) &#123; r.push(nodes[i]); // 取每项数据放入一个新数组 // 判断每一项数据下是否有children属性且值为数组,而且数组的长度大于0 if (Array.isArray(nodes[i]["children"]) &amp;&amp; nodes[i]["children"].length &gt; 0) &#123; // 若存在children则递归调用，把数据拼接到新数组中，并且删除该children r = r.concat(treeToArray(nodes[i]["children"])); delete nodes[i]["children"]; &#125; &#125; &#125; return r; &#125; // 方法的调用与验证 var bb = treeToArray(treeArr) console.log('树形数据转一维数组', bb); &lt;/script&gt;&lt;/body&gt;&lt;/html&gt; 结果 12345678910111213141516171819202122232425262728293031323334353637[ &#123; "id":1, "name":"全国", "pid":"" &#125;, &#123; "id":2, "name":"广东省", "pid":1 &#125;, &#123; "id":4, "name":"深圳市", "pid":2 &#125;, &#123; "id":6, "name":"南山区", "pid":4 &#125;, &#123; "id":3, "name":"广西省", "pid":1 &#125;, &#123; "id":5, "name":"南宁市", "pid":3 &#125;, &#123; "id":7, "name":"武鸣区", "pid":5 &#125;]]]></content>
      <categories>
        <category>js</category>
      </categories>
      <tags>
        <tag>js</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[通过点语法无法获取属性名为变量的属性值]]></title>
    <url>%2Fposts%2Fa36cfcf0%2F</url>
    <content type="text"><![CDATA[通过点语法无法获取属性名为变量的属性值 12345678// 获取formData对象中的值,作为另一个对象的属性名let templateUrl = this.formData.templateUrl;// 错误的做法, 得到undefined, this.templateUrl// 这里templateUrl是字符串不是变量// 正确的做法是通过字符串语法获取,[]里面是变量this[templateUrl]]]></content>
      <categories>
        <category>js</category>
      </categories>
      <tags>
        <tag>js</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[父子关系的一维数组,获取面包屑路径及节点信息]]></title>
    <url>%2Fposts%2F64e8b54d%2F</url>
    <content type="text"><![CDATA[父子关系的一维数组,获取面包屑路径及节点信息 面包屑路径生成取出某一个id节点在整个节点树中的path路径，即父子层级上的关系，类似于面包屑导航。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788&lt;!DOCTYPE html&gt;&lt;html lang="en"&gt;&lt;head&gt; &lt;meta charset="UTF-8"&gt; &lt;meta name="viewport" content="width=device-width, initial-scale=1.0"&gt; &lt;meta http-equiv="X-UA-Compatible" content="ie=edge"&gt; &lt;title&gt;Document&lt;/title&gt;&lt;/head&gt;&lt;body&gt; &lt;script&gt; // 数据 var dataArr = [&#123; "id": 1, "name": "全国", "pid": "" &#125;, &#123; "id": 2, "name": "广东省", "pid": 1 &#125;, &#123; "id": 3, "name": "广西省", "pid": 1 &#125;, &#123; "id": 4, "name": "深圳市", "pid": 2 &#125;, &#123; "id": 5, "name": "南宁市", "pid": 3 &#125;, &#123; "id": 6, "name": "南山区", "pid": 4 &#125;, &#123; "id": 7, "name": "武鸣区", "pid": 5 &#125; ]; //获得某一个节点从根点到此节点的路径 function getPath(getId ,dataArr) &#123; // 1.新建临时对象 var tmpMap = &#123;&#125;; // 2.遍历一维数组数据 生成一个临时对象 // &#123;1:&#123;"id": 1,"name": "全国", "pid": ""&#125;, // 2:&#123;"id": 2,"name": "广东", "pid": "1"&#125;...&#125; for (var i = 0, l = dataArr.length; i &lt; l; i++) &#123; // 以每条数据的id作为obj的key值，数据作为value值存入到一个临时对象里面 tmpMap[dataArr[i]["id"]] = dataArr[i]; &#125; // 3.新建一个空数组 var arr = []; //通过Id获取到当前节点对象值 &#123;"id": 7, "name": "武鸣区", "pid": 5 &#125; var currentNode = tmpMap[getId]; // 遍历数据拿到当前节点的父级数据 while (currentNode) &#123; arr.unshift(currentNode);// 将当前节点添加到定义的数组的前面 // 在通过当前节点的中的父id,在临时数组中找到父id的值,在while中再循环判断添加,直到顶级节点pid为空,退出循环 currentNode = tmpMap[currentNode.pid];// 设置新的节点 &#125; return arr; &#125; //获得节点路径 console.log(getPath(7,dataArr)); &lt;/script&gt;&lt;/body&gt;&lt;/html&gt; 结果 12345678910111213141516171819202122[ &#123; "id":1, "name":"全国", "pid":"" &#125;, &#123; "id":3, "name":"广西省", "pid":1 &#125;, &#123; "id":5, "name":"南宁市", "pid":3 &#125;, &#123; "id":7, "name":"武鸣区", "pid":5 &#125;] 获取节点信息123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778&lt;!DOCTYPE html&gt;&lt;html lang="en"&gt;&lt;head&gt; &lt;meta charset="UTF-8"&gt; &lt;meta name="viewport" content="width=device-width, initial-scale=1.0"&gt; &lt;meta http-equiv="X-UA-Compatible" content="ie=edge"&gt; &lt;title&gt;Document&lt;/title&gt;&lt;/head&gt;&lt;body&gt; &lt;script&gt; // 数据 var dataArr = [&#123; "id": 1, "name": "全国", "pid": "" &#125;, &#123; "id": 2, "name": "广东省", "pid": 1 &#125;, &#123; "id": 3, "name": "广西省", "pid": 1 &#125;, &#123; "id": 4, "name": "深圳市", "pid": 2 &#125;, &#123; "id": 5, "name": "南宁市", "pid": 3 &#125;, &#123; "id": 6, "name": "南山区", "pid": 4 &#125;, &#123; "id": 7, "name": "武鸣区", "pid": 5 &#125; ]; //获得以某一个节点信息，其中已经包含了所有树状关系。本节点的子菜单在节点的children属性里 function getNode(rootid,dataArr) &#123; // 1.新建临时对象 var tmpMap = &#123;&#125;; // 2.遍历一维数组数据 生成一个临时对象 // &#123;1:&#123;"id": 1,"name": "全国", "pid": ""&#125;, // 2:&#123;"id": 2,"name": "广东", "pid": "1"&#125;...&#125; for (var i = 0, l = dataArr.length; i &lt; l; i++) &#123; // 以每条数据的id作为obj的key值，数据作为value值存入到一个临时对象里面 tmpMap[dataArr[i]["id"]] = dataArr[i]; &#125; // 在临时数组中找到对应的节点,并返回 return tmpMap[rootid]; &#125; //获得节点信息 console.info(getNode(7,dataArr)); &lt;/script&gt;&lt;/body&gt;&lt;/html&gt; 结果 1&#123;id: 7, name: "武鸣区", pid: 5&#125;]]></content>
      <categories>
        <category>js</category>
      </categories>
      <tags>
        <tag>js</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[二维码包JsBarcode和QRCode使用]]></title>
    <url>%2Fposts%2F819665e%2F</url>
    <content type="text"><![CDATA[二维码包JsBarcode和QRCode使用 jsBarcode使用123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657&lt;!DOCTYPE html&gt;&lt;html lang="en"&gt; &lt;head&gt; &lt;meta charset="UTF-8"&gt; &lt;meta name="viewport" content="width=device-width, initial-scale=1.0"&gt; &lt;meta http-equiv="X-UA-Compatible" content="ie=edge"&gt; &lt;title&gt;js生成条形码插件&lt;/title&gt; &lt;script src="https://cdn.bootcss.com/jsbarcode/3.8.0/JsBarcode.all.min.js"&gt;&lt;/script&gt; &lt;style&gt; * &#123;margin: 0;padding: 0;box-sizing: border-box;&#125; h3 &#123;text-align: center;font-size: 16px;margin: 10px;&#125; .box &#123;text-align: center;&#125; #barcode &#123;width: 200px;&#125; &lt;/style&gt;&lt;/head&gt; &lt;body&gt; &lt;h3&gt;js自动生成条形码插件-JsBarcode&lt;/h3&gt; &lt;div class="box"&gt; &lt;img id="barcode" /&gt; &lt;/div&gt; &lt;/body&gt;&lt;script&gt; var barcode = document.getElementById('barcode'), var str = "16620902551", var options = &#123; format: "CODE128", displayValue: true, fontSize: 18, height: 100 &#125;; JsBarcode(barcode, str, options); //原生 // $('#barcode').JsBarcode(string, options); //jQuery /* JsBarcode("#imgcode", "123", &#123; format: "CODE39",//选择要使用的条形码类型 width:3,//设置条之间的宽度 height:100,//高度 displayValue:true,//是否在条形码下方显示文字 text:"456",//覆盖显示的文本 fontOptions:"bold italic",//使文字加粗体或变斜体 font:"fantasy",//设置文本的字体 textAlign:"left",//设置文本的水平对齐方式 textPosition:"top",//设置文本的垂直位置 textMargin:5,//设置条形码和文本之间的间距 fontSize:15,//设置文本的大小 background:"#eee",//设置条形码的背景 lineColor:"#2196f3",//设置条和文本的颜色。 margin:15//设置条形码周围的空白边距 &#125;);*/&lt;/script&gt; &lt;/html&gt; GitHub： https://github.com/lindell/JsBarcode/wiki/Options QRCode.js的使用1、引入插件 12345/*html*/&lt;div id="qrcode"&gt;&lt;/div&gt;/*js*/&lt;script src="qrcode.js"&gt;&lt;/script&gt; 2、基本用法 123456789101112131415var qrcode = document.getElementById('qrcode')/*直接生成二维码*/new QRCode(qrcode, 'http://www.daqianduan.com')/*也可以配置二维码的宽高等*/var qrcodeObj = new QRCode('qrcode', &#123; text: 'http://www.daqianduan.com', //解析成二维码的连接 width: 256, height: 256, colorDark : '#000000', //前景色 colorLight : '#ffffff' //背景色 //render: "table", //二维码的生成方式 //correctLevel :3 //容错级别，默认为2，最高为3，为了让用户扫码最快，容错级别应当设为最低&#125;) 3、API 设置二维码内容–makeCode 1qrcodeObj.makeCode('http://www.daqianduan.com/?p=6518&amp;preview=true') 清除二维码–clear 1qrcodeObj.clear()]]></content>
      <categories>
        <category>qr</category>
      </categories>
      <tags>
        <tag>qr</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[vue中引用子组件子组件没有高度问题]]></title>
    <url>%2Fposts%2Febeb809a%2F</url>
    <content type="text"><![CDATA[vue中引用子组件子组件没有高度问题 在使用iview的tab做页签导航时,切换的时候,有时tab组件的高度变为0 原因,直接使用组件,没有在组件外部包裹一个盒子 1234567891011&lt;Tabs id=&quot;Tabs&quot; type=&quot;card&quot; @on-tab-remove=&quot;handleTabRemove&quot; v-model=&quot;currentPageName&quot; @on-click=&quot;linkTo&quot;&gt; &lt;TabPane :name=&quot;item.name&quot; :label=&quot;item.label&quot; :closable=&quot;index==0?false:true&quot; v-for=&quot;(item,index) in tabitems&quot; :key=&quot;item.name&quot;&gt; &lt;/TabPane&gt;&lt;/Tabs&gt; 解决方案 1使用组件的时候, 最好在组件外面包裹一个盒子设置宽高, 不然会导致没有组件可能没有高度 12345678910111213&lt;div id=&quot;TabsBox&quot; ref=&quot;tabWrapper&quot;&gt; &lt;Tabs id=&quot;Tabs&quot; type=&quot;card&quot; @on-tab-remove=&quot;handleTabRemove&quot; v-model=&quot;currentPageName&quot; @on-click=&quot;linkTo&quot;&gt; &lt;TabPane :name=&quot;item.name&quot; :label=&quot;item.label&quot; :closable=&quot;index==0?false:true&quot; v-for=&quot;(item,index) in tabitems&quot; :key=&quot;item.name&quot;&gt; &lt;/TabPane&gt; &lt;/Tabs&gt;&lt;/div&gt;]]></content>
      <categories>
        <category>vue</category>
      </categories>
      <tags>
        <tag>vue</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[vue中使用v-for时key坑点]]></title>
    <url>%2Fposts%2F1320013%2F</url>
    <content type="text"><![CDATA[vue中使用v-for时key坑点 1234567891011&lt;Tabs id=&quot;Tabs&quot; type=&quot;card&quot; @on-tab-remove=&quot;handleTabRemove&quot; v-model=&quot;currentPageName&quot; @on-click=&quot;linkTo&quot;&gt; &lt;TabPane :name=&quot;item.name&quot; :label=&quot;item.label&quot; :closable=&quot;index==0?false:true&quot; v-for=&quot;(item,index) in tabitems&quot; :key=&quot;index&quot;&gt; // 使用的是代码默认的index作为key &lt;/TabPane&gt;&lt;/Tabs&gt; 以上代码的问题在于 1删除数组 tabitems 里面中间的某个元素时,该元素后面的元素也被删除了 1问题是出在v-for的:key上 1由于虚拟DOM的原因引起的，tab列表的生成是通过绑定的tabitems数组来生成的，当tabitems删除掉一项时，tab列表的dom对象自然也会减少一项。但是由于v-for循环的是子组件，子组件内部显示数据并未绑定tabitems数组里的属性，因此子组件的显示数据并未按新数组重新渲染，体现出来的结果就是最后一个元素被删掉了。 解决方法 1就是给:key赋予一个独一无二的值，这样绑定的数组就可以和dom对象一一对应起来，删除的时候也能正确删除掉响应dom对象了。]]></content>
      <categories>
        <category>vue</category>
      </categories>
      <tags>
        <tag>vue</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[vue中嵌套页面（iframe）]]></title>
    <url>%2Fposts%2F1ae9fed7%2F</url>
    <content type="text"><![CDATA[vue中嵌套页面（iframe） vue中嵌套iframe,将要嵌套的文件放在static下面。src可以使用相对路径，也可使用服务器根路径http:localhost:8088/… 1&lt;iframe src="../../static/plusPro.html" width="1200" height="300" frameborder="0" scrolling="auto"style="position:absolute;top: -300px;left: 0px;"&gt;&lt;/iframe&gt; 网页加载使用 iframe 时候,一般有缓存, 可以将 src改为动态的, 每次调用都是新的页面,新的数据 对于iframe 嵌套在弹框中, 弹框能滚动, iframe内嵌页面不能滚轮滚动问题,可以修改弹框的样式 123.eModal /deep/ .ivu-modal-wrap &#123; overflow: scroll;&#125;]]></content>
      <categories>
        <category>vue</category>
      </categories>
      <tags>
        <tag>vue</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[vue中父组件子组件相互传递数据值报错]]></title>
    <url>%2Fposts%2F910695fb%2F</url>
    <content type="text"><![CDATA[vue中父组件子组件相互传递数据值报错 路由出口传值 (父组件) 12&lt;!-- 页面主体 路由出口 --&gt;&lt;router-view :sysAreaCode="sysAreaCode" :breadCrumbItems="breadCrumbItems"&gt;&lt;/router-view&gt; data 1breadCrumbItems: [] 子组件接收后在传递给孙组件 1234&lt;!-- 面包屑导航 --&gt; &lt;div class=&quot;breadCrumbBox&quot;&gt; &lt;breadCrumb :breadCrumbItems=&quot;breadCrumbItems&quot;&gt;&lt;/breadCrumb&gt; &lt;/div&gt; 123props: &#123; breadCrumbItems:Array&#125;, 孙组件接收 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647&lt;template&gt; &lt;div id=&quot;breadCrumbBox&quot;&gt; &lt;Breadcrumb&gt; &lt;BreadcrumbItem v-for=&quot;(item, index) in breadCrumbItems&quot; :key=&quot;index&quot;&gt;&#123;&#123;item&#125;&#125; &lt;/BreadcrumbItem&gt; &lt;/Breadcrumb&gt; &lt;/div&gt;&lt;/template&gt;&lt;script&gt;export default &#123; name: &quot;breadCrumb&quot;, data: function() &#123; return &#123;&#125;; &#125;, methods: &#123; breadCrumbItems:[&quot;中国&quot;,&quot;广东&quot;,&quot;深圳&quot;] &#125;, props: &#123;// 接收 breadCrumbItems: Array &#125;&#125;;&lt;/script&gt;&lt;style scoped lang=&apos;scss&apos;&gt;// *px 转 rem@function rem($px, $base-font-size: 19.2px) &#123; @if (unitless($px)) &#123; //有无单位 @return ($px / 19.2) * 1rem; &#125; @else if (unit($px) == em) &#123; @return $px; &#125; @return ($px / $base-font-size) * 1rem;&#125;// *主色调$mainColor: #00ffff;// *面包屑导航#breadCrumbBox &#123; /deep/ span &#123; color: $mainColor; font-size: rem(24px); font-weight: normal; &#125;&#125;&lt;/style&gt; 报错 1The data property "breadCrumbItems" is already declared as a prop. Use prop default value instead. 1这里意思是这个data的属性 breadCrumbItems 已经在prop声明了，使用prop默认的值替代。因为 breadCrumbItems 在子组件已经创建声明, 后面又在孙组件的data声明和初始化，会冲突 解决 1把孙组件的那个data函数里的 breadCrumbItems 删除，便可以解决报错。]]></content>
      <categories>
        <category>vue</category>
      </categories>
      <tags>
        <tag>vue</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[vue中this指向改变问题]]></title>
    <url>%2Fposts%2F5b7fd63a%2F</url>
    <content type="text"><![CDATA[vue中this指向改变问题 1.如果给元素注册事件,事件处理函数里面的this指向就改变了,需要修改this指向 1234567891011121314151617181920methods: &#123; // 右键菜单 rightMenu()&#123; let _this=this;// 保存this指向 this.$refs.tabWrapper.oncontextmenu=function(e)&#123; let scrollTop=document.documentElement.scrollTop||document.body.scrollTop; _this.$refs.menu.style.display="block"; _this.$refs.menu.style.left=e.clientX+"px"; //当滑动滚动条时也能准确获取菜单位置 _this.$refs.menu.style.top=e.clientY+scrollTop+"px"; //阻止默认事件 return false; &#125; document.onclick=function(e)&#123; //用户触发click事件就可以关闭了，因为绑定在window上，按事件冒泡处理，不会影响菜单的功能 _this.$refs.menu.style.display="none"; &#125; &#125;,&#125; 2.如果在echarts的配置中使用vue data中的数据,需要修改this指向,不然里面的数据指向的是echarts 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283methods: &#123; partInstall() &#123; let _this = this; // *修改this指向 // *1.初始化echarts实例 let chart = this.$echarts.init(this.$refs.partInstall, "macarons"); chart.resize(); // *2.配置项 let option = &#123; animation: false, // 关闭初始渲染动画 tooltip: &#123; trigger: "axis", axisPointer: &#123; type: "shadow" &#125;, formatter: "&#123;b&#125;&lt;br/&gt;标签安装量: &#123;c&#125;个 " // 提示内容 &#125;, grid: &#123; top: "20%", left: "2%", right: "12%", bottom: "8%", containLabel: true &#125;, xAxis: &#123; name: "", type: "value", boundaryGap: [0, 0.01], splitLine: &#123; show: false &#125;, //去除网格线 splitArea: &#123; show: false //去除分隔区域背景 &#125;, axisLabel: &#123; // x轴文字的样式 show: true, color: "#fff" // fontSize: 16 &#125; &#125;, yAxis: &#123; type: "category", data: _this.partInstallData.yAxis,// 使用修改后的数据 axisLabel: &#123; // x轴文字的样式 show: true, color: "#fff" // fontSize: 16 &#125; &#125;, series: [ &#123; type: "bar", // data: [10, 8, 6, 4, 2, 1], data: _this.partInstallData.data, barWidth: 10, // 柱状图柱图宽度 itemStyle: &#123; // 柱形的样式 normal: &#123; barBorderRadius: [30, 30, 30, 30], // 圆角 color: new this.$echarts.graphic.LinearGradient(0, 0, 1, 0, [ //渐进色 &#123; offset: 0, color: "#0acadc" &#125;, &#123; offset: 0.5, color: "#027eff" &#125;, &#123; offset: 1, color: "#1a86da" &#125; ]) &#125; &#125; &#125; ] &#125;; // *3.使用刚指定的配置项和数据显示图表。 chart.setOption(option); &#125; &#125;]]></content>
      <categories>
        <category>vue</category>
      </categories>
      <tags>
        <tag>vue</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[vue中ref ($refs)用法和坑点]]></title>
    <url>%2Fposts%2F9a60e0ff%2F</url>
    <content type="text"><![CDATA[vue中ref ($refs)用法和坑点 介绍ref被用来给DOM元素或子组件注册引用信息。引用信息将会注册在父组件的 $refs 对象上。 $refs 是所有注册过的ref的一个集合， 如果在普通的DOM元素上使用，引用信息就是元素。 如果用在子组件上，引用信息就是组件实例。 $refs相对document.getElementById的方法，会减少获取dom节点的消耗。 1.ref 基本使用方法定义 12345678在元素(dom元素或者组件)身上定义 ref="name"比如：dom元素&lt;p ref="p"&gt;hello&lt;/p&gt;子组件&lt;child-comp ref="child"&gt;&lt;/child-comp&gt; 使用 12345// ref 加在普通的元素上，用this.$ref.name 获取到的是dom元素this.$ref.p// ref 加在子组件上，用this.$ref.name 获取到的是组件实例，可以使用组件的所有方法this.$ref.child 2.利用 v-for 和 ref 获取一组数组或者dom 节点注意： 1、ref 需要在dom渲染完成后才会有，在使用的时候确保dom已经渲染完成。 比如在生命周期 mounted(){} 钩子中调用，或者在(视图更新后) this.$nextTick(()=&gt;{}) 中调用。 2、如果ref 是循环出来的，有多个重名，那么ref的值会是一个数组 ，此时要拿到单个的ref 只需要循环就可以了。 123456789101112131415161718192021&lt;template&gt; &lt;ul&gt; &lt;li v-for=&quot;item in people&quot; ref=&quot;refContent&quot;&gt;&#123;&#123;item&#125;&#125;&lt;/li&gt; &lt;/ul&gt;&lt;/template&gt;&lt;script&gt; export default &#123; name: &quot;name&quot;, data: function() &#123; return &#123; people:[&quot;爸爸&quot;,&quot;妈妈&quot;,&quot;老师&quot;,&quot;学生&quot;] &#125; &#125;, created()&#123; this.$nextTick(()=&gt;&#123; console.log(this.$refs.refContent)// [li,li,li,li] &#125;) &#125;&lt;/script&gt; 3.ref使用在外面的组件上1234567891011121314151617181920212223&lt;div id="ref-outside-component" v-on:click="consoleRef"&gt; &lt;component-father ref="outsideComponentRef"&gt;&lt;/component-father&gt; &lt;p&gt;ref在外面的组件上&lt;/p&gt;&lt;/div&gt;// 定义子组件模板对象var refoutsidecomponentTem=&#123; template:"&lt;div class='childComp'&gt;&lt;h5&gt;我是子组件&lt;/h5&gt;&lt;/div&gt;" &#125;;var refoutsidecomponent=new Vue(&#123; el:"#ref-outside-component", components:&#123;// 注册子组件 "component-father":refoutsidecomponentTem &#125;, methods:&#123; consoleRef:function () &#123; console.log(this); // #ref-outside-component vue实例 console.log(this.$refs.outsideComponentRef); // div.childComp 组件实例 &#125; &#125; &#125;); 4.ref作用在外面元素上1234567891011121314151617181920212223//ref在外面的元素上&lt;div id="ref-outside-dom" v-on:click="consoleRef" &gt; &lt;component-father&gt;&lt;/component-father&gt; &lt;p ref="outsideDomRef"&gt;ref在外面的元素上&lt;/p&gt;&lt;/div&gt;// 定义子组件模板对象var refoutsidedomTem=&#123; template:"&lt;div class='childComp'&gt;&lt;h5&gt;我是子组件&lt;/h5&gt;&lt;/div&gt;" &#125;;var refoutsidedom=new Vue(&#123; el:"#ref-outside-dom", components:&#123; "component-father":refoutsidedomTem &#125;, methods:&#123; consoleRef:function () &#123; console.log(this); // #ref-outside-dom vue实例 console.log(this.$refs.outsideDomRef); // &lt;p&gt;标签dom元素 ref在外面的元素上&lt;/p&gt; &#125; &#125; &#125;); 5.ref使用在组件里面的元素上–局部注册组件123456789101112131415161718192021222324&lt;div id="ref-inside-dom"&gt; &lt;component-father&gt;&lt;/component-father&gt; &lt;p&gt;ref在里面的元素上&lt;/p&gt;&lt;/div&gt;// 定义子组件模板对象 使用refvar refinsidedomTem=&#123; template:"&lt;div class='childComp' v-on:click='consoleRef'&gt;" + "&lt;h5 ref='insideDomRef'&gt;我是子组件&lt;/h5&gt;" + "&lt;/div&gt;", methods:&#123; consoleRef:function () &#123; console.log(this); // div.childComp vue实例 console.log(this.$refs.insideDomRef); // &lt;h5&gt;我是子组件&lt;/h5&gt; &#125; &#125; &#125;;var refinsidedom=new Vue(&#123; el:"#ref-inside-dom", components:&#123; "component-father":refinsidedomTem &#125; &#125;); 6.ref使用在里面的元素上–全局注册组件12345678910111213141516171819202122&lt;div id="ref-inside-dom-all"&gt; &lt;ref-inside-dom-quanjv&gt;&lt;/ref-inside-dom-quanjv&gt;&lt;/div&gt;// 定义子组件模板对象 使用refVue.component("ref-inside-dom-quanjv",&#123; template:"&lt;div class='insideFather'&gt; " + "&lt;input type='text' ref='insideDomRefAll' v-on:input='showinsideDomRef'&gt;" + " &lt;p&gt;ref在里面的元素上--全局注册 &lt;/p&gt; " + "&lt;/div&gt;", methods:&#123; showinsideDomRef:function () &#123; console.log(this); //这里的this其实还是div.insideFather console.log(this.$refs.insideDomRefAll); // &lt;input type="text"&gt; &#125; &#125; &#125;);var refinsidedomall=new Vue(&#123; el:"#ref-inside-dom-all" &#125;); 7.Vue中使用refs定位dom出现undefined的解决方法原因分析: 在mounted阶段，DOM结构准备就绪，但是这里的准备就绪需要特别说明一下： 虽然DOM结构已经出来了，但是如果在DOM结构中的某个DOMOM节点使用了v-if、v-show或者v-for(即根据 获得的后台数据 或 父组件/路由传递过来的参数来动态操作DOM，即响应式）， 那么这些DOM是不会再mounted阶段找到的。 如果想要真正地在DOM加载完成后拿到数据，就需要调用VUE的全局api ： this.$nextTick(() =&gt; {}) 如果说mounted阶段是加载阶段，那么updated阶段则是完成了数据更新到DOM的阶段(对加载回来的数据进行处理)，此时，ref、数据等等全部都挂载到DOM结构上去，在update阶段使用this.$refs.xxx，就100%能找到该DOM节点。 使用updated与mounted不同的是，在每一次的DOM结构更新，vue都会调用一次updated(){}钩子函数！而mounted仅仅只执行一次。 解决方案: 如果你在mounted里获取this.$refs，因为dom还未完全加载，所以是拿不到的， update阶段则是完成了数据更新到 DOM的阶段(对加载回来的数据进行处理)，此时，就可以使用this.$refs了 如果写在method中，那么可以使用 this.$nextTick(() =&gt; {}) 等页面渲染好再调用 加个定时器延时加载this.$refs 当在methods中用到ref，但是却拿不到时，可以设置一个flag（isUpdate），当点击时isUpdate = 1;更新后isUpdate = 0]]></content>
      <categories>
        <category>vue</category>
      </categories>
      <tags>
        <tag>vue</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[vue中echarts图表常见问题]]></title>
    <url>%2Fposts%2Fe91f661d%2F</url>
    <content type="text"><![CDATA[vue中echarts图表常见问题 引入方式 12345678910111213// 引入echartsimport echarts from 'echarts'Vue.prototype.$echarts = echartsimport 'echarts/extension/bmap/bmap';// echarts扩展件百度地图Vue.use(BaiduMap, &#123; ak: 'T7qbY8u36ULF0tzduCA0v0YQ' //百度地图的key&#125;)import "echarts/theme/macarons.js"; // echart样式主题// 也可以按需引入//import echarts from 'echarts/lib/echarts'import 'echarts/lib/chart/line'import 'echarts/lib/component/tooltip'import 'echarts/lib/component/legendScroll' 1-侦听数据改变而改变图表的视图父组件 在父组件通过props给子组件传值 123456789101112131415161718192021222324&lt;template&gt; &lt;div&gt; &lt;div class=&quot;indexBox&quot;&gt; &lt;!-- 雷达图 --&gt; &lt;realTimeIndex :realTimeIndexData=&quot;realTimeIndexData&quot;&gt;&lt;/realTimeIndex&gt; &lt;/div&gt; &lt;/div&gt;&lt;/template&gt;&lt;script&gt;import realTimeIndex from &quot;./echarts/realTimeIndex&quot;; //*实时指数组件export default &#123; name: &quot;reportFormIndex&quot;, data: function() &#123; return &#123; // *实时指数数据 realTimeIndexData: &#123; indicatorData: [], seriesData: [] &#125; &#125;&#125;...... 子组件 子组件接收到父组件传递过来的值后,通过props接收,通过侦听器侦听深度侦听传递过来的数据改变,数据改变后执行数据渲染 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148&lt;template&gt; &lt;div id=&quot;realTimeIndexBox&quot;&gt; &lt;div id=&quot;realTimeIndex&quot; ref=&quot;realTimeIndex&quot; style=&quot;width: 100%;height:100%;&quot;&gt;&lt;/div&gt; &lt;/div&gt;&lt;/template&gt;&lt;script&gt;export default &#123; name: &quot;realTimeIndex&quot;, data: function() &#123; return &#123; chart:null &#125;; &#125;, props: &#123; realTimeIndexData: Object &#125;, watch: &#123; realTimeIndexData: &#123; deep: true, handler() &#123; this.realTimeIndex(); // *实时指数 &#125; &#125; &#125;, mounted() &#123; // 调用绘制图表的方法,必须在mounted,否则报错 // this.realTimeIndex(); // *实时指数 this.init() //让echarts窗口自适应 &#125;, methods: &#123; // *实时指数 realTimeIndex() &#123; let _this=this; // *1.初始化echarts实例 let chart = this.$echarts.init(this.$refs.realTimeIndex, &quot;macarons&quot;); chart.resize(); // *2.配置项 let option = &#123; animation: false,// 关闭初始渲染动画 // 弹框组件 tooltip: &#123; // backgroundColor:&quot;rgba(16, 44, 93,.7)&quot; &#125;, // 雷达图坐标系组件 radar: &#123; // shape: &apos;circle&apos;, //雷达图绘制类型 center: [&quot;50%&quot;, &quot;60%&quot;], //中心（圆心）坐标，数组的第一项是横坐标，第二项是纵坐标 radius: &quot;50%&quot;, name: &#123; // 雷达图每个指示器名称的配置项,就是那几条线的文字的样式 // formatter: function(value) &#123; // return &quot;【&quot; + value + &quot;】&quot;; // &#125;, textStyle: &#123; color: &quot;#fff&quot; &#125; &#125;, splitLine: &#123; // 坐标轴在 grid 区域中的分隔线 lineStyle: &#123; color: [&quot;#02cad1&quot;] &#125; &#125;, splitArea: &#123; // 坐标轴在 grid 区域中的分隔区域 areaStyle: &#123; //分隔区域的样式设置 color: [ &quot;transparent&quot;, &quot;transparent&quot;, &quot;transparent&quot;, &quot;transparent&quot; ], shadowColor: &quot;rgba(0, 100, 0, 0.3)&quot; &#125; &#125;, // 雷达图的指示器，用来指定雷达图中的多个变量（维度） indicator: _this.realTimeIndexData.indicatorData &#125;, textStyle: &#123; color: &quot;#fff&quot;, fontSize: 12 &#125;, // 数据 series: [ &#123; name: &quot;实时指数&quot;, //系列名称，用于tooltip的显示，legend 的图例筛选， type: &quot;radar&quot;, // 图表类型 data: _this.realTimeIndexData.seriesData, symbol: &apos;circle&apos;, // 标记的图形 // 图形上的文本标签，可用于说明图形的一些数据信息，比如值，名称等 label: &#123; show: true, textStyle: &#123; color: &quot;#fe6904&quot; &#125; &#125;, symbolSize: 8, //标记的大小 itemStyle: &#123; normal: &#123; color: &quot;#fe6904&quot;, &#125; &#125;, lineStyle: &#123; color:&apos;#0dc2d9&apos;, // 图表中各个图区域的边框线颜色 opacity: 0.5, &#125;, areaStyle: &#123; normal: &#123; color: &quot;#0dc2d9&quot;, opacity: 0.5 &#125; &#125; &#125; ] &#125;; // *3.使用刚指定的配置项和数据显示图表。 chart.setOption(option); this.chart=chart; &#125;, // *自适应 init() &#123; let that=this; setTimeout(function()&#123; let sizeFun = function () &#123; that.chart.resize(); &#125; window.addEventListener(&apos;resize&apos;, sizeFun ) &#125;,20) &#125; &#125;&#125;;&lt;/script&gt;&lt;style scoped lang=&apos;scss&apos;&gt;#realTimeIndexBox &#123; width: 100%; height: 100%;&#125;&lt;/style&gt; 2-echarts图表自适应宽度在有无数据切换图表视图的时候, 容器宽度设置为百分数，但是图表只有100px，缩到一起 原因分析: 查了一下echarts源码 12345Painter.prototype._getWidth = function() &#123; var root = this.root; var stl = root.currentStyle || document.defaultView.getComputedStyle(root); return ((root.clientWidth || parseInt(stl.width, 10)) - parseInt(stl.paddingLeft, 10) - parseInt(stl.paddingRight, 10)).toFixed(0) - 0;&#125;; 所以 1echarts绘制图表计算宽度的时候，由于第二个tab的属性display: none;所以无法获取到clientWidth，而 parseInt(stl.width, 10)) 将width: 100%;转为100，所以计算出的图表宽度为100px。 解决方法: 方法1 123mychart.setOption(option);// 加上下面这行代码mychart.resize(); // 重置echarts的宽度，达到自适应 比如 12345678910111213141516171819202122// 基于准备好的dom，初始化echarts实例var myChart = echarts.init(document.getElementById("CoreBarrelRatio"));// 绘制图表myChart.setOption(&#123; title: &#123; text: "上海白玉兰" &#125;, tooltip: &#123;&#125;, xAxis: &#123; data: ["衬衫", "羊毛衫", "雪纺衫", "裤子", "高跟鞋", "袜子"] &#125;, yAxis: &#123;&#125;, series: [ &#123; name: "销量", type: "bar", data: [5, 20, 36, 10, 10, 20] &#125; ]&#125;);// 重置echarts的宽度，达到自适应myChart.resize(); 方法2 12345根据实际需要选取其他div宽度进行设置。 还可同时设置宽度、高度var width = $("参考图ID").width();var height = $("参考图ID").height();$("#目标图ID").css("width", width).css("height", height); 12345678910111213141516$(document).ready(function()&#123; //给图设置固定宽度，div chart是第一个tab页面上面的某个图，宽度布局与map一致 $("#map").css('width',$("#chart").width()); require.config(&#123; paths: &#123; echarts: 'http://echarts.baidu.com/build/dist' &#125; &#125;); require( [ 'echarts', 'echarts/chart/map' ], function (ec) &#123; var myChart = ec.init(document.getElementById('map')); 3-echarts图表自适应浏览器窗口html部分 1&lt;div id="charts" :class="className" :id="id" :style="&#123;height:height,width:width&#125;" ref="myEchart"&gt;&lt;/div vue中配置参数部分 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576// 在data里声名一个chart选项 chart:nulldata: function() &#123; return &#123; chart:null &#125;; &#125;, props:&#123; className: &#123; type:String, default:'yourClassName' &#125;, id:&#123; type:String, default:'yourID' &#125;, width:&#123; type:String, default:'100%' &#125;, height:&#123; type:String, default:'400px' &#125; &#125;, methods: &#123; initChart() &#123; this.chart = echarts.init(this.$refs.myEchart); // 把配置和数据放这里 this.chart.setOption(&#123; tooltip: &#123; trigger: 'axis', &#125;, legend:&#123; icon:'rect', itemWidth:15, itemHeight:8, itemGap:10, data:['本月流量','上月流量'], right:'20px', textStyle:&#123; fontSize:12, color:'#ccc' &#125; &#125;, xAxis: [&#123; type: 'category', boundaryGap : false, data : ['1','2','3','4','5','6','7','8','9','10','11','12','13','14','15','16','17'], &#125;], yAxis: [&#123; type: 'value', splitLine:&#123; show:false &#125; &#125;], series: [&#123; name: '本月流量', type:'line', smooth:true, itemStyle: &#123;normal: &#123;areaStyle: &#123;type: 'default',color:'#00d7bf',opacity:'0.2'&#125;,color:'#00d7bf'&#125;&#125;, lineStyle:&#123;color:'#00d7df',opacity:0.2&#125;, data:[12330, 12334, 13300, 13444, 13000, 12567, 13400,12450,13000,13200,12343,13452,12345,12333,12345,12456,13456] &#125;, &#123; name:'上月流量', type:'line', smooth:true, itemStyle: &#123;normal: &#123;areaStyle: &#123;type: 'default',color:'#c4b03d',opacity:'0.2'&#125;,color:'#c4b03d'&#125;&#125;, data:[11200, 16534, 10433, 10678, 11435, 10444, 11000,11450,11000,10200,11343,10452,11345,10333,11234,10234,10222] &#125;] &#125;) &#125;, 把配置好的echarts挂载到dom节点 123mounted() &#123; this.initChart(); &#125;, 让echarts自适应于窗口的部分 在methods里添加一个init方法 123456789init() &#123; const self = this;//因为箭头函数会改变this指向，指向windows。所以先把this保存 setTimeout(() =&gt; &#123; window.onresize = function() &#123; self.chart = echarts.init(self.$refs.myEchart); self.chart.resize(); &#125; &#125;,20) &#125; 把该方法加到mounted 1234mounted() &#123; this.initChart(); this.init() //让echarts窗口自适应 &#125;, 或者采用(推荐) 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146&lt;template&gt; &lt;div id=&quot;realTimeIndexBox&quot;&gt; &lt;div id=&quot;realTimeIndex&quot; ref=&quot;realTimeIndex&quot; style=&quot;width: 100%;height:100%;&quot;&gt;&lt;/div&gt; &lt;/div&gt;&lt;/template&gt;&lt;script&gt;export default &#123; name: &quot;realTimeIndex&quot;, data: function() &#123; return &#123; chart:null // 1. 添加chart保存echarts对象----------------------------------------------- &#125;; &#125;, props: &#123; realTimeIndexData: Object &#125;, watch: &#123; realTimeIndexData: &#123; deep: true, handler() &#123; this.realTimeIndex(); // *实时指数 &#125; &#125; &#125;, mounted() &#123; this.init() //4.调用echarts窗口自适应函数------------------------------------------------ &#125;, methods: &#123; // *实时指数 realTimeIndex() &#123; let _this=this; // *1.初始化echarts实例 let chart = this.$echarts.init(this.$refs.realTimeIndex, &quot;macarons&quot;); chart.resize(); // *2.配置项 let option = &#123; animation: false,// 关闭初始渲染动画 // 弹框组件 tooltip: &#123; // backgroundColor:&quot;rgba(16, 44, 93,.7)&quot; &#125;, // 雷达图坐标系组件 radar: &#123; // shape: &apos;circle&apos;, //雷达图绘制类型 center: [&quot;50%&quot;, &quot;60%&quot;], //中心（圆心）坐标，数组的第一项是横坐标，第二项是纵坐标 radius: &quot;50%&quot;, name: &#123; // 雷达图每个指示器名称的配置项,就是那几条线的文字的样式 // formatter: function(value) &#123; // return &quot;【&quot; + value + &quot;】&quot;; // &#125;, textStyle: &#123; color: &quot;#fff&quot; &#125; &#125;, splitLine: &#123; // 坐标轴在 grid 区域中的分隔线 lineStyle: &#123; color: [&quot;#02cad1&quot;] &#125; &#125;, splitArea: &#123; // 坐标轴在 grid 区域中的分隔区域 areaStyle: &#123; //分隔区域的样式设置 color: [ &quot;transparent&quot;, &quot;transparent&quot;, &quot;transparent&quot;, &quot;transparent&quot; ], shadowColor: &quot;rgba(0, 100, 0, 0.3)&quot; &#125; &#125;, // 雷达图的指示器，用来指定雷达图中的多个变量（维度） indicator: _this.realTimeIndexData.indicatorData &#125;, textStyle: &#123; color: &quot;#fff&quot;, fontSize: 12 &#125;, // 数据 series: [ &#123; name: &quot;实时指数&quot;, //系列名称，用于tooltip的显示，legend 的图例筛选， type: &quot;radar&quot;, // 图表类型 data: _this.realTimeIndexData.seriesData, symbol: &apos;circle&apos;, // 标记的图形 // 图形上的文本标签，可用于说明图形的一些数据信息，比如值，名称等 label: &#123; show: true, textStyle: &#123; color: &quot;#fe6904&quot; &#125; &#125;, symbolSize: 8, //标记的大小 itemStyle: &#123; normal: &#123; color: &quot;#fe6904&quot;, &#125; &#125;, lineStyle: &#123; color:&apos;#0dc2d9&apos;, // 图表中各个图区域的边框线颜色 opacity: 0.5, &#125;, areaStyle: &#123; normal: &#123; color: &quot;#0dc2d9&quot;, opacity: 0.5 &#125; &#125; &#125; ] &#125;; // *3.使用刚指定的配置项和数据显示图表。 chart.setOption(option); this.chart=chart;// 2.保存chart对象-------------------------------------------------------- &#125;, // *3.新建自适应函数--------------------------------------------------------------------------- init() &#123; let that=this;// 修改this指向 setTimeout(function()&#123; let sizeFun = function () &#123; that.chart.resize(); &#125; window.addEventListener(&apos;resize&apos;, sizeFun ) &#125;,20) &#125; &#125;&#125;;&lt;/script&gt;&lt;style scoped lang=&apos;scss&apos;&gt;#realTimeIndexBox &#123; width: 100%; height: 100%;&#125;&lt;/style&gt;]]></content>
      <categories>
        <category>vue</category>
        <category>echarts</category>
      </categories>
      <tags>
        <tag>vue</tag>
        <tag>echarts</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[vue打包后css背景图片不显示问题和图片引入方式]]></title>
    <url>%2Fposts%2F3cdeb137%2F</url>
    <content type="text"><![CDATA[vue打包后css背景图片不显示问题和图片引入方式 vue打包后css背景图片不显示,iview找不到woff字体 预备知识 12绝对路径：从盘符开始的路径，如：C:\windows\system32\cmd.exe相对路径：从当前路径开始的路径 问题1：我在打包完成后，打开index.html文件发现文件找不到 打包之后寻找文件的地址错误，config文件夹下的index.js中寻找问题。 index.js中的build命令的配置有一个属性叫assetsPublicPath，它的值为‘/’。意思是根目录，这时会从index.html所在的硬盘的根目录下开始查找，自然无法找到。 解决方案: 改为‘./’这时就不再是绝对路径的根目录了，而是改为了相对路径，同目录下进行查找。再次打包，即可。 问题1：再次打包后，页面可以正常打开。但是页面上的一些图片请求失败。 1.css背景图片不显示原因分析 当用vue-cli自动构建项目后，有两种运行方法 12npm run dev : 提供一个开发的环境，自动热更新，资源使用 绝对路径，所以可以正常看到背景图片。npm run build : 打包项目，资源使用相对路径，所以会出现路径错误问题。 构建后的项目, 都需要读取静态资源，静态资源分为三种, JS, CSS, IMG，目录结构如下 123456789//结构目录index.htmlstatic |–img |–picname |–css |–app.css |–js |–app.js 如果项目中是通过img标签引入的图片显示正常，是因为img为html标签，它的路径是由index.html开始访问的，它的路径 static/img/‘图片名’ 是能正确访问到图片的 但是static/css/app.css文件里面的背景图片路径访问 static/img/’图片名’ 是访问错误的，因为在css目录下并没有static目录。所以此时需要先回退两层到根节点处才可以正确获取到图片。 解决方案 12345678910111213打开build/utils.js // Extract CSS when that option is specified // (which is the case during production build) if (options.extract) &#123; return ExtractTextPlugin.extract(&#123; use: loaders, publicPath:'../../',// 添加这个代码让css里面的图片路径变为 ../../static/img/’图片名’ fallback: 'vue-style-loader' &#125;) &#125; else &#123; return ['vue-style-loader'].concat(loaders) &#125; 2.iview打包后找不到woff字体在build文件夹下的webpack.prod.conf.js文件中 将extract改为false 就可以了 12345678const webpackConfig = merge(baseWebpackConfig, &#123; module: &#123; rules: utils.styleLoaders(&#123; sourceMap: config.build.productionSourceMap, extract: false ,// 修改 usePostCSS: true &#125;) &#125;, 总结: 在vue项目中使用图片的方式 1234567891011121314在工程里静态文件存储分为两种//（1）.存放在assets中（的image文件夹）：img标签引入图片&lt;img src="…/…/assets/img/moon.png" class=“test-img” /&gt;css图片使用background: url(’…/…/assets/img/moon.png’) no-repeat top left ;//（2）存放在static文件夹里：img标签引入图片&lt;img src="…/…/static/img/moon.png" class=“test-img” /&gt;css图片使用background: url(’…/…/static/img/moon.png’) no-repeat top left ; 3.vue图片引入的三种方式相同点：资源在html中使用，都是可以的。 不同点：使用assets下面的资源，在js中使用的话，路径要经过webpack中file-loader编译，路径不能直接写。 assets中的文件会经过webpack打包，重新编译，推荐该方式。而static中的文件，不会经过编译。项目在经过打包后，会生成dist文件夹，static中的文件只是复制一遍而已。简单来说，static中建议放一些外部第三方，自己的放到assets，别人的放到static中。 注意：如果把图片放在assets与static中，html页面可以使用；但在动态绑定中，assets路径的图片会加载失败，因为webpack使用的是commenJS规范，必须使用require才可以, data中必须用require加载，否则会当成字符串来处理. html 12345678910&lt;div id="hook"&gt; &lt;h3&gt;演示钩子的组件&lt;/h3&gt; &lt;p&gt;直接使用路径&lt;/p&gt; &lt;img src="../../assets/11.png" alt="图片加载失败" title="assets中的图片"&gt; &lt;img src="../../../static/11.png" alt="图片加载失败" title="static中的图片"&gt; &lt;br&gt; &lt;p&gt;动态绑定路径&lt;/p&gt; &lt;img :src="assetsURL" alt="图片加载失败" title="assets中的图片"&gt; &lt;img :src="staticURL" alt="图片加载失败" title="static中的图片"&gt;&lt;/div&gt; js 123456data ()&#123; return &#123; assetsURL: require('../../assets/11.png'), staticURL: '../../../static/11.png' &#125; &#125; 图片放在 assets目录下 和static 目录下 在template 中直接固定的引入 1&lt;img src="../assets/logo.png"&gt; 把图片放static 目录,直接通过data引入 12345678910// template&lt;img v-bind:src=imgSrc&gt;// srciptexport default &#123; data () &#123; return &#123; imgSrc: '../static/launch.png' &#125;; &#125;&#125;; 如果放在其它目录,直接通过data引入,则需要如下引入 123456789101112131415161718192021222324252627require('../assets/launch.png')` 或者 `import logo from '../assets/logo.png'// 方式1// template&lt;img v-bind:src=imgSrc&gt;// srciptexport default &#123; data () &#123; return &#123; imgSrc: require('../assets/launch.png') &#125;; &#125;&#125;;// 方式2import logo from '../assets/logo.png// template&lt;img v-bind:src=imgSrc&gt;// srciptexport default &#123; data () &#123; return &#123; imgSrc: logo &#125;; &#125;&#125;;]]></content>
      <categories>
        <category>vue</category>
      </categories>
      <tags>
        <tag>vue</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[js实现自定义右键菜单]]></title>
    <url>%2Fposts%2Fed3ab233%2F</url>
    <content type="text"><![CDATA[js实现自定义右键菜单 html 1234&lt;!-- 菜单管理 --&gt; &lt;div id="menu" ref="menu"&gt; &lt;Button type="primary" @click="clearAllTab"&gt;清空所有标签页&lt;/Button&gt; &lt;/div&gt; css 1234#menu &#123; position: absolute; display: none;&#125; js 123456789101112131415161718192021methods: &#123; rightMenu() &#123; let _this = this; _this.$refs.tabWrapper.oncontextmenu = function(e) &#123; let scrollTop = document.documentElement.scrollTop || document.body.scrollTop; _this.$refs.menu.style.display = "block"; _this.$refs.menu.style.left = e.clientX + "px"; //当滑动滚动条时也能准确获取菜单位置 _this.$refs.menu.style.top = e.clientY + scrollTop + "px"; //阻止默认事件 return false; &#125;; document.onclick = function(e) &#123; //用户触发click事件就可以关闭了，因为绑定在window上，按事件冒泡处理，不会影响菜单的功能 _this.$refs.menu.style.display = "none"; &#125;; &#125;, &#125;]]></content>
      <categories>
        <category>js</category>
      </categories>
      <tags>
        <tag>js</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[js全屏类似F11]]></title>
    <url>%2Fposts%2Fdce754fd%2F</url>
    <content type="text"><![CDATA[js全屏类似F11 123456789101112131415161718192021222324252627282930313233toggleFull() &#123; if ( (document.fullScreenElement !== undefined &amp;&amp; document.fullScreenElement === null) || (document.msFullscreenElement !== undefined &amp;&amp; document.msFullscreenElement === null) || (document.mozFullScreen !== undefined &amp;&amp; !document.mozFullScreen) || (document.webkitIsFullScreen !== undefined &amp;&amp; !document.webkitIsFullScreen) ) &#123; if (document.documentElement.requestFullScreen) &#123; document.documentElement.requestFullScreen(); &#125; else if (document.documentElement.mozRequestFullScreen) &#123; document.documentElement.mozRequestFullScreen(); &#125; else if (document.documentElement.webkitRequestFullScreen) &#123; document.documentElement.webkitRequestFullScreen( Element.ALLOW_KEYBOARD_INPUT ); &#125; else if (document.documentElement.msRequestFullscreen) &#123; document.documentElement.msRequestFullscreen(); &#125; &#125; else &#123; if (document.cancelFullScreen) &#123; document.cancelFullScreen(); &#125; else if (document.mozCancelFullScreen) &#123; document.mozCancelFullScreen(); &#125; else if (document.webkitCancelFullScreen) &#123; document.webkitCancelFullScreen(); &#125; else if (document.msExitFullscreen) &#123; document.msExitFullscreen(); &#125; &#125; &#125;]]></content>
      <categories>
        <category>js</category>
      </categories>
      <tags>
        <tag>js</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[iview 动态设置menu组件open-names，不起作用, 使用$nextTick 解决]]></title>
    <url>%2Fposts%2F684bd951%2F</url>
    <content type="text"><![CDATA[iview 动态设置menu组件open-names，不起作用, 使用$nextTick 解决 设置完openNames，activeName值以后，要在mounted以后，调用如下dom方法进行更新, 如果openNames，activeName 再次赋值为新的值的时候, 需要在赋值结束后在 $nextTick 方法内重新 初始化方法 123456&lt;Menu ref=&quot;side_menu&quot;&gt;&lt;/Menu&gt;this.$nextTick(() =&gt; &#123; this.$refs.side_menu.updateOpened(); this.$refs.side_menu.updateActiveName();&#125;) openNames，activeName赋值不能在$nextTick中进行，不然dom更新方法会无效]]></content>
      <categories>
        <category>iview</category>
      </categories>
      <tags>
        <tag>iview</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[iview modal 点击确认按钮不关闭对话框,执行判断后再手动关闭]]></title>
    <url>%2Fposts%2F6450d321%2F</url>
    <content type="text"><![CDATA[iview modal 点击确认按钮不关闭对话框,执行判断后再手动关闭 使用 iview 的 Modal对话框实现单击确定的时候不直接关闭对话框，而是经过一些判断，满足自己的条件的时候再关闭对话框 使用iview的 slot 自定义样式实现，经过一些业务逻辑判断，可控制modal显示关闭 在事件中进行操作相应的字段关闭弹框即可 1234&lt;div slot="footer"&gt; &lt;Button type="text" size="large" @click="modalCancel"&gt;取消&lt;/Button&gt; &lt;Button type="primary" size="large" @click="modalOk"&gt;确定&lt;/Button&gt;&lt;/div&gt;]]></content>
      <categories>
        <category>iview</category>
      </categories>
      <tags>
        <tag>iview</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[修改placeholder的样式]]></title>
    <url>%2Fposts%2Fc7f2643b%2F</url>
    <content type="text"><![CDATA[修改placeholder的样式 html 1&lt;textarea class="input" maxlength="200" name="text" placeholder="请输入文字" &gt;&lt;/textarea&gt; css 123456789.input::-webkit-input-placeholder &#123; color: red;&#125;.input:-moz-placeholder &#123; color: red;&#125;.input:-ms-input-placeholder &#123; color: red;&#125;]]></content>
      <categories>
        <category>css</category>
      </categories>
      <tags>
        <tag>css</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[通过css让双击不选中文本]]></title>
    <url>%2Fposts%2Ffae5c398%2F</url>
    <content type="text"><![CDATA[通过css让双击不选中文本 body{ -moz-user-select:none; /火狐/ -webkit-user-select:none; /webkit浏览器/ -ms-user-select:none; /IE10/ user-select:none; }]]></content>
      <categories>
        <category>css</category>
      </categories>
      <tags>
        <tag>css</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[IOS下微信H5页面软键盘输入后页面下方留白的问题]]></title>
    <url>%2Fposts%2F2b5d16c9%2F</url>
    <content type="text"><![CDATA[IOS下微信H5页面软键盘输入后页面下方留白的问题 一、问题分析最近微信和ios都有版本升级，不知道是哪边升级造成的，软键盘收起后，再滚动一下页面，下面的留白就会消失。所以只要在输入完毕后模拟一下这个“滚动”的操作，就能解决问题了。 关于这个现象出现的原因个人分析如下，仅供参考。 首先了解下window对象的scrollY属性,它返回的是当前垂直滚动的像素数，未发生滚动时值为0，向上滚动为正值。 当软键盘弹出后，页面会被软键盘顶上去，从而改变了window.scrollY的值，当软键盘收起后，页面停留在当前scrollY偏移的位置，所以下方有一大块留白。 因此可以在input失焦后让页面回滚到顶部来解决问题 二、解决方法input、textarea和select输入或下拉选择后均会出现以上问题。 1、如果使用jquery，修改起来就比较方便 $(‘input, textarea, select’).on(‘blur’,function(){ ​ window.scroll(0, 0); }); 2、如果使用vue，要修改的地方不是很多的话，直接用vue的v-on添加blur事件即可，以input为例 //methods中添加： fixScroll() { ​ window.scrolll(0, 0); } 如果修改的地方比较多，建议使用addEventListener循环添加事件，在组件销毁记得remove就好，以input为例 mounted() { ​ var a = document.getElementsByTagName(‘input’); ​ for (let i = 0; i &lt; a.length; i++) { ​ a[i].addEventListener(‘blur’, this.fixScroll); ​ } }, destroyed() { …移除mounted中添加的事件…｝ methods: { ​ fixScroll() { ​ window.scrolll(0, 0); ​ } } 3、因为这个问题只出现在ios端，所以可以在添加事件前判断是不是在ios系统上运行 var m = navigator.userAgent; var isAndroid = m.indexOf(‘Android’) &gt; -1 || m.indexOf(‘Adr’) &gt; -1; //android终端 var isIos = !!m.match(/(i[^;]+;( U;)? CPU.+Mac OS X/); //ios终端 if (isIos) { //为input、textarea、select添加blur事件 }]]></content>
      <categories>
        <category>H5</category>
      </categories>
      <tags>
        <tag>H5</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[IOS下点击事件失效的情况及解决方法]]></title>
    <url>%2Fposts%2F8c6147b4%2F</url>
    <content type="text"><![CDATA[IOS下点击事件失效的情况及解决方法 很简单的一个点击事件 123$(document).on(&apos;click&apos;, &apos;dl dt&apos;, function() &#123; //something()&#125;); 在pc以及安卓设备都是正常的，但是在ios上面就失效了。 问题描述： 当使用委托给一个元素添加click事件时，如果事件是委托到 document或 body上，并且委托的元素是默认不可点击的（如 div, span等），此时 click事件会失效。 解决方法 1、​将 click 事件直接绑定到目标​元素（​​即 .target）上； 2、将目标​元素换成 a 或者button 等可点击的​元素； ​3、将 click 事件委托到​​​​​非 document 或 body 的​​父级元素上； ​4、给​目标元素加一条样式规则 cursor: pointer。]]></content>
      <categories>
        <category>H5</category>
      </categories>
      <tags>
        <tag>H5</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[HTML空格符号 nbsp; ensp; emsp; 介绍及实现中文对齐的方法]]></title>
    <url>%2Fposts%2F8c6147b4%2F</url>
    <content type="text"><![CDATA[HTML空格符号 nbsp; ensp; emsp; 介绍及实现中文对齐的方法 一：不同空格符合的区别 &nbsp; 半角的不断行的空白格（推荐使用） &ensp; 半角的空格 &emsp; 全角的空格 详细的含义： &amp;nbsp;：这是我们使用最多的空格，也就是按下space键产生的空格。在HTML中，如果你用空格键产生此空格，空格是不会累加的（只算1个）。要使用html实体表示才可累加。该空格占据宽度受字体影响明显而强烈。在inline-block布局中会搞些小破坏，在两端对齐布局中又是不可少的元素。 &amp;ensp;：此空格有个相当稳健的特性，就是其占据的宽度正好是1/2个中文宽度，而且基本上不受字体影响。 &amp;emsp;：此空格也有个相当稳健的特性，就是其占据的宽度正好是1个中文宽度，而且基本上不受字体影响。 二：使用场景对于&amp;ensp;和&amp;emsp;在一些中文排版对齐方面可以使用，如下html代码： 12345&lt;ul&gt; &lt;li class="li"&gt;姓&amp;emsp;&amp;emsp;名：&lt;input type="text" /&gt;&lt;/li&gt; &lt;li class="li"&gt;手&amp;ensp;机&amp;ensp;号：&lt;input type="text" /&gt;&lt;/li&gt; &lt;li class="li"&gt;电子邮箱：&lt;input type="text" /&gt;&lt;/li&gt;&lt;/ul&gt; 三：空格新成员&amp;#x3000大多数编辑器中空格是透明滴，很容易就被删掉；另外，HTML压缩时候，空格也会被删除掉，所以需要转换书写形式。 在web页面上，一般有3种书写： 直接，例如搜狗输入法输入“版权” – ©. web字符，&amp;copy; charCode表示：&amp;#xa9; 而上面的&amp;ensp;, &amp;emsp;就是具有特定名称的web字符。但是，恕我寡闻，我并不清楚全角空格是否有对应&amp; + 关键字示意，所以，就使用工具转成了charCode字符表示，也就是这里的&amp;#x3000; &amp;ensp; → &amp;#x2002; &amp;emsp; → &amp;#x2003; 字符使用技巧： \1. HTML中字符输出使用&amp;#x配上charCode值；\2. 在JavaScript文件中为防止乱码转义，则是\u配上charCode值；\3. 而在CSS文件中，如CSS伪元素的content属性，直接使用\配上charCode值。 因此，想在HTML/JS/CSS中转义“我”这个汉字，分别是： &amp;#x6211; \如`console.log('\u6211');`1234567- \```\6211`, 如`.xxx:before &#123; content: &apos;\6211&apos;; &#125;`考虑到直接`&amp;#x3000;`这种形式暴露在HTML中，可能会让屏幕阅读器等辅助设备读取，从而影响正常阅读流，因此，我们可以进一步优化下，使用标签，利用伪元素，例如：```css.half:before &#123; content: &apos;\2002&apos;; speak: none; &#125;.full:before &#123; content: &apos;\2003&apos;; speak: none; &#125; html代码： 12345&lt;ul&gt; &lt;li class="li"&gt;姓&lt;span class="full"&gt;&lt;/span&gt;&lt;span class="full"&gt;&lt;/span&gt;名：&lt;input type="text" /&gt;&lt;/li&gt; &lt;li class="li"&gt;手&lt;span class="half"&gt;&lt;/span&gt;机&lt;span class="half"&gt;&lt;/span&gt;号：&lt;input type="text" /&gt;&lt;/li&gt; &lt;li class="li"&gt;电子邮箱：&lt;input type="text" /&gt;&lt;/li&gt;&lt;/ul&gt; css代码： 12345678.half &#123; *zoom: expression( this.runtimeStyle['zoom'] = '1', this.innerHTML = '&amp;#x2002;');&#125;.full &#123; *zoom: expression( this.runtimeStyle['zoom'] = '1', this.innerHTML = '&amp;#x2003;');&#125;.half:before &#123; content: '\2002'; speak: none; &#125;.full:before &#123; content: '\2003'; speak: none; &#125; 上面用到了runtimeStyle这个对象属性，这个是IE专属的。 下面简单介绍下style、 currentStyle、 runtimeStyle以及getComputedStyle的区别，在IE下测试如下。 html代码： 1&lt;div id="tt" style="color:blue;"&gt;这里是来检测style,currentStyle,runtimeStyle的区别&lt;/div&gt; js代码： 123456var myDiv = document.getElementById("tt");myDiv.runtimeStyle.color="black"; console.log(myDiv.currentStyle.color); //blackconsole.log(myDiv.runtimeStyle.color); //blackconsole.log(document.defaultView.getComputedStyle(myDiv, null).color); //rgb(0, 0, 0)console.log(myDiv.style.color); //blue 说明一下： obj.style：这个方法只能JS只能获取写在html标签中的写在style属性中的值（style=”…”），而无法获取定义在&lt;style type=&quot;text/css&quot;&gt;里面的属性。 IE中使用的是obj.currentStyle方法，而FF是用的是getComputedStyle 方法 。 “DOM2级样式”增强了document.defaultView，提供了getComputedStyle()方法。这个方法接受两个参数：要取得计算样式的元素和一个伪元素字符串（例如“:after”）。如果不需要伪元素信息，第二个参数可以是null。getComputerStyle()方法返回一个CSSStyleDeclaration对象，其中包含当前元素的所有计算的样式。 其语法为：document.defaultView.getComputedStyle(‘元素’, ‘伪类’)；IE9及以上支持该写法，IE8以及以下不支持。 总结一下： 通过document.defaultView.getComputedStyle()得到背景色，不同浏览器得到的不一样，可能会返回将所有颜色转换成RGB格式，也可能是颜色值。 IE通过currentStyle方法得到的颜色值没有将颜色转化成RGB格式。]]></content>
      <categories>
        <category>HTML</category>
      </categories>
      <tags>
        <tag>HTML</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[H5页面调用手机拨打电话功能]]></title>
    <url>%2Fposts%2Fa199d243%2F</url>
    <content type="text"><![CDATA[H5页面调用手机拨打电话功能 12&lt;head&gt;里面加上：&lt;meta name=&quot;format-detection&quot; content=&quot;telephone=yes&quot;/&gt; 12需要拨打电话的地方：&lt;a href="tel:400-0000-688"&gt;400-0000-688&lt;/a&gt; 12发短信：&lt;a href="sms:18688888888"&gt;发短信&lt;/a&gt; 点击 页面上的电话号码 ，页面会调用手机的电话接口。]]></content>
      <categories>
        <category>H5</category>
      </categories>
      <tags>
        <tag>H5</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[项目优化方式]]></title>
    <url>%2Fposts%2F31301012%2F</url>
    <content type="text"><![CDATA[项目优化方式 注：每次打包完成后，都可以删除js文件中，带有map后缀的文件，体积会变小很多 1.脚手架自带的功能 vue-cli提供的webpack打包 npm run build 网站上线之后 服务器可以开启 Gzipped压缩文件传输时 会更小 2.路由懒加载 路由懒加载 会把组件拆分为多个文件 用到了这个路由对应的组件 再去加载 访问到了 再去请求 在 router.js 修改路由引入方式 12345678&gt; // 导入 让路由管理的组件&gt; // import index from '../components/index.vue'&gt; // import cart from '../components/cart.vue'&gt; &gt; // 路由懒加载 使用webpack提供的功能 以及Vue自带的异步组件 进行拆分&gt; const index = () =&gt; import('../components/index.vue')&gt; const cart = () =&gt; import('../components/cart.vue')&gt; 3.CDN优化常见的js库 不会频繁更新，如果我们webpack打包的时候 一起合并 会增加请求的资源大小 作用是，抽取不用合并的js 以及 css 不需要合并的第三方js库 使用CDN获取 cdn地址：https://www.bootcdn.cn/ 不需要合并的第三方库 Vue，Vue-router，Vuex，element-ui 步骤： 在index.html中引入第三方库的cdn路径 需要告诉webpack 不要压缩这几个js文件 12345678910111213141516171819&gt; //从 CDN 引入 jQuery，而不是把它打包：&gt; &gt; //index.html&gt; &gt; &lt;script&gt; src="https://code.jquery.com/jquery-3.1.0.js"&gt; integrity="sha256-slogkvB1K3VOkzAI8QITxV3VzpOnkeNVsKvtkYLMjfk="&gt; crossorigin="anonymous"&gt;&gt; &lt;/script&gt;&gt; &gt; &gt; //webpack.config.js&gt; module.exports = &#123;&gt; //...&gt; externals: &#123;&gt; jquery: 'jQuery'&gt; &#125;&gt; &#125;;&gt; vue-cli封装了webpack的配置 也提供了方法让我们修改(如果采用了脚手架开发，就采用这样的方式) 在项目根路径新建 vue.config.js 文件 1234567891011121314151617181920212223&gt; //https://cli.vuejs.org/zh/guide/webpack.html#%E7%AE%80%E5%8D%95%E7%9A%84%E9%85%8D%E7%BD%AE%E6%96%B9%E5%BC%8F&gt; // vue.config.js&gt; module.exports = &#123;&gt; configureWebpack: &#123;&gt; // 插件&gt; // plugins: [&gt; // new MyAwesomeWebpackPlugin()&gt; // ]&gt; &gt; externals: &#123;&gt; // 忽略的第三方库&gt; // vue 键是引入的包名，值是自定义包的名，比如 import Vue from 'vue';&gt; vue: 'Vue',&gt; // vue-router&gt; 'vue-router': 'VueRouter',&gt; // vuex&gt; 'vuex': 'Vuex',&gt; // element-ui&gt; 'element-ui': 'Element'&gt; &#125;&gt; &#125;&gt; &#125;&gt; 注意点： 在index.html中，注意cdn要放在打包好js文件的上面，因为打包的js文件中可能会依赖上面的cdn 1234567891011&gt; &gt; &lt;link href="https://cdn.bootcss.com/element-ui/2.4.11/theme-chalk/index.css" rel="stylesheet"&gt;&gt; &gt; &lt;!-- cdn引入js --&gt;&gt; &lt;script src="https://cdn.bootcss.com/vue/2.5.22/vue.min.js"&gt;&lt;/script&gt;&gt; &lt;script src="https://cdn.bootcss.com/vue-router/3.0.2/vue-router.min.js"&gt;&lt;/script&gt;&gt; &lt;script src="https://cdn.bootcss.com/vuex/3.1.0/vuex.min.js"&gt;&lt;/script&gt;&gt; &lt;script src="https://cdn.bootcss.com/element-ui/2.4.11/index.js"&gt;&lt;/script&gt;&gt; &lt;!-- 打包的js会自动引入到下面 --&gt;&gt; &lt;!-- built files will be auto injected --&gt;&gt; 如果已经采用的cdn文件里面引入的文件就不用在main.js中导入 123456&gt; &gt; // 饿了吗UI的导入 注册 已经使用CDN抽取&gt; //import Element from 'element-ui';&gt; // import 'element-ui/lib/theme-chalk/index.css';&gt; //Vue.use(Element);&gt;]]></content>
      <categories>
        <category>vue</category>
      </categories>
      <tags>
        <tag>vue</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[处理cdn挂掉的方式]]></title>
    <url>%2Fposts%2F433901f6%2F</url>
    <content type="text"><![CDATA[cdn处理cdn挂掉的方式123456789101112131415161718192021222324252627282930&lt;!DOCTYPE html&gt;&lt;html lang="en"&gt;&lt;head&gt; &lt;meta charset="UTF-8"&gt; &lt;meta name="viewport" content="width=device-width, initial-scale=1.0"&gt; &lt;meta http-equiv="X-UA-Compatible" content="ie=edge"&gt; &lt;title&gt;Document&lt;/title&gt;&lt;/head&gt;&lt;body&gt;&lt;/body&gt;&lt;/html&gt;&lt;script&gt; // document.querySelector('.cdn').onload = function () &#123; // console.log('load'); // &#125; function error() &#123; // console.log('error'); // 使用替代的 js文件 let scriptDom = document.createElement('script'); scriptDom.src ='https://cdn.bootcss.com/vue-router/3.0.2/vue-router.min.js' ; document.body.appendChild(scriptDom); &#125;&lt;/script&gt;&lt;!-- 如果有问题了 我要知道 --&gt;&lt;script class="cdn" onerror="error()" src="https://cdn.bootcss.com/vue-router/3.0.2/vue-router.min.js123123"&gt;&lt;/script&gt;]]></content>
      <categories>
        <category>vue</category>
      </categories>
      <tags>
        <tag>vue</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[基于promise和async及await封装原生ajax]]></title>
    <url>%2Fposts%2F57f352f1%2F</url>
    <content type="text"><![CDATA[基于promise和async及await封装原生ajax async await 原理 123456async本质 被他修饰的函数 在调用时 会被自动包装到一个Promise对象中await 调用 后面 Promise对象的 .then 方法 把.then方法中的 res的值 赋值给了 左边的 变量 将异步代码变为同步 123456789101112131415161718192021222324252627282930313233343536373839404142// 自己封装的hxios 基于 Promiselet hxios = &#123; get(url) &#123; // 返回promise对象 return new Promise((resolve, reject) =&gt; &#123; // ajax let xhr = new XMLHttpRequest(); // 设置请求方法 和地址 xhr.open('get', url); // 注册回调函数 xhr.onload = function () &#123; // promise resolve resolve(xhr.responseText); &#125; // 错误回调函数 xhr.onerror = function () &#123; // 调用reject reject('请求出错啦') &#125; // 发送ajax请求 xhr.send(); &#125;) &#125;&#125;// 依次 查询 多个 城市的天气 // 用async 修饰的函数 内部的代码执行 是从上往下async function searchWeather() &#123; // 希望按照顺序执行的代码 全都丢到 async修饰的函数中 // await 把 后面 Promise 中then的 回调函数的参数 返回给你 let res1 = await hxios.get('http://wthrcdn.etouch.cn/weather_mini?city=深圳') console.log(res1); let res2 = await hxios.get('http://wthrcdn.etouch.cn/weather_mini?city=广州') console.log(res2); console.log('我是底部的代码');&#125;searchWeather();// 底部的代码// 不希望阻塞的代码 函数之外console.log('我是 window底部的代码');]]></content>
      <categories>
        <category>vue</category>
      </categories>
      <tags>
        <tag>vue</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[webpack4使用]]></title>
    <url>%2Fposts%2Fbcf62ff4%2F</url>
    <content type="text"><![CDATA[webpack4使用 css不分离的方式,打包到入口文件中,css文件被javascript写入到head的style中1.初始化项目1npm init -y 初始化后将在项目目录下生成一个package.json文件 2.安装webpack和webpack-cli1npm install webpack webpack-cli --save-dev 此时的package.json为 12345678910111213141516&#123; "name": "01InitializationPacking", "version": "1.0.0", "description": "", "main": "index.js", "scripts": &#123; "test": "echo \"Error: no test specified\" &amp;&amp; exit 1" &#125;, "keywords": [], "author": "", "license": "ISC", "devDependencies": &#123; "webpack": "^4.28.1",// 确保这里是webpack4 "webpack-cli": "^3.2.1" &#125;&#125; 3.配置webpack 4的production(生产) 和 development(开发) 模式修改package.json,在scrpit属性下修改配置，并配置开发和编译两个模式 12345"scripts": &#123; "test": "echo \"Error: no test specified\" &amp;&amp; exit 1", "dev": "webpack --mode development", // 开发者模式 "build": "webpack --mode production"// 编译模式，默认模式&#125; development(开发)用于开发的配置文件，用于定义 webpack dev server 和其他东西 production(生产)用于生产的配置文件，用于定义 UglifyJSPlugin，sourcemaps 等 production mode(生产模式) 可以开箱即用地进行各种优化。 包括压缩，作用域提升，tree-shaking 等。 另一方面development mode(开发模式)针对速度进行了优化，仅仅提供了一种不压缩的 bundle 。 注意:如果不配置这两个模式,会有终端会输出警告 The ‘mode’ option has not been set. Set ‘mode’ option to ‘development’ or ‘production’ to enable defaults for this environment.“模式”选项尚未设置。 将 “mode” 选项设置为 “development” 或 “production” 以启用此环境的默认值。 此时的package.json为 123456789101112131415161718&#123; "name": "01InitializationPacking", "version": "1.0.0", "description": "", "main": "index.js", "scripts": &#123; "test": "echo \"Error: no test specified\" &amp;&amp; exit 1", "dev": "webpack --mode development", "build": "webpack --mode production" &#125;, "keywords": [], "author": "", "license": "ISC", "devDependencies": &#123; "webpack": "^4.28.1", "webpack-cli": "^3.2.1" &#125;&#125; 4.创建一个index.js入口文件创建一个src文件夹，并新建一个工程文件index.js,内部代码为： 1console.log(`Hello Webpack4`); 在 webpack 4 中，既不必须定义 entry point(入口点) ，也不必须定义 output file(输出文件)它将查找 ./src/index.js 作为默认入口点。 而且，它会在 ./dist/main.js 中输出模块包 5.测试打包是否成功 运行命令开发模式命令 1npm run dev 在./dist/main.js 自动生成没有压缩的main.js 文件,表示测试成功 运行命令生产模式命令 1npm run build 在./dist/main.js 自动生成压缩的main.js 文件,表示测试成功 在src文件夹中新建一个index.html的文件,引入dist文件夹下的打包好的main.js,如果在控制台输入Hello Webpack4表示打包成功 注意: 编译后会自动创建dist文件夹并生成main.js文件，而且我们可以发现build模式编译后的文件比dev模式小得多。 webpack4相比之前版本为用户配置了默认的入口文件（./src/index.js）以及默认的输出(./dist/main.js)。默认配置可在package.json里修改： 1234"scripts": &#123; "dev": "webpack --mode development ./src/index.js --output ./dist/main.js", "build": "webpack --mode production ./src/index.js --output ./dist/main.js"&#125; 6.使用html-webpack-plugin插件配置启动页面,将js自动注入html文件安装插件 1npm install html-webpack-plugin --save-dev 修改webpack的配置文件webpack.config.js 12345678910111213141516171819202122232425262728293031323334353637383940414243// @导入path模块,操作路径使用const path = require('path');// @导入自动生成HTMl文件的插件const HtmlWebpackPlugin = require('html-webpack-plugin');// ?只要是插件，都一定要 放到 plugins 节点中去// ?这个插件的两个作用：// ?1. 自动在内存中根据指定页面生成一个内存的页面// ?2. 自动，把打包好的js文件 追加到页面中去// @通过 Node 中的模块操作，向外暴露了一个 配置对象module.exports = &#123; // // !─── 指定入口文件和出口文件 // // *文件入口，表示，要使用 webpack 打包哪个文件 entry: path.join(__dirname, './src/index.js'), // *输出文件相关的配置 output: &#123; // ?指定打包好的文件，输出到哪个目录中去 path: path.join(__dirname, './dist'), // ?指定 输出的文件的名称 filename: 'main.js' &#125;, // // !─── 插件配置 // // *配置插件的节点 plugins: [ // // !─── 配置自动生成HTMl文件的插件 // // *创建一个 在内存中 生成 HTML 页面的插件 new HtmlWebpackPlugin(&#123; // hash: true, //为文件添加hash对于文件缓存是很有帮助的 // *指定 模板页面，将来会根据指定的页面路径，生成内存中的页面 template: path.join(__dirname, './src/index.html'), // *指定生成的页面的名称 filename: 'index.html' &#125;) ]&#125; 虽说webpack4不用指定文件的入口和出口,指定页也没有错,方便修改 先删除src内模板页面的script的链接运行命令 1npm run build 执行命令后dist里面的index.html 123456789101112&lt;!DOCTYPE html&gt;&lt;html lang="en"&gt;&lt;head&gt; &lt;meta charset="UTF-8"&gt; &lt;meta name="viewport" content="width=device-width, initial-scale=1.0"&gt; &lt;meta http-equiv="X-UA-Compatible" content="ie=edge"&gt; &lt;title&gt;webpack 4 quickstart&lt;/title&gt;&lt;/head&gt;&lt;body&gt; &lt;script type="text/javascript" src="main.js"&gt;&lt;/script&gt;&lt;/body&gt;&lt;/html&gt; 可以看到在根目录下生成了dist文件夹里面,自动生成index.html、main.js，并且index.html里面自动引入main.js 所以该插件的作用是可以将生成的js自动引入html页面，不用手动添加 到目前为止src里面的index.html是dist里面index.html的模板页 7.使用webpack打包css文件安装 1npm install style-loader css-loader --save-dev 在src文件夹下css中新建index.css 123body &#123; background: red;&#125; 在src中index.js入口文件中引入css文件 12import "./index.css";//新增console.log(`Hello Webpack4`); 在webpack.config.js配置文件添加规则 1234567891011module: &#123; rules: [ // ?所有第三方模块的 匹配规则 // !配置处理 .css 文件的第三方loader 规则 &#123; test: /\.css$/, // ?用正则匹配 use: ['style-loader', 'css-loader'] // ?用use处理 // *css-loader一定要放在后面,先用css-loader处理后成可以打包的类型,js来import一个css文件 // 再通过style-loader创建一个style标签 &#125; ] &#125; 运行命令 1npm run dev 在dist文件夹中生成了index.html和miain.js,通过浏览器打开index.html,可以发现在head中生成了style标签,里面有是在index.css中写的样式 这两个加载器的作用就是使javascript脚本中能够引入css文件，并且写入到html 8.使用webpack打包less文件安装 1npm i less-loader less --save-dev 注意: less-loader依赖less所以要安装,但是不需要配置 在src文件夹下的css新建index.less 12345ul&#123; li&#123; background-color: green; &#125;&#125; 在src文件夹下的index.html添加结构,方便测试 12345&lt;ul&gt; &lt;li&gt;1&lt;/li&gt; &lt;li&gt;2&lt;/li&gt; &lt;li&gt;3&lt;/li&gt;&lt;/ul&gt; 在src中index.js入口文件中引入less文件 1234import "./css/index.css";import "./css/index.less";//新增console.log(`Hello Webpack4`); 在webpack.config.js配置文件添加规则 12345678module: &#123; rules: [ // ?所有第三方模块的 匹配规则 &#123; test: /\.less$/, use: ['style-loader', 'css-loader', 'less-loader'] &#125; // 处理 less 文件的 loader ] &#125; 运行命令 1npm run dev 在dist文件夹中生成了index.html和miain.js,通过浏览器打开index.html,可以发现在head中生成了style标签,里面有是在index.less中写的样式 9.使用webpack打包sass文件安装 1npm i sass-loader node-sass --save-dev 注意: sass-loader依赖node-sass所以要安装,但是不需要配置 在src的css文件夹下新建index.scss 123li&#123; height: 50px;&#125; src中index.js入口文件中引入less文件 12345import "./css/index.css";import "./css/index.less";import "./css/index.scss";//新增console.log(`Hello Webpack4`); 在webpack.config.js配置文件添加规则 12345678module: &#123; rules: [ // ?所有第三方模块的 匹配规则 &#123; test: /\.scss$/, use: ['style-loader', 'css-loader', 'sass-loader'] &#125;, // 处理 scss 文件的 loader ] &#125; 运行命令 1npm run dev 在dist文件夹中生成了index.html和miain.js,通过浏览器打开index.html,可以发现在head中生成了style标签,里面有是在index.sess中写的样式 10.使用webpack处理css中的路径安装 1npm i url-loader file-loader --save-dev 注意:默认情况下，webpack 无法 处理 CSS 文件中的 url 地址，不管是图片还是字体库，还是 URL 地址，都处理不了,所以需要加载器来处理 url-loader 依赖 file-loader 需要下载但无需配置 在src文件夹下的index.html添加 1&lt;div class="box"&gt;&lt;/div&gt; 在src文件夹下新建imgs,添加icon.jpg图片 在src文件夹下的index.less添加 123456.box &#123; width: 100px; height: 100px; background: url('../imgs/icon.jpg'); background-size: cover;&#125; 在webpack.config.js配置文件添加规则 12345678910111213141516171819module: &#123; rules: [ // ?所有第三方模块的 匹配规则 &#123; test: /\.(jpg|png|gif|bmp|jpeg)$/, use: 'url-loader?limit=76&amp;name=[hash:8]-[name].[ext]&amp;outputPath=imgs/' &#125;, // 处理 图片路径的 loader ] &#125;// ?默认情况下,webpack会把图片转为base64编码图片,可以减少图片的二次请求 且图片没有了路径,原本的名字和和扩展名也没有了,但是一般情况下,我们只是希望小的图片转为base64// 大图片不转,按照原来的路径和名字,所以需要给配置文件的url传参,和浏览器地址上的URL传参一致// 传limit 给定的值，是图片的大小，单位是 byte， 如果我们引用的 图片，大于或等于给定的 limit值，则不会被转为base64格式的字符串， 如果 图片小于给定的 limit 值，则会被转为 base64的字符串// 为了防止图片的重名,webpack会将图片的名字转为哈希值,如果不想让webpack改变图片的名字,可以通过设置名字参数 name=[name].[ext] ,[name]表示之前是什么就还是什么名,[ext]表示之前是什么扩展名就还是什么扩展名// 如果用图片原来的名字,如果重名了,后面会覆盖前面的图片地址,为了防止重名,可以给[name].[ext]的前面加上一个哈希值(哈希值是有32位的), 设置哈希值为8位[hash:8],通过扛-与图片名连接在一起,就不会重名了// 这里涉及到了4个参数：limit、name、outputPath、publicPath。其中limit已经说明过。file-loader相关的是name、outputPath和publicPath。下面解释一下这3个参数 // name表示输出的文件名规则，如果不添加这个参数，输出的就是默认值：文件哈希。加上[path]表示输出文件的相对路径与当前文件相对路径相同，加上[name].[ext]则表示输出文件的名字和扩展名与当前相同。加上[path]这个参数后，打包后文件中引用文件的路径也会加上这个相对路径。// outputPath表示输出文件路径前缀。图片经过url-loader打包都会打包到指定的输出文件夹下。但是我们可以指定图片在输出文件夹下的路径。比如outputPath=img/，图片被打包时，就会在输出文件夹下新建（如果没有）一个名为img的文件夹，把图片放到里面。// publicPath表示打包文件中引用文件的路径前缀，如果你的图片存放在CDN上，那么你上线时可以加上这个参数，值为CDN地址，这样就可以让项目上线后的资源引用路径指向CDN了。 运行命令 1npm run dev 在dist文件夹中生成了index.html和miain.js,通过浏览器打开index.html,可以发现在head中生成了style标签,图片可以正常显示了,小于限定值的图片转为了base64 css中的路径除了图片外还有字体图标,所以也要处理 在webpack.config.js配置文件添加规则 12345678module: &#123; rules: [ // ?所有第三方模块的 匹配规则 &#123; test: /\.(jpg|png|gif|bmp|jpeg)$/, use: 'url-loader?limit=7631&amp;name=[hash:8]-[name].[ext]' &#125;, // 处理 图片路径的 loader ] &#125; 11.使用babel处理高级JS语法安装 不同环境版本要求不同，编译时可能会出错，可根据提示改变版本 1npm install babel-core babel-loader babel-preset-env --save-dev 目前用下面这个安装不会报错 1npm install babel-core babel-loader@7 babel-preset-env --save-dev 在项目根目录中添加.babelrc文件 123&#123; "presets": ["env" ]&#125; 在webpack.config.js配置文件添加规则 12345678910111213141516module: &#123; rules: [ // ?所有第三方模块的 匹配规则 &#123; test: /\.js$/, use: &#123; loader: "babel-loader" &#125;, exclude: /node_modules/ // 排除node_modules文件夹 &#125; // 配置 Babel 来转换高级的ES语法 ] &#125;// webpack 中，默认只能处理 一部分 ES6 的新语法，一些更高级的ES6语法或者 ES7 语法，webpack 是处理不了的；需要借助于第三方的 loader，来帮助webpack 处理这些高级的语法，当第三方loader 把 高级语法转为 低级的语法之后，会把结果交给 webpack 去打包到 main.js 中//babel-loader作为webpack的loader的一种，作用同其他loader一样，实现对特定文件类型的处理//当webpack使用babel-loader处理文件时，babel-loader实际上调用了babel-core的api//babel-preset-env的作用是告诉babel使用哪种转码规则进行文件处理。事实上，babel有几种规则都可以实现对ES6语法的转码，如babel-preset-es2015、babel-preset-latest、babel-preset-env，不过官方现已建议采用babel-preset-env 在src中index.js入口文件中添加es6语法 123(val) =&gt; &#123; console.log("世界你好");&#125; 运行命令 1npm run dev 在dist文件夹中生成了index.html和main.js,打开main.js,查看箭头函数是否转为es2015的语法 12.webpack-dev-servers插件开启本地服务器，设置热更新安装 1npm i webpack-dev-server --save-dev 配置方式1 修改package.json的script节点如下，其中--open表示自动打开浏览器，--port 3000表示打开的端口号为3000，--hot表示启用浏览器热更新 1"dev": "webpack-dev-server --mode development --hot --port 3000 --open" 运行命令 1npm run dev 发现可以进行实时打包，但是dist目录下并没有生成index.js文件，这是因为webpack-dev-server将打包好的文件放在了内存中 把index.js放在内存中的好处是：由于需要实时打包编译，所以放在内存中速度会非常快 配置方式2 修改package.json的script节点如下 1"dev": "webpack-dev-server --mode development" 在webpack.config.js头部引入webpack模块： 12// @开启热更新热更新第一步 引入webpack因为webpack-dev-server依赖 const webpack = require("webpack") 在webpack.config.js中的plugins节点下新增： 1234plugins: [ // @开启热更新第二步 启用HMR热更新 new webpack.HotModuleReplacementPlugin() ] 修改webpack.config.js文件中，新增devServer节点如下： 1234567// @开启热更新第三步 开启热更新设置端口 指定托管的根目录等 devServer: &#123; contentBase: __dirname + '/dist', // 指定托管的根目录 port: 3000, // 端口 open: true, // 运行时自动在浏览器打开 hot: true // 开启热更新,不是刷新 &#125; webpack-dev-server就是一个基于Node.js和webpack的一个小型服务器，它有强大的自动刷新和热替换功能。 webpack-dev-server可以实现代码实时打包编译，当修改代码之后，会自动进行打包构建 发现可以进行实时打包，但是dist目录下并没有生成bundle.js文件，这是因为webpack-dev-server将打包好的文件放在了内存中 13.build自动清除旧的dist文件夹安装 1npm install clean-webpack-plugin --save-dev 在webpack.config.js中新增： 12// @引入自动清除dist文件夹插件 const CleanWebpackPlugin = require('clean-webpack-plugin'); 1234plugins: [ // @清除dist文件夹 new CleanWebpackPlugin(['dist']) ] 14.修改模板页也可以触发自动刷新安装 1npm install raw-loader --save-dev 在webpack.config.js中新增： 12345678910module.exports = &#123; module: &#123; rules: [&#123; test: /\.(htm|html)$/, use: [ 'raw-loader' ] &#125;] &#125;,&#125; 在入口文件index.js中导入模板文件 1import './index.html'; 运行命令 1npm run dev 即可 15.Source Maps调试配置在webpack.config.js中新增： 123module.exports = &#123; devtool: 'source-map' // 会生成对于调试的完整的.map文件，但同时也会减慢打包速度&#125; 配置好后，我们再次运行npm run build进行打包，这时我们会发现在dist文件夹中多出了一个bundle.js.map 如果代码有bug，在浏览器的调试工具中会提示错误出现的位置，这就是devtool: &#39;source-map&#39;配置项的作用。 css分离的方式????? webpack配合boostrap使用在入口文件main.js中通过es6的方式引入boostrap的文件 1import 'bootstrap/dist/css/bootstrap.css' 12// 注意： 如果要通过路径的形式，去引入 node_modules 中相关的文件，可以直接省略 路径前面的 node_modules 这一层目录，直接写 包的名称，然后后面跟上具体的文件路径// 不写 node_modules 这一层目录 ，默认 就会去 node_modules 中查找 webpack配合vue使用安装运行依赖 1npm i vue -S 安装加载器为开发依赖 1npm i vue-loader vue-template-compiler -D 在webpack.config.js中，添加如下module规则： 12345module: &#123; rules: [ &#123; test: /\.vue$/, use: 'vue-loader' &#125; ] &#125; 由于Vue-loader在15.*之后的版本都是 vue-loader的使用都是需要伴生 VueLoaderPlugin的,所以在webpack.config.js中加入以下配置,不然会报错 123456const VueLoaderPlugin = require('vue-loader/lib/plugin');plugins: [ // make sure to include the plugin for the magic new VueLoaderPlugin() ] 在webpack.config.js中添加resolve属性 123456789101112// 注意： 在 webpack 中， 使用 import Vue from 'vue' 导入的 Vue 构造函数，功能不完整，只提供了 runtime-only 的方式，并没有提供 像网页中那样的使用方式；// 方式1 导入完整版vue 导入包后在webpack配置文件中配置别名,在require或者import的时候是以vue结尾的,就去指定路径下去找文件// 在webpack配置文件中配置别名,在require或者import的时候是以vue结尾的,就去指定路径下去找文件 resolve: &#123; alias: &#123; // 修改 Vue 被导入时候的包的路径 "vue$": "vue/dist/vue.js" &#125; &#125;// 方式2 导入完整版vue可以采用直接通过文件去找文件的形式 // import Vue from '../node_modules/vue/dist/vue.js' 创建App.vue组件页面 12345678910111213141516171819202122232425262728293031 &lt;!--结构--&gt; &lt;template&gt;&lt;!-- 注意：在 .vue 的组件中，template 中必须有且只有唯一的根元素进行包裹，一般用 div 当作唯一的根元素 --&gt; &lt;div&gt; &lt;h1&gt;这是APP组件 - &#123;&#123;msg&#125;&#125;&lt;/h1&gt; &lt;h3&gt;我是h3&lt;/h3&gt; &lt;/div&gt; &lt;/template&gt; &lt;!--逻辑--&gt; &lt;script&gt; // 注意：在 .vue 的组件中，通过 script 标签来定义组件的行为， // 需要使用 ES6 中提供的 export default 方式，导出一个vue实例对象 export default &#123; data() &#123; return &#123; msg: &apos;OK&apos; &#125; &#125; &#125; &lt;/script&gt; &lt;!--样式--&gt; &lt;style scoped lang=&apos;less&apos; &gt; /*scoped 设置局部作用,lang=&apos;less&apos;用less预处理器 */ h1 &#123; color: red; &#125; &lt;/style&gt; 创建index.js入口文件 12345678910111213// 导入 Vue 组件import Vue from 'vue'// 导入 App组件import App from './components/App.vue'// 创建一个 Vue 实例，使用 render 函数，渲染指定的组件var vm = new Vue(&#123; el: '#app', render: c =&gt; c(App)&#125;); 创建index.htm文件 123456789101112131415161718192021&lt;!DOCTYPE html&gt;&lt;html lang="en"&gt;&lt;head&gt; &lt;meta charset="UTF-8"&gt; &lt;meta name="viewport" content="width=device-width, initial-scale=1.0"&gt; &lt;meta http-equiv="X-UA-Compatible" content="ie=edge"&gt; &lt;title&gt;Document&lt;/title&gt;&lt;/head&gt;&lt;body&gt; &lt;!-- 这是容器 --&gt; &lt;div id="app"&gt; &lt;!-- 使用组件 --&gt; &lt;App&gt;&lt;/App&gt; &lt;/div&gt;&lt;/body&gt;&lt;/html&gt; 运行命令 1npm run dev 运行成功 在vue组件页面中，集成vue-router路由模块安装运行依赖 1npm i vue-router -S 导入路由模块： 1import VueRouter from &apos;vue-router&apos; 安装路由模块： 1Vue.use(VueRouter); 导入需要展示的组件: 12import login from &apos;./components/account/login.vue&apos;import register from &apos;./components/account/register.vue&apos; 创建路由对象: 1234567var router = new VueRouter(&#123; routes: [ &#123; path: &apos;/&apos;, redirect: &apos;/login&apos; &#125;, &#123; path: &apos;/login&apos;, component: login &#125;, &#123; path: &apos;/register&apos;, component: register &#125; ]&#125;); 将路由对象，挂载到 Vue 实例上: 12345678var vm = new Vue(&#123; el: &apos;#app&apos;, // render: c =&gt; &#123; return c(App) &#125; render(c) &#123; return c(App); &#125;, router // 将路由对象，挂载到 Vue 实例上&#125;); 改造App.vue组件，在 template 中，添加router-link和router-view： 1234&lt;router-link to=&quot;/login&quot;&gt;登录&lt;/router-link&gt;&lt;router-link to=&quot;/register&quot;&gt;注册&lt;/router-link&gt;&lt;router-view&gt;&lt;/router-view&gt; 组件中的css作用域问题/ 普通的 style 标签只支持 普通的 样式，如果想要启用 scss 或 less ，需要为 style 元素，设置 lang 属性 / // 只要 咱们的 style 标签， 是在 .vue 组件中定义的，那么，推荐都为 style 开启 scoped 属性]]></content>
      <categories>
        <category>vue</category>
      </categories>
      <tags>
        <tag>vue</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[vue响应式原理]]></title>
    <url>%2Fposts%2F6c6ad520%2F</url>
    <content type="text"><![CDATA[vue响应式原理 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253&lt;!DOCTYPE html&gt;&lt;html lang="en"&gt;&lt;head&gt; &lt;meta charset="UTF-8"&gt; &lt;meta name="viewport" content="width=device-width, initial-scale=1.0"&gt; &lt;meta http-equiv="X-UA-Compatible" content="ie=edge"&gt; &lt;title&gt;Document&lt;/title&gt;&lt;/head&gt;&lt;body&gt; &lt;!-- 输入数据的文本框 --&gt; &lt;input v-model type="text"&gt; &lt;!-- 同步显示数据的dom元素 --&gt; &lt;h2 v-text&gt;&lt;/h2&gt; &lt;h2 v-text&gt;&lt;/h2&gt;&lt;/body&gt;&lt;/html&gt;&lt;script&gt; // 定义一个数据对象 let data = &#123;&#125; // 给这个数据对象设置一个可以观察改变的属性message Object.defineProperty(data, 'message', &#123; // 取值的时候触发 get() &#123; console.log('get触发啦'); // 通过data.message取值的时候返回观察改变的属性 return message; &#125;, // 赋值的时候触发 set(value) &#123; console.log('set触发啦'); // 设置属性message的值 message = value; // 同步所有v-text的值 let arr = document.querySelectorAll('[v-text]'); arr.forEach(v =&gt; &#123; v.innerText = message; &#125;) document.querySelector('[v-model]').value = message; &#125; &#125;) // input标签数据改变时 同步修改 有v-text指令的标签内部的内容 // onchange 值改变 文本框的话 失去焦点的时候触发 // oninput 只要输入内容 就会一直触发 document.querySelector('[v-model]').oninput = function () &#123; // console.log(this.value) data.message = this.value; &#125;&lt;/script&gt;]]></content>
      <categories>
        <category>vue</category>
      </categories>
      <tags>
        <tag>vue</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[模块化的目的]]></title>
    <url>%2Fposts%2F838ad06b%2F</url>
    <content type="text"><![CDATA[模块化的目的 防止全局变量污染 全局作用域下写代码 模块化方案方案1 抽取到 对象中 12&gt; let obj=&#123;sayHI()&#123;&#125; name&#125;&gt; 沙箱 (function(w){})(window) 函数体 声明变量 增加属性 暴露出去 window.xx = xx; 方案2 CMD common model define sea.js 不在维护 淘宝 玉伯 写的 方案3 AMD async model define require.js common.js require module.exports 方案4 ES6的规范 import export default 兼容性不太好不过有babel]]></content>
      <categories>
        <category>vue</category>
      </categories>
      <tags>
        <tag>vue</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[node模块化及module.exports和exports的区别]]></title>
    <url>%2Fposts%2Ffaea0a8c%2F</url>
    <content type="text"><![CDATA[node模块化及module.exports和exports的区别 模块:(一个,或者是一类功能的集合) 模块化: 把常用的 公共的部分 进行封装 抽取为模块 1.浏览器中的模块化封装(沙箱)浏览器端的js,一个页面中所有的js作用域都是一个,所以需要使用自执行函数进行包裹 12345678910111213141516171819202122// js中 函数可以创建作用域;(function (w) &#123; // 1.写功能 function sayHi() &#123; console.log('吃了吗?') &#125; // 多个功能 function eatNoodle() &#123; console.log('滋遛滋遛') &#125; function eatDumplings() &#123; console.log('吧唧吧唧') &#125; // 2.暴露出去 让外部可以访问 需要暴露多个方法可以才采用对象的方式 // w.sayHi = sayHi; w.hQuery = &#123; sayHi, eatDumplings, eatNoodle &#125;&#125;)(window) 2.node模块封装服务端的js(node.js),每个js文件 都有自己独立的作用域,可以理解为 新建一个 js文件,自动帮我们用自执行函数包裹了一次,暴露出去 在 Node 没有全局作用域，它是文件模块作用域 123456789101112131415161718192021222324252627// 1.写功能function sun() &#123; console.log('滋滋的声音')&#125;function moon() &#123; console.log('代表月亮消灭你')&#125;function star() &#123; console.log('一闪一闪亮晶晶')&#125;// 2.暴露出去// 直接暴露一个函数 外部接收到的就是 一个函数// module.exports = sun;// 如果功能很多 暴露 一个对象出去 把功能写到对象上// module.exports = &#123;// sun,// moon// &#125;// 可以直接为exports 赋值一个新对象 或者直接动态为他增加属性 因为他就是一个 对象module.exports.sun = sun;module.exports.moon = moon;module.exports.star = star; 3.node模块的使用123456789101112// 1.导入模块(导包)// 如果是js文件 后缀名可以不写 const sun = require('./02.模块定义')// const sun = require('./02.模块定义.js')// 返回一个函数,调用函数// sun();// 2.导入模块(导包) 暴露了一个对象const light = require('./02.模块定义');console.log(light);// light.moon(); 4.module.exports和exports的区别模块暴露原理 123456789// 在 Node 中，每个模块内部都有一个自己的 module 对象// 该 module 对象中，有一个成员叫：exports 也是一个对象var module = &#123;//是一个外部对象 exports: &#123;//是一个内部对象 foo: 'bar', add: function &#125;&#125; 12345678// 也就是说如果你需要对外导出成员，只需要把导出的成员挂载到 module.exports 中// 可以直接为exports 赋值一个新对象 或者直接动态为他增加属性 因为他就是一个 对象module.exports=&#123;&#125;//--------------------------------//function sun() &#123; console.log('滋滋的声音')&#125;module.exports.sun = sun; 123456// 我们发现，每次导出接口成员的时候都通过 module.exports.xxx = xxx 的方式很麻烦，点儿的太多了// 所以，Node 为了简化你的操作，专门提供了一个变量：exports 等于 module.exports// 也就是说在模块中还有这么一句代码 , 哪么exports中保存的也就是module.exports对象var exports = module.exports// console.log(exports === module.exports)//true 12345678910//它们的对象关系为module.exports.foo = 'bar'module.exports.add = function (x, y) &#123; return x + y&#125;//等同于下面exports.foo = 'bar'module.exports.add = function (x, y) &#123; return x + y&#125; 使用exports需要注意的事项 123456789101112// 当一个模块需要导出单个成员的时候// 直接给 exports 赋值是不管用的// 给 exports 赋值会断开和 module.exports 之间的引用// 同理，给 module.exports 重新赋值也会断开// 这里导致 exports !== module.exportsmodule.exports = &#123; foo: 'bar' &#125;// 当然可以重新建立两者的引用关系exports = module.exports 123456// exports !== module.exports// 最终 return 的是 module.exports// 所以无论你 exports 中的成员是什么都没用exports = &#123; a : 456&#125;; module.exports和exports方式写法 1234567891011121314151617181920212223242526272829303132333435363738//js文件var foo = "bar";function add(x, y) &#123; return x + y;&#125;// 如果想要将上面定义的add方法暴露出去,采用下面这种方式不行// exports = add// 如果一个模块需要直接导出某个成员，而非挂载的方式(即,成员不是exports对象里面的属性或方法)// 那这个时候必须使用下面这种方式module.exports = "hello";module.exports = function (x, y) &#123; return x + y;&#125;;//如果一个模块需要直接导出多个成员,可以采用导出对象的方法module.exports = &#123; add: function () &#123; return x + y; &#125;, str: "hello"&#125;;// 只能得到我想要给你的成员// 这样做的目的是为了解决变量命名冲突的问题// exports.add = add// exports 是一个对象// 我们可以通过多次为这个对象添加成员实现对外导出多个内部成员// exports.str = 'hello' 总结: 12345678910111213141516171819202122232425// 真正去使用的时候：//挂载到对象模式// 导出多个成员：exports.xxx = xxx //给对象动态添加成员// 导出多个成员 : module.exports.xxx = xxx;// 导出多个成员也可以：module.exports = &#123; //一次性导出一个对象// &#125;//非挂载到对象模式 // 导出单个成员：module.exports=xxxx//不能采用// 导出单个成员：exports=xxxx //因为会断开与module.exports的连接,return的是 module.exports//注意:// 谁来 require 我，谁就得到 module.exports// 默认在代码的最后有一句：// 一定要记住，最后 return 的是 module.exports// 不是 exports// 所以你给 exports 重新赋值不管用，// return module.exports]]></content>
      <categories>
        <category>node</category>
      </categories>
      <tags>
        <tag>node</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[node中的__dirname，path.resolve()和path.join()]]></title>
    <url>%2Fposts%2Fb7184d6f%2F</url>
    <content type="text"><![CDATA[node中的__dirname，path.resolve()和path.join() 1. __dirname1//__dirname指的是当前文件所在文件夹的绝对路径 测试路径如下： 12345即 根目录/dir0.js 根目录/path1/dir1.js 根目录/paht1/path2/dir2.js 每个dir.js文件里的代码都只有一行（号代表数字，下同）： 1console.log(&apos;dir*: &apos;+__dirname); 一.在根目录下执行上述3个js文件1.执行node dir0.js12PS C:\Users\Administrator\Desktop\dirname&gt; node dir0.jsdir0: C:\Users\Administrator\Desktop\dirname 2.执行node dir1.js12PS C:\Users\Administrator\Desktop\dirname&gt; node path1/dir1.jsdir1: C:\Users\Administrator\Desktop\dirname\path1 3.执行node dir2.js12PS C:\Users\Administrator\Desktop\dirname&gt; node path1/path2/dir2.jsdir2: C:\Users\Administrator\Desktop\dirname\path1\path2 总结：在根目录下执行不同目录下的3个文件，__dirname地址分别为3个文件所在文件夹的绝对路径。 二.在当前文件所在文件夹下执行js文件1.执行node dir0.js与上面一致。 2.执行node dir1.js12PS C:\Users\Administrator\Desktop\dirname\path1&gt; node dir1.jsdir1: C:\Users\Administrator\Desktop\dirname\path1 3.执行node12PS C:\Users\Administrator\Desktop\dirname\path1\path2&gt; node dir2.jsdir2: C:\Users\Administrator\Desktop\dirname\path1\path2 总结：在当前文件所在文件夹下执行js文件,__dirname为当前文件所在文件夹绝对路径。 所以：综上所述， __dirname指的是当前文件所在文件夹的绝对路径。 2.path.resolve()path.resolve([arg1,arg2,…])根据参数的不同，返回值存在两种情况。 以下为参数的两种情况： 1.每个参数都不带’/‘，比如path.resolve(),或者path.resolve(‘path1’,’path2’)，或者path.resolve(‘./path’); 2.一个或多个参数最开头带’/‘符号 path.resolve(‘/path’); 返回值分别为： 1.绝对路径 2.相对路径 下面具体分析： 1.参数为空：*path.resolve()或者paht.resolve(‘’) 1输出：当前文件所在文件夹路径 === __dirname 2.参数为文件夹名字(参数&gt;=1):*path.resolve(‘path’) 1输出：当前文件所在文件夹绝对路径/path *或者 path.resolve(‘path1’,’path2’) 1输出：当前文件所在文件夹绝对路径/path1/path2 *或者 path.resolve(‘path1’,’path2’…….’pathX’) 1输出：当前文件所在文件夹绝对路径/path1/path2...../pathX 3. 某个参数为’./‘+文件名*path.resolve(‘./path’) 1输出：当前文件所在文件夹绝对路径/path *或者path.resolve(‘path1’,’./path2’) 1输出：当前文件所在文件夹绝对路径/path1/path2 4.文件夹名字前加了’/‘注意，无论是第几个文件前加了/！！！最终路径都为：/+‘最后一个前面加/的文件文件名’+‘剩下文件夹’ 好的，我知道上面那句话很难懂，那就看例子 4.1.path.resolve(‘/path’)1输出: /path 4.2.4.2.1path.resolve(‘path1’,’path2’,’/path3’)*前两个path前没有斜杠，只最后一个有 1输出: /path2 4.2.2.path.resolve(‘path1’,’/path2’,’/path3’)*后面两个path都有斜杠 1输出：/path2 看到没，跟path1,path2,根本没有任何关系，因为最后一个path2前面有斜杠/，所以地址为path2 4.3.path.resolve(‘path1’,’/path2’,’path3’)*path2有斜杠，后面的path3没有斜杠 1输出: /path2/path3 总结：if(当path.resolve参数中不存在最开头带/的参数时) return 绝对路径else return /+‘最后一个前面加/的文件文件名’+‘剩下文件夹’** 带/的参数：举个例子来解释就是 ‘/path’。 注：不包括’./path’ 路径解析：path.resolve([from …], to) path.resolve()方法可以将多个路径解析为一个规范化的绝对路径。其处理方式类似于对这些路径逐一进行cd操作，与cd操作不同的是，这引起路径可以是文件，并且可不必实际存在（resolve()方法不会利用底层的文件系统判断路径是否存在，而只是进行路径字符串操作）。例如： 1path.resolve(&apos;foo/bar&apos;, &apos;/tmp/file/&apos;, &apos;..&apos;, &apos;a/../subfile&apos;) 其处理方式类型于 12345cd foo/barcd /tmp/file/cd ..cd a/../subfilepwd 如果解析的不是绝对路径，path.resolve()会将当前工作目录加到解析结果的前面。例如： 1234567891011path.resolve(&apos;/foo/bar&apos;, &apos;./baz&apos;)// 输出结果为&apos;/foo/bar/baz&apos;path.resolve(&apos;/foo/bar&apos;, &apos;/tmp/file/&apos;)// 输出结果为&apos;/tmp/file&apos;path.resolve(&apos;wwwroot&apos;, &apos;static_files/png/&apos;, &apos;../gif/image.gif&apos;)// 当前的工作路径是 /home/itbilu/node，则输出结果为&apos;/home/itbilu/node/wwwroot/static_files/gif/image.gif&apos; path.join()path.join([path1][, path2][, …]) path.join()方法可以连接任意多个路径字符串。要连接的多个路径可做为参数传入。 path.join()方法在接边路径的同时也会对路径进行规范化。例如： 12345678910var path = require(&apos;path&apos;);//合法的字符串连接path.join(&apos;/foo&apos;, &apos;bar&apos;, &apos;baz/asdf&apos;, &apos;quux&apos;, &apos;..&apos;)// 连接后&apos;/foo/bar/baz/asdf&apos;//不合法的字符串将抛出异常path.join(&apos;foo&apos;, &#123;&#125;, &apos;bar&apos;)// 抛出的异常TypeError: Arguments to path.join must be strings&apos;]]></content>
      <categories>
        <category>node</category>
      </categories>
      <tags>
        <tag>node</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[node异常捕获-try catch]]></title>
    <url>%2Fposts%2Fc51f86b4%2F</url>
    <content type="text"><![CDATA[node异常捕获-try catch 123456789101112131415// 有一段代码 可能出错 我希望在出错的时候 知道 并且不影响后续代码的执行try &#123; // try中 写的是 可能出错的代码 console.log(foodName)&#125; catch (error) &#123; // error 是错误的信息 // 可以根据错误信息的内容 进行不同的处理 console.log(error); // 如果真的出错的 会执行 catch中的代码 // 对这个错误进行处理 console.log('卧槽 真的错了!!')&#125;console.log('我是底部的代码')]]></content>
      <categories>
        <category>node</category>
      </categories>
      <tags>
        <tag>node</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[node内置模块-http]]></title>
    <url>%2Fposts%2F3b6d3631%2F</url>
    <content type="text"><![CDATA[node内置模块-http 启动一个node服务器 1234567891011121314151617181920212223// 导入模块 (引包)const http = require('http');// 用包// 创建服务器 create Server (等同于 安装了 phpStudy 中的Apache)// let server = http.createServer(function(request,response)&#123;// let server = http.createServer(function(req,res)&#123;let server = http.createServer((req,res)=&gt;&#123; // console.log('运行了'); // 返回内容给浏览器 返回响应报文 // response.end('hello world'); // 返回之前设置一个响应头 告诉浏览器编码是什么 res.setHeader('content-type','text/html;charset=utf-8') // 响应内容 res.end('你好 靓仔 靓妹');&#125;)// 启动服务器// server.listen('8848','127.0.0.1',()=&gt;&#123;server.listen('8848',()=&gt;&#123;// 不写地址 默认是 127.0.0.1 本机 当前局域网本机的ip console.log('开起来啦!!1');&#125;) 注意:需要设置响应头,因为如果不设置,浏览器不知道用什么来解析,会用中文win系统的gbk来解析utf-8,会导致乱码 fs模块结合http模块使用 123456789101112131415161718192021222324252627282930313233343536/** * http开启服务器 * fs读取文件 * 用户访问的时候 读取index.html 并返回 * */// 导入 内置模块 fsconst fs = require('fs');// 导入 内置模块 httpconst http = require('http');// http创建服务器// let server = http.createServer(function(request,response)&#123;&#125;)let server = http.createServer((req,res)=&gt;&#123; // 请求过来之后 就会执行 // 读取index.html 并返回 fs.readFile('./www/index1.html',(err,data)=&gt;&#123; // 如果有错 提示 if(err)&#123; // console.log('读取失败啦'); res.end('404 not find'); &#125;else&#123; // 如果没有错 返回 res.end(data.toString()) &#125; &#125;) // 在这里 文件还没有读取出来&#125;)// 开启监听server.listen('8888',()=&gt;&#123; console.log('开启啦!8888');&#125;)]]></content>
      <categories>
        <category>node</category>
      </categories>
      <tags>
        <tag>node</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[node内置模块-fs]]></title>
    <url>%2Fposts%2Fc51f86b4%2F</url>
    <content type="text"><![CDATA[node内置模块-fs 1.读取资源fs.readFile() 同步 fs.readFileSync() 异步 12345678910111213141516171819202122232425262728// node.js中 提供了文件读写功能 但是在一个 "模块"中 为了使用 先要 引入 script src="地址"// node.js中 导入模块的语法是 require('模块名')// 文件的模块名叫做 fs(fileSystem)// 导入模块 (类似于 导包 )const fs = require('fs');//--------------------异步读取文件--------------------// fs.readFile('./data/novel.txt',function(err,data)&#123;//参数1 路径 参数2 回调函数// fs.readFile('./data/novel2.txt',function(err,data)&#123;// // 如果读取成功 err是null(没错)// // console.log(err);// // data 默认打印的是&lt;Buffer 但是正常人看不懂 转换为 字符串 // // console.log(data.toString());// if(err)&#123;// // 如果有错 err是错误信息 // console.log(err);// &#125;else&#123;// console.log(data.toString());// &#125;// &#125;)// console.log('底部的代码')//--------------------同步读取文件--------------------// Sync结尾的都是同步的执行 依次往下let data = fs.readFileSync('./data/novel.txt')console.log(data.toString());console.log('底部的代码') 2.写入资源fs.writeFile() 异步 fs.writeFileSync() 同步 12345678910111213141516171819// 导入 fs 模块const fs = require('fs');// 执行对应的方法//--------------------异步写文件--------------------//参数1 路径 参数2 写入的内容 参数3 回调函数// fs.writeFile('./data/novel2.txt','咏鹅,鹅鹅鹅,曲项向天歌,白毛浮绿水,红掌拨清波',function(err)&#123;// fs.writeFile('./data/novel3.txt','咏鹅,鹅鹅鹅,曲项向天歌,白毛浮绿水,红掌拨清波',function(err)&#123;// // console.log(err);// if(err)&#123;// console.log('文件写入失败');// &#125;else&#123;// console.log('写入成功');// &#125;// &#125;)// console.log('底部的代码');//--------------------同步写文件--------------------fs.writeFileSync('./data/novel2.txt','锄禾 锄禾日当午,汗滴禾下土,谁知盘中餐,粒粒皆辛苦')console.log('底部的代码') 写入资源时，如果该路径下文件保存在，会自动创建该文件 3.判断文件是否存在fs.existsSync 同步,异步的已经被废弃 12// !判断文件是否存在 , 参数为路径 , 返回布尔值let isExists = fs.existsSync(fullPath); 4.获取文件信息fs.stat(path, callback) 异步 fs.stat(path)执行后，会将stats类的实例返回给其回调函数 通过stats类中的提供很多方法,比如判断文件的相关属性 方法 描述 stats.isFile() 如果是文件返回 true，否则返回 false。 stats.isDirectory() 如果是目录返回 true，否则返回 false。 fs.statSync(path) 同步 stat(). 返回 fs.Stats 的实例。 12345678910111213141516171819//一般常用statSync同步 // *判断文件是文件还是文件夹 // !先获取资源的信息,通过返回的对象,调用里面的方法就可以知道资源是什么类型的 let fsStatus = fs.statSync(fullPath); console.log("fsStatus:" + fsStatus); // ?如果是文件 if (fsStatus.isFile() == true) &#123; //........... &#125; // ?如果是文件夹 if (fsStatus.isDirectory() == true) &#123; //........... &#125; 7.读取目录fs.readdir(path, callback) 异步 fs.readdirSync(path) 同步 (常用) 返回一个数组,里面包含这个路径下文件和文件夹的名字 12// ?读取文件夹里面的文件资源生成一个数组 let dirList = fs.readdirSync(fullPath)]]></content>
      <categories>
        <category>node</category>
      </categories>
      <tags>
        <tag>node</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[npm和cnpm及yarn下包的基本知识]]></title>
    <url>%2Fposts%2F50166e59%2F</url>
    <content type="text"><![CDATA[1.cnpm下包的基本知识 初始化项目,还是采用npm的方式初始化 12npm init -y //自动生成 默认信息npm init //手动输入信息 安装第三方模块,采用cnpm的方式 1cnpm install 模块名 --save //安装模块并且保存信息到 package.json中 为了运行项目 直接在package.json 同级目录下 执行 cnpm install 即可 共享保存了第三方包信息的 项目时 可以删除 node_modules 根据package.json 一次性安装所有必须模块 1cnpm install //读取package.json中的第三方模块信息 依次安装 依赖的模块也会一起安装 2.npm 下包的基本知识 初始化项目 12npm init -y //自动生成 默认信息npm init //手动输入信息 安装第三方模块 123npm install 模块名 //安装模块并且保存信息到 package.json中 //默认会 保存到 package.json中 哪怕不写 --save //因为高版本node会自动创建一个 package-lock.json,保存模块的详细信息和依赖,就不用写--save,也会保存到package.json中的 额外的创建一个 package-lock.json 1//保存模块的详细信息 包含了地址 下次安装的时候 直接去这个地址下载 速度更快一点 根据package.json 一次性安装所有必须模块 1npm install //依赖的模块也会一起安装 3.提升下包速度安装命令的后面 加上上面的指令 即可提速 ,使用淘宝镜像 1--registry=https://registry.npm.taobao.org 4.yarn的基本使用1https://yarn.bootcss.com/ node的第三方包管理工具 npm 官方的 cnpm 国内 淘宝 yarn facebook弄出来的 命令 1初始化 yarn init -y 1安装模块 yarn add 模块 1安装package.json中保存的依赖 yarn 或者 yarn install 1如果速度慢 采用淘宝源 --registry=https://registry.npm.taobao.org]]></content>
      <categories>
        <category>node</category>
      </categories>
      <tags>
        <tag>node</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[字体图标的原理和基本使用]]></title>
    <url>%2Fposts%2F253f9b8f%2F</url>
    <content type="text"><![CDATA[字体图标的原理和基本使用 1.什么是字体图标 字体图标（有特殊含义的图片）使用都是svg图片，svg是矢量图，放大了不会失真和字体一样 svg图标设计师会提供，前端需要把svg图标去转成字体图标 为了减少网络请求，把svg图标打包到字体文件里面，通过字体图标的方式使用 图片是有诸多优点的，但是缺点很明显，比如图片不但增加了总文件的大小，还增加了很多额外的”http请求”，这都会大大降低网页的性能的。更重要的是图片不能很好的进行“缩放”，因为图片放大和缩小会失真 字体图标的有点 12345可以做出跟图片一样可以做的事情,改变透明度、旋转度，等..但是本质其实是文字，可以很随意的改变颜色、产生阴影、透明效果等等...本身体积更小，但携带的信息并没有削减。几乎支持所有的浏览器移动端设备必备良药... 2.字体图标的下载和生成 使用阿里官方提供图标，添加到购物车下载代码 让设计师设计图标（必须svg(矢量图放大缩小不会失真)） 把设计师提供的图标文件，上传到阿里图标库里面 再把上传的图标加入购物车下载代码 把下载的代码复制到项目里面引入来使用 3.字体图标的原理 字体图标：由字体文件 + 字体名称 + 图标编码组成 字体文件，有四种 eot、woff、ttf、svg eot 兼容IE woff 标准的文件 ttf 兼容谷歌火狐等 svg 兼容低版本的ios浏览器 字体名称： 字体图标的字体名称 定义字体 123456789101112/* @font-face CSS3里面新增的属性 web字体 使用CSS定义一个字体 指定你要定义的字体名称 和 字体文件的路径 需要声明用 format 格式*/@font-face &#123; /*定义字体名称*/ font-family: 'iconfont'; /*引入字体文件，为了兼容各种浏览器引入多个文件*/ src: url('iconfont.eot?t=1543800973803') format('embedded-opentype'), /*eot 兼容IE*/ url('../fonts/xxx.ttf') format('truetype'), /*woff 标准的文件*/ url('iconfont.ttf') format('truetype'), /*ttf 兼容chrome, firefox, opera, Safari,Android, iOS 4.2+*/ url('iconfont.svg?t=1543800973803#iconfont') format('svg'); /* iOS 4.1- */ &#125; 图标编码: content: “\e602”; 这种是unicode编码 作用：由于字体名称是代表所有图标的一个集合字体，为了让元素知道使用哪个字体图标，就要给元素使用编码，不过这个编码是网站给生成的，不需要记住 直接使用编码 使用图标的编码时，编码只能在伪元素使用 注意点 12345678//注意：要给某个元素（如div）使用字体时，必须给这个元素的样式中写字体的名称和图标编码，由于只能在伪元素中使用 //给div直接 div::before &#123; /1. 使用字体名称/ font-family: 'iconfont'; /2. 使用图标的编码/ content: "\e62b"; &#125; 字体图标使用原理详解1.直接使用法第一步：在iconfont.css中定义字体名称,引入源文件 12345678910111213/* @font-face CSS3里面新增的属性 web字体 使用CSS定义一个字体 指定你要定义的字体名称 和 字体文件的路径 需要声明用 format 格式*/@font-face &#123; /*定义字体名称*/ font-family: 'iconfont'; /*引入字体文件，为了兼容各种浏览器引入多个文件*/ src: url('iconfont.eot?t=1543800973803') format('embedded-opentype'), /*eot 兼容IE*/ url('../fonts/xxx.ttf') format('truetype'), /*woff 标准的文件*/ url('iconfont.ttf') format('truetype'), /*ttf 兼容chrome, firefox, opera, Safari,Android, iOS 4.2+*/ url('iconfont.svg?t=1543800973803#iconfont') format('svg'); /* iOS 4.1- */ &#125; 第二步：在HTML页面中引入iconfont.css，使用通过伪类选择器使用字体图标，注意给元素同时设置字体和编码才有效 1234567891011121314151617181920212223242526272829303132&lt;!DOCTYPE html&gt;&lt;html lang="en"&gt;&lt;head&gt; &lt;meta charset="UTF-8"&gt; &lt;title&gt;Document&lt;/title&gt; &lt;!-- 1. 引入你图标的字体名称 --&gt; &lt;link rel="stylesheet" href="iconfont.css"&gt; &lt;style&gt; /*直接使用法,由于编码只能在伪元素使用,所以通过伪元素选择器找到div,将编码写在content中即可*/ div::before &#123; /*1. 给div使用字体名称*/ font-family: 'iconfont'; /*2. 给div使用图标的编码*/ content: "\e62b"; &#125; &lt;/style&gt;&lt;/head&gt;&lt;body&gt; &lt;!-- 2. 使用图标的编码 编码只能在伪元素使用，不能在双标签的内容中的文本 下方这样写是不能生效的--&gt; &lt;div&gt;"\e602"&lt;/div&gt; &lt;/body&gt;&lt;/html&gt; 2.通过定义类用法第一步：在iconfont.css中定义字体名称,引入源文件 12345678910111213/* @font-face CSS3里面新增的属性 web字体 使用CSS定义一个字体 指定你要定义的字体名称 和 字体文件的路径 需要声明用 format 格式*/@font-face &#123; /*定义字体名称*/ font-family: 'iconfont'; /*引入字体文件，为了兼容各种浏览器引入多个文件*/ src: url('iconfont.eot?t=1543800973803') format('embedded-opentype'), /*eot 兼容IE*/ url('../fonts/xxx.ttf') format('truetype'), /*woff 标准的文件*/ url('iconfont.ttf') format('truetype'), /*ttf 兼容chrome, firefox, opera, Safari,Android, iOS 4.2+*/ url('iconfont.svg?t=1543800973803#iconfont') format('svg'); /* iOS 4.1- */ &#125; 第二步：在iconfont.css中,将定义的 字体图标的名称 和 编码 封装到一个类里面，如果需要直接在标签中添加类即可 12345678910/*封装一个字体类*/.iconfont &#123; /*iconfont字体名称*/ font-family:"iconfont" !important; font-size:16px; font-style:normal; -webkit-font-smoothing: antialiased; -moz-osx-font-smoothing: grayscale;&#125; 12345 /* 如果用直接使用法需要查找编码，不好记忆和使用， 为了方便使用和记忆把编码定义在一个类名里面 使用的时候使用类名即可 */.jiantou::before &#123; content: "\e62b"; &#125; 第三步：在HTML页面中引入iconfont.css，使用通过伪类选择器使用字体图标，注意给元素同时设置字体和编码才有效 12345678910111213141516171819&lt;!DOCTYPE html&gt;&lt;html lang="en"&gt;&lt;head&gt; &lt;meta charset="UTF-8"&gt; &lt;title&gt;Document&lt;/title&gt; &lt;!-- 1. 引入你图标的字体名称 --&gt; &lt;link rel="stylesheet" href="iconfont.css"&gt;&lt;/head&gt;&lt;body&gt; &lt;!-- 2. 使用图标的编码 编码只能在伪元素使用，不能在双标签的内容中的文本 下方这样写是不能生效的--&gt; &lt;div class="iconfont jiantou"&gt;&lt;/div&gt; &lt;/body&gt;&lt;/html&gt; 3.阿里图标库的使用 在iconfont.css中详解 12345678910111213141516171819202122232425262728293031323334353637383940/*1. @font-face CSS3里面新增的属性 web字体 使用CSS定义一个字体 指定你要定义的字体名称 和 字体文件的路径 */@font-face &#123; /*定义字体名称，字体可以修改*/ font-family: "iconfont"; /*引入字体文件 为了兼容各种浏览器引入多个文件*/ src: url('iconfont.eot?t=1543800973803'); /* IE9*/ src: url('iconfont.eot?t=1543800973803#iefix') format('embedded-opentype'), /* IE6-IE8 */ url('data:application/x-font-woff;charset=utf==') format('woff'), url('iconfont.ttf?t=1543800973803') format('truetype'), /* chrome, firefox, opera, Safari, Android, iOS 4.2+*/ url('iconfont.svg?t=1543800973803#iconfont') format('svg'); /* iOS 4.1- */&#125;/*2.使用一个字体，定义字体类*/.iconfont &#123; /*使用iconfont字体*/ font-family:"iconfont" !important; font-size:16px; font-style:normal; -webkit-font-smoothing: antialiased; -moz-osx-font-smoothing: grayscale;&#125;/*3.使用图标的编码 定义编码类*/.icon-icon-test:before &#123; content: "\e602"; &#125;.icon-icon-test1:before &#123; content: "\e603"; &#125;.icon-icon-test2:before &#123; content: "\e604"; &#125;.icon-mountains__ea:before &#123; content: "\e629"; &#125;.icon-arrows__easyi:before &#123; content: "\e62a"; &#125;.icon-odin__easyico:before &#123; content: "\e62b"; &#125; 在HTML文件中引入字体 iconfont.css 1234 &lt;!-- 在标签中引入类名，即可完成图标引入 --&gt;&lt;i class="iconfont icon-icon-test"&gt;&lt;/i&gt;&lt;i class="iconfont icon-mountains__ea"&gt;&lt;/i&gt; 注意：如果只是给元素添加编码没有加字体名称，哪么只会出现一个框框占位，如果只给字体名称，没有给编码，啥都不会显示 简化字体图标的使用123456789101112/*如果图标写了公共的属性选择器匹配了所有字体图标的类名，只需要写一个类名,不像之前的iconfont要使用2个类名*//*[class^="icon-"]匹配所有类名以icon-开头的元素 [class*=" icon-"]中间包含了空格icon-的元素 后续类名以icon-开头*/[class^="icon-"],[class*=" icon-"] &#123; font-style: normal;/*注意上面选择器中间的空格我们使用的名为iconfont的字体就是最上面的@font-face的方式声明*//*当字体名字之间有空格的都要用引号引起来 ,如果没有空格的话可以不用引号*/ font-family: iconfont;&#125; 字体图标使用流程(重点)总体来说，字体图标按照如下流程： 设计字体图标假如图标是我们公司单独设计，那就需要第一步了，这个属于UI设计人员的工作， 他们在 illustrator 或 Sketch 这类矢量图形软件里创建 icon图标， 比如下图： 之后保存为svg格式，然后给我们前端人员就好了。 （一般都是使用现成的字体图标）。 上传生成字体包 当UI设计人员给我们svg文件的时候，我们需要转换成我们页面能使用的字体文件， 而且需要生成的是兼容性的适合各个浏览器的。 ​ 推荐网站： http://icomoon.io icomoon字库（推荐） IcoMoon成立于2011年，推出的第一个自定义图标字体生成器，它允许用户选择他们所需要的图标，使它们成一字型。 内容种类繁多，非常全面，唯一的遗憾是国外服务器，打开网速较慢。 推荐网站： http://www.iconfont.cn/ 阿里icon font字库（推荐） http://www.iconfont.cn/ 这个是阿里妈妈M2UX的一个icon font字体图标字库，包含了淘宝图标库和阿里妈妈图标库。可以使用AI制作图标上传生成。 一个字，免费，免费！！ fontello http://fontello.com/ 在线定制你自己的icon font字体图标字库，也可以直接从GitHub下载整个图标集，该项目也是开源的。 Font-Awesome http://fortawesome.github.io/Font-Awesome/ 这是我最喜欢的字库之一了，更新比较快。目前已经有369个图标了。 Glyphicon Halflings http://glyphicons.com/ 这个字体图标可以在Bootstrap下免费使用。自带了200多个图标。 Icons8 https://icons8.com/ 提供PNG免费下载，像素大能到500PX 下载兼容字体包刚才上传完毕， 网站会给我们把UI做的svg图片转换为我们的字体格式， 然后下载下来就好了 当然，我们不需要自己专门的图标，是想网上找几个图标使用，以上2步可以直接省略了， 直接到刚才的网站上找喜欢的下载使用吧。 字体引入到HTML得到压缩包之后，最后一步，是最重要的一步了， 就是字体文件已经有了，我们需要引入到我们页面中。 首先把不管其他的，把所有的文件放到文件夹中 第一步：引用iconfont.css1&lt;link rel="stylesheet" type="text/css" href="./iconfont.css"&gt; 第二步：给盒子使用字体123&lt;i class="iconfont icon-xxx"&gt;&lt;/i&gt;或者&lt;i class="iconfont"&gt;&amp;#x33;&lt;/i&gt; 开发中遇到可能遇到的问题1.字体图标需要修改？ 答：将需要修改的字体，修改好，上传到图标库，然后重新下载，覆盖掉现在的字体图标，注意之前上传的图标名字不能改变，不然字体图标会失效]]></content>
      <categories>
        <category>移动web</category>
      </categories>
      <tags>
        <tag>移动web</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[移动端一些触摸事件]]></title>
    <url>%2Fposts%2F69a87088%2F</url>
    <content type="text"><![CDATA[移动端一些触摸事件 touchstart 手指触摸的时候触发 触摸开始，手指按下马上触发，但是一个触摸过程只会触发一次touchstart事件 touchmove 手指移动的时候触发 触摸移动，手指按下并且滑动的时候会不断触发，一个触摸过程可以触发多次touchmove事件 touchend 手指触摸离开的时候触发 触摸结束 触摸松开手的时候会触发事件，一次触摸过程只会触发一次touchend事件 touchcancel 触摸意外中断会触发，触摸的时候遇到了优先级更高的事件 触摸取消(中断)事件(很少用) 注意：使用addEventListener方式添加事件 移动端click（点击）事件的延迟问题 在移动端的click事件，有一定延迟的， 大概300ms左右 延迟的原因，是手机端为了兼容双击操作，如果300ms以内点击2次就认为是双击事件，如果300ms以内只点击了一次就是单击操作 解决方案，就是使用touch系列事件封装一个不延迟的click事件，或者使用ffastclick.js、zepto.js 解决点击事件延迟问题的方案 解决延迟的原理，使用移动端touch相关事件模拟一个click (也就tap事件) 因为touch事件在移动端，是不会延迟 只是触发了touchstart和touchend但是没有触发touchmove ，就认为是一个单击操作(单击事件) 如果触发touchmove，就表示手指不仅单击还触发移动，这就不是一个单击操作 还需要添加事件判断，记录滑动开始的时间和滑动结束的时间进行相减判断，手指按下的时间有没有超过300ms，不超过才是单击操作，否则就是长按了 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778&lt;!DOCTYPE html&gt;&lt;html lang="en"&gt;&lt;head&gt; &lt;meta charset="UTF-8"&gt; &lt;title&gt;Document&lt;/title&gt; &lt;style&gt; div &#123; width: 100px; height: 100px; background-color: #ccc; &#125; &lt;/style&gt;&lt;/head&gt;&lt;body&gt; &lt;div&gt;&lt;/div&gt; &lt;script&gt; // 封装一个tap函数 类似于事件的功能 function tap(dom,callback) &#123; //实参给形参赋值 // dom = div // callback = function () &#123; // console.log('这是使用封装的tap事件'); // &#125;; // 默认假设没有触发move事件 var isMove = false; // 按住的时间 var time = 0; var startTime = 0; var endTime = 0; dom.addEventListener('touchstart', function() &#123; //记录按下的时间 startTime = new Date().getTime(); &#125;); dom.addEventListener('touchmove', function() &#123; //如果触发了touchmove把isMove变成true 表示触发了move事件 isMove = true; &#125;); dom.addEventListener('touchend', function() &#123; // end是记录松开手的事件 endTime = new Date().getTime(); // 用松开手的时间 - 按下的事件 == 时间差(整个触摸按住的事件) time = endTime - startTime; console.log(time); // 在touchend判断如果isMove还为false表示没有触发move就是单击事件 // 同时判断time&lt; 300毫秒以内才是单击 if (isMove == false &amp;&amp; time &lt; 300) &#123; // 当触发了touchend但是没有触发touchmove 认为是单击事件 执行回调函数 callback(); &#125; // 一次触摸结束要重置isMove为false isMove = false; &#125;); &#125; var div = document.querySelector('div'); tap(div,function () &#123; console.log('这是使用封装的tap事件'); &#125;); div.addEventListener('click', function () &#123; console.log('原生的click事件'); &#125;); div.addEventListener('tap', function () &#123; console.log('原生tap'); &#125;); &lt;/script&gt;&lt;/body&gt;&lt;/html&gt; 采用fastclick.js包 引包引入fastclick 1&lt;script src="lib/fastclick/fastclick.js"&gt;&lt;/script&gt; 给页面的body元素绑定fastclick，间接为所有元素绑定了之所以是绑定fastclick给body，是因为元素都在body里面，就相当于间接为所有元素都绑定了fastclick 123window.addEventListener('load', function() &#123; new FastClick(document.body);&#125;, false); 后续就直接添加click就不会延迟了 1234// 绑定了fastclick后,添加事件的方式还是和之前一样加click事件 但是这个click已经不会延迟了 div.addEventListener('click', function() &#123; console.log('点击事件'); &#125;); 使用zepto的tap事件来解决延迟的问题 1234567891011121314151617181920212223242526272829303132333435363738394041&lt;!DOCTYPE html&gt;&lt;html lang="en"&gt;&lt;head&gt; &lt;meta charset="UTF-8"&gt; &lt;title&gt;Document&lt;/title&gt; &lt;style&gt; div &#123; width: 100px; height: 100px; background-color: #ccc; &#125; &lt;/style&gt;&lt;/head&gt;&lt;body&gt;&lt;div&gt;&lt;/div&gt;&lt;!-- 1. 引入zepto库 --&gt;&lt;script src="jd/lib/zepto/zepto.min.js"&gt;&lt;/script&gt;&lt;!-- 2. 使用zepto的方式和jquery一样 --&gt;&lt;script&gt; // zepto的入口函数 和jquery一样 $ ( function () &#123; // 获取元素$('选择器') 选择器默认只能传一些基本选择器 querySelector()能够支持选择器 var div = $ ( "div" ); div.on ( "click", function () &#123;//还存在延时的点击事件 console.log ( "click事件" ); &#125; ); // zepto封装的tap事件 原理和前面tap函数一样也是触发touchstart 和 touchend 没有触发touchmove 时间在300ms以内 就是tap //on添加事件的方式 div.on ( "tap", function () &#123; console.log ( "tap事件" ); &#125; ); //函数事件的方式 div.tap ( function () &#123; console.log ( "tap事件" ); &#125; ); &#125; );&lt;/script&gt;&lt;/body&gt;&lt;/html&gt;]]></content>
      <categories>
        <category>移动web</category>
      </categories>
      <tags>
        <tag>移动web</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[左边自适应右边固定的布局方式]]></title>
    <url>%2Fposts%2F82459dae%2F</url>
    <content type="text"><![CDATA[左边自适应右边固定的布局方式 1.浮动方式1234567891011121314151617181920212223242526272829303132333435363738394041424344&lt;!DOCTYPE html&gt;&lt;html lang="en"&gt;&lt;head&gt; &lt;meta charset="UTF-8"&gt; &lt;title&gt;Document&lt;/title&gt; &lt;style&gt; * &#123; box-sizing: border-box; &#125; .product &#123; width: 100%; &#125; /*设置margin-right让左边的盒子距离右边有间距 如果没有设置宽度 自动把左边盒子宽度变小*/ .left &#123; height: 200px; background-color: #ccc; margin-right: 200px; &#125; .right &#123; width: 200px; height: 200px; background-color: yellowgreen; float: right; &#125; &lt;/style&gt;&lt;/head&gt;&lt;body&gt; &lt;div class="product"&gt; &lt;!-- 先让右边浮起来 --&gt; &lt;div class="right"&gt;&lt;/div&gt; &lt;!-- 左边自然跟上来了浮动脱标 left会顶上去 --&gt; &lt;div class="left"&gt;&lt;/div&gt;&lt;/div&gt;&lt;/body&gt;&lt;/html&gt; 2.定位方式123456789101112131415161718192021222324252627282930313233343536373839404142434445&lt;!DOCTYPE html&gt;&lt;html lang="en"&gt;&lt;head&gt; &lt;meta charset="UTF-8"&gt; &lt;title&gt;Document&lt;/title&gt; &lt;style&gt; * &#123; box-sizing: border-box; &#125; .product &#123; width: 100%; position: relative; /*定位的话给父元素设置padding 让内容往左边挤也可以*/ padding-right: 200px; &#125; /*设置margin-right让左边的盒子距离右边有间距 如果没有设置宽度 自动把左边盒子宽度变小*/ .left &#123; height: 200px; background-color: #ccc; &#125; .right &#123; width: 200px; height: 200px; background-color: yellowgreen; position: absolute; right: 0; top: 0 ; &#125; &lt;/style&gt;&lt;/head&gt;&lt;body&gt; &lt;div class="product"&gt; &lt;div class="left"&gt;&lt;/div&gt; &lt;div class="right"&gt;&lt;/div&gt; &lt;/div&gt;&lt;/body&gt;&lt;/html&gt; 3.flex伸缩布局方式1234567891011121314151617181920212223242526272829303132333435363738394041&lt;!DOCTYPE html&gt;&lt;html lang="en"&gt;&lt;head&gt; &lt;meta charset="UTF-8"&gt; &lt;title&gt;Document&lt;/title&gt; &lt;style&gt; * &#123; box-sizing: border-box; &#125; .product &#123; width: 100%; /*父元素设置伸缩布局*/ display: flex; &#125; .left &#123; /*左边flex1自适应*/ flex:1; height: 200px; background-color: #ccc; &#125; .right &#123; /*右边固定宽度*/ width: 200px; height: 200px; background-color: yellowgreen; &#125; &lt;/style&gt;&lt;/head&gt;&lt;body&gt; &lt;div class="product"&gt; &lt;div class="left"&gt;&lt;/div&gt; &lt;div class="right"&gt;&lt;/div&gt; &lt;/div&gt;&lt;/body&gt;&lt;/html&gt; 4.overflowhidden的高级用法方式123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293&lt;--!1.overflowhidden的高级用法方式 --&gt;&lt;!DOCTYPE html&gt;&lt;html lang="en"&gt;&lt;head&gt; &lt;meta charset="UTF-8"&gt; &lt;title&gt;Document&lt;/title&gt; &lt;style&gt; .box &#123; width: 600px; border: 2px solid #000; &#125; .box .left &#123; float:left; width: 100px; height: 100px; background-color: red; &#125; .right &#123; height: 200px; background-color: #0f0; /*overflow: hidden;*/ &#125; input::before&#123; content: '伪元素'; &#125; img::before&#123; content: '伪元素'; &#125; &lt;/style&gt;&lt;/head&gt;&lt;body&gt; &lt;div class="box"&gt; &lt;img src="./public/m/images/1.png" alt=""&gt; &lt;div class="left"&gt; &lt;input type="text"&gt; &lt;/div&gt; &lt;div class="right"&gt;&lt;!DOCTYPE html&gt;&lt;html lang="en"&gt;&lt;head&gt; &lt;meta charset="UTF-8"&gt; &lt;title&gt;Document&lt;/title&gt; &lt;style&gt; .box &#123; width: 600px; border: 2px solid #000; &#125; .box .left &#123; float:left; width: 100px; height: 100px; background-color: red; &#125; .right &#123; height: 200px; background-color: #0f0; /*overflow: hidden;*/ &#125; input::before&#123; content: '伪元素'; &#125; img::before&#123; content: '伪元素'; &#125; &lt;/style&gt;&lt;/head&gt;&lt;body&gt; &lt;div class="box"&gt; &lt;img src="./public/m/images/1.png" alt=""&gt; &lt;div class="left"&gt; &lt;input type="text"&gt; &lt;/div&gt; &lt;div class="right"&gt; 文字文字文字文字文字文字文字文字文字文字文字文字文字文字文字文字文字文字文字文字文字文字文字文字文字文字文字文字文字文字文字文字文字文字文字文字文字文字文字文字文字文字文字文字文字文字文字文字文字文字文字文字文字文字文字文字文字文字文字文字文字文字文字文字文字文字文字文字文字文字文字文字文字文字文字文字文字文字文字文字文字文字文字文字文字文字文字文字文字文字文字文字文字文字文字文字文字文字文字文字文字文字文字文字文字文字文字文字文字文字文字文字文字文字文字文字文字文字文字文字文字文字文字文字文字文字文字文字文字文字文字文字文字文字文字文字文字文字文字文字文字文字文字文字文字文字文字文字文字文字文字文字文字文字文字文字文字文字文字文字文字文字文字文字文字文字文字文字文字文字文字文字文字文字文字文字文字文字文字文字文字文字文字文字文字文字文字 &lt;/div&gt; &lt;/div&gt;&lt;/body&gt;&lt;/html&gt; &lt;/div&gt; &lt;/div&gt;&lt;/body&gt;&lt;/html&gt;]]></content>
      <categories>
        <category>移动web</category>
      </categories>
      <tags>
        <tag>移动web</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[01-html5新增了这些布局的标签]]></title>
    <url>%2Fposts%2F8b07fa81%2F</url>
    <content type="text"><![CDATA[移动web开发介绍 PC端的web在PC端电脑访问的web(网页网站) 页面一般固定宽度的，居中在网页显示 还有各种浏览器需要兼容 移动端的web在手机端访问的web 页面一般是全屏的，全屏在手机里面显示 在手机端的浏览器内核都是统一webkit 很少考虑浏览器兼容性问题 移动web的概念和发展历史 什么是移动web 就是运行在手机浏览器里面的web应用程序(网页) 虽然和网页是一样的 ， 但是现代的web特别是移动web已经不再是简简单单的网页了，而是实现了和APP一样的功能 所以现代的网页已经可以称之为应用程序了 移动端的浏览器 移动端的浏览器和PC端有些不一样，都是在手机上安装的浏览器，常见有UC、 QQ 、百度、 safari 等 移动端浏览器都有一个共同的特点，就是都是webkit内核的浏览器，所以在浏览器的兼容性上相对PC端比较统一 常见的移动web应用程序 淘宝触屏版、京东手机版、苏宁手机版、携程手机版、小米手机版等，这些都是在手机端浏览器运行的应用程序 如何区分什么是网页，什么是应用程序 网页就是只能做一些基本的显示，例如新闻 、官网宣传页等等 应用程序就是能实现某个具体的功能，例如酷狗音乐能听歌，爱奇艺视频能看视频，淘宝能购物qq能聊天，这些东西都不仅仅只是显示一些信息了而是能够改善我们的上网应用体验的就是应用程序 移动web应用程序都有什么特点 通常移动web应用程序都是以m开头的站点 例如m.taobao.com m.jd.com 通常移动web应用都是只运行在手机端，设计功能也是符合手机的操作 页面都相对比较简洁 使用起来比较方便 移动web的发展历史 从2014年HTML5正式定稿后移动web就迎来了飞速的发展，因为使用HTML5技术可以更方便，更快捷的开发现代web应用程序 移动端的手机浏览器都是比较新，HTML5在移动端的浏览器支持情况都比较好，所以HTML5主要应用就是在移动端（移动web） 直到2015 - 2016 - 2017 - 至今 移动web已经发展了很多年，各方面的技术都比较成熟稳定，网上的教程也比较完整成熟 所以现在的web已经到全民移动web的时代 移动web的开发方式 如何去开发移动web 常见的移动web的开发方式 响应式开发方式 开发一个页面，同时运行在PC端和移动端，针对不同的屏幕大小，来自动适应屏幕，展示对应端的页面的布局 原生的移动web开发方式 针对每一个端，PC端和移动端都分别开发1个页面，PC端加载PC端的页面，移动端加载移动端的页面 两种方式的对比和应用场景 响应式开发 一个页面适配多个终端，开发效率高 、维护效率高，但是由于代码都在一个页面会造成冗余 所以运行的效率低 应用在一些新建的网站 ，同时把2个端都做完，快速上线 ，对页面加载性能要求不高，所以响应式开发常用于，新闻网站、官网、活动页面等 原生移动web开发 要针对每个端都写1个页面，开发维护效率低，但是由于针对性强，只有对应端需要的代码，代码冗余少 运行效率高 所以原生移动web开发应用在一些老网站，PC已经上线 ，单独开发移动端，需要写2套代码，对页面加载性能要求高也采用原生开发方式，比如 电商、直播、视频、聊天的应用等 掌握响应式开发的方式（重点） 理解响应式开发的原理 获取屏幕的宽度去判断当前是属于什么大小的屏幕 屏幕通常有4种（单位为像素px） 大屏幕 屏幕宽度大于1200 中屏幕 屏幕宽度大于992 小于等于1200 小屏幕 屏幕宽度大于768 小于等于992 超小屏幕 屏幕宽度小于等于768 根据不同的屏幕来改变页面的布局方式 如何判断和改变布局方式 使用JS判断 和 设置行内样式的方式 使用CSS3新增的属性媒体查询来判断屏幕宽度，然后在媒体查询里面写需要改变的样式 媒体查询 媒体查询: 根据媒体来作为条件 来判断 如果符合这个条件 生效对应的样式 如果不符合 就不生效这个样式 1234//单个条件@media(条件)&#123; //条件成立执行的代码&#125; 条件通常有3种写法 width:1200px; 表示屏幕宽度等于1200 条件成立 min-width:1200px; 表示屏幕宽度大于等于1200 条件成立 max-width:1200px 表示屏幕宽度小于等于1200 条成立 1234 //如果有多个条件可以使用 and 相连 @media(条件) and (条件2)&#123;//条件成立执行的代码 &#125; 条件成立执行的代码就是普通的CSS代码，里面写选择{属性:值} 的方式，当条件成立就会执行这个CSS样式 媒体查询条件的判断顺序 如果使用min-width作为条件判断的时候，由于是大于等于的判断假设屏幕1400，同时写了3个条件，min-widht:768px min-width:992px min-width:1200px 那么1400 大于 1200 也大于992 也大于768 就意味着3个条件都能成立，但是一般我们会取最大的屏幕的样式，也就是在1200时所以写判断的时候要从小到大的方式写 让大屏幕生效的样式把小屏幕的样式覆盖 （CSS层叠性，向下覆盖） 写媒体查询条件的时候 如果 使用min-width 大于等于做判断应该把条件从小到大写 让大屏幕样式把小屏幕样式覆盖 向下覆盖 由于CSS有层叠性 如果都写max-width 小于等于生效的判断 小屏幕的判断 和 大屏幕的判断同时生效 希望小屏幕生效 例如 750宽度 max-width:1200; max-width:992; max-width:768; 大家都成立希望生效 768最小那个 需要把最小768判断写在最后面把前面2个覆盖 写媒体查询条件的时候 如果 使用max-width 小于等于做判断,应该把条件从大到小写 让小屏幕样式把大屏幕样式覆盖 向上覆盖 响应式的开发框架 框架帮你封装好了响应式的功能，你只需要使用框架提供的类名既可实现响应式布局 常见的响应式开发框架 bootstrap: 目前前端最流行的框架，应用非常广泛，移动、PC都可以使用，代码风格很好，可以快速构建网页布局 （重点） AmazeUI: 妹子UI 中国首个响应式开发框架 layUI: 响应式模块的UI框架 MUI ： 中国人开发的针对移动端的UI，也有响应式功能（只适配手机和ipad） framework7：构造原生APP的框架UI框架]]></content>
      <categories>
        <category>移动web</category>
      </categories>
      <tags>
        <tag>移动web</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[39-滑块元素和视频音量]]></title>
    <url>%2Fposts%2F98c8260c%2F</url>
    <content type="text"><![CDATA[滑块元素和视频音量 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263&lt;!DOCTYPE html&gt;&lt;html lang="en"&gt;&lt;head&gt; &lt;meta charset="UTF-8"&gt; &lt;meta name="viewport" content="width=device-width, initial-scale=1.0"&gt; &lt;meta http-equiv="X-UA-Compatible" content="ie=edge"&gt; &lt;title&gt;Document&lt;/title&gt;&lt;/head&gt;&lt;body&gt; &lt;!-- 要修改滑块的值就用value属性 默认最大值是100，最小值是0 max修改最大值 min修改最小值 --&gt; &lt;input type="range" max="10" min="0"&gt; &lt;video src="video/movie01.mp4" controls&gt;&lt;/video&gt; &lt;input type="button" value="提高音量到1" id="btn1"&gt; &lt;input type="button" value="减少音量到0" id="btn2"&gt; &lt;input type="button" value="减少音量到10" id="btn3"&gt; &lt;input type="button" value="减少音量到0.5" id="btn4"&gt;&lt;/body&gt;&lt;/html&gt;&lt;script&gt; document.querySelector('input').onchange = function () &#123; console.log(this.value); &#125;; //找到video var video = document.querySelector('video'); document.getElementById('btn1').onclick = function () &#123; //只在0-1之间 video.volume = 1; &#125; document.getElementById('btn3').onclick = function()&#123; video.volume = 10; &#125; document.getElementById('btn2').onclick = function () &#123; video.volume = 0; &#125; document.getElementById('btn4').onclick = function()&#123; video.volume = 0.5; &#125;&lt;/script&gt;]]></content>
      <categories>
        <category>HTML/CSS</category>
        <category>HTML5/CSS3</category>
      </categories>
      <tags>
        <tag>HTML</tag>
        <tag>HTML5</tag>
        <tag>CSS3</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[38-自定义视频播放器]]></title>
    <url>%2Fposts%2F8435e11c%2F</url>
    <content type="text"><![CDATA[自定义视频播放器 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188&lt;!DOCTYPE html&gt;&lt;html lang="en"&gt;&lt;head&gt; &lt;meta charset="UTF-8"&gt; &lt;meta name="viewport" content="width=device-width, initial-scale=1.0"&gt; &lt;meta http-equiv="X-UA-Compatible" content="ie=edge"&gt; &lt;title&gt;Document&lt;/title&gt; &lt;!-- 跟视频/音频有关的方法： play()：播放 pause()：暂停 --&gt; &lt;link rel="stylesheet" href="css/font-awesome.min.css"&gt; &lt;style&gt; body &#123; background-color: #000; &#125; .player &#123; width: 600px; height: 450px; border: 1px solid #fff; margin: 100px auto; display: flex; flex-direction: column; &#125; video &#123; height: 90%; &#125; .controls &#123; /* 代表用主轴剩余的大小，现在主轴是Y轴，相当于用父元素剩余的高度 */ flex: 1; /* 让它的子元素用弹性布局 */ display: flex; &#125; .controls a &#123; width: 60px; text-decoration: none; color: white; display: flex; justify-content: center; align-items: center; font-size: 23px; &#125; .controls .progress &#123; /* 用主轴剩余的大小，现在主轴是x轴，所以是给剩余的宽度 */ flex: 1; background-color: #fff; &#125; /* 显示进度条的值 */ .son &#123; background-color: gray; height: 100%; width: 0%; &#125; &lt;/style&gt;&lt;/head&gt;&lt;body&gt; &lt;div class="player"&gt; &lt;video src="video/movie01.mp4"&gt;&lt;/video&gt; &lt;div class="controls"&gt; &lt;a class="play fa fa-play" href="javascript:void(0);"&gt;&lt;/a&gt; &lt;div class="progress"&gt; &lt;div class="son"&gt;&lt;/div&gt; &lt;/div&gt; &lt;input id="range" type="range" max="10" value="10"&gt; &lt;a class="full fa fa-expand" href="javascript:void(0);"&gt;&lt;/a&gt; &lt;/div&gt; &lt;/div&gt;&lt;/body&gt;&lt;/html&gt;&lt;script&gt; //需要找到video var video = document.querySelector('video'); //找到显示进度条值的子元素div var son = document.querySelector('.son'); // 播放的点击事件 document.querySelector('.play').onclick = function () &#123; //如果有，代表当前显示的是播放图标 if (this.classList.contains('fa-play')) &#123; video.play(); //还要把图标换成暂停的图标 this.classList.remove('fa-play'); this.classList.add('fa-pause'); &#125; else &#123; //暂停 video.pause(); this.classList.remove('fa-pause'); this.classList.add('fa-play'); &#125; &#125;; //全屏的点击事件 document.querySelector('.full').onclick = function()&#123; // 这个方法是实验室中的方法，现在没有加入到标准文档里面，但是准备加在下一代的标准里面 // 但是现在还没有正式启用，只是浏览器厂商先加入这个功能来测试是否正确，等到下一个版本发布时再正式启用 // 如果是实验室中的方法，那么就需要加浏览器前缀，代表调用这个浏览器的私有方法 // video.requestFullscreen(); // video.webkitRequestFullScreen(); // video.webkitRequestFullscreen(); //火狐的 // video.mozRequestFullScreen(); //IE的 // video.msRequestFullscreen(); if(video.webkitRequestFullScreen)&#123; video.webkitRequestFullScreen(); &#125;else if(video.mozRequestFullScreen)&#123; video.mozRequestFullScreen(); &#125;else&#123; video.msRequestFullscreen(); &#125; &#125;; //视频的播放时间更新事件,相当于是视频每播放一秒都来触发一次的事件了 video.ontimeupdate = function()&#123; // console.log(video.currentTime,video.duration); //在这个事件里不断的计算进度条的值 //算法： 用视频当前播放的时间 / 视频总时长 // var per = video.currentTime / video.duration * 100 + "%"; // console.log(per); son.style.width = video.currentTime / video.duration * 100 + "%"; &#125; // 进度条的点击事件 document.querySelector('.progress').onclick = function(e)&#123; //思路：要获得点击的那个点相对于进度条左上角的x值，用这个值除以进度条的总宽度 //就得到百分比，再用这个百分比乘以视频的总时长，就得到视频应该跳到的时间 e = e || window.event; //计算相对于自身的x var x = e.clientX - this.getBoundingClientRect().left; //用计算的结果赋值给视频的播放时间 video.currentTime = x / this.offsetWidth * video.duration; &#125;; document.getElementById('range').onchange = function()&#123; video.volume = this.value / 10; &#125;&lt;/script&gt;]]></content>
      <categories>
        <category>HTML/CSS</category>
        <category>HTML5/CSS3</category>
      </categories>
      <tags>
        <tag>HTML</tag>
        <tag>HTML5</tag>
        <tag>CSS3</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[37-极其无聊的flex-basis属性]]></title>
    <url>%2Fposts%2F3f7e1d7a%2F</url>
    <content type="text"><![CDATA[极其无聊的flex-basis属性 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152&lt;!DOCTYPE html&gt;&lt;html lang="en"&gt;&lt;head&gt; &lt;meta charset="UTF-8"&gt; &lt;meta name="viewport" content="width=device-width, initial-scale=1.0"&gt; &lt;meta http-equiv="X-UA-Compatible" content="ie=edge"&gt; &lt;title&gt;Document&lt;/title&gt; &lt;!-- 本文件知识点： flex-basis:设置子元素在主轴方向的大小，可能是宽（x为主轴），也可能是高(y为主轴) 下面这三个属性都是设置在子元素上的 align-self flex: flex-basis： --&gt; &lt;style&gt; ul&#123; padding: 0; list-style: none; width: 600px; height: 600px; border: 1px solid #000; display: flex; flex-direction: column; &#125; li&#123; width: 150px; /* 设置子元素在主轴方向的大小，可能是设置的宽，也可能设置的是高 */ /* flex-basis: 180px; */ height: 150px; background-color: yellowgreen; &#125; &lt;/style&gt;&lt;/head&gt;&lt;body&gt; &lt;ul&gt; &lt;li&gt;1&lt;/li&gt; &lt;li&gt;2&lt;/li&gt; &lt;li&gt;3&lt;/li&gt; &lt;/ul&gt;&lt;/body&gt;&lt;/html&gt;]]></content>
      <categories>
        <category>HTML/CSS</category>
        <category>HTML5/CSS3</category>
      </categories>
      <tags>
        <tag>HTML</tag>
        <tag>HTML5</tag>
        <tag>CSS3</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[36-设置子元素在主轴的占比]]></title>
    <url>%2Fposts%2F5830b0f1%2F</url>
    <content type="text"><![CDATA[设置子元素在主轴的占比 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465&lt;!DOCTYPE html&gt;&lt;html lang="en"&gt;&lt;head&gt; &lt;meta charset="UTF-8"&gt; &lt;meta name="viewport" content="width=device-width, initial-scale=1.0"&gt; &lt;meta http-equiv="X-UA-Compatible" content="ie=edge"&gt; &lt;title&gt;Document&lt;/title&gt; &lt;!-- 本文件知识点： flex:设置的是在主轴方向的占比 如果大家占比的值都一样，就代表平分 flex这个属性永远计算的是主轴方向剩余的大小 --&gt; &lt;style&gt; ul&#123; padding: 0; list-style: none; width: 600px; height: 600px; border: 1px solid #000; display: flex; /* flex-direction: column; */ &#125; li&#123; /* width: 150px; */ /* flex:99; */ height: 150px; background-color: yellowgreen; &#125; li:nth-child(1)&#123; /* 在主轴方向占2份 */ /* flex:2; */ width:100px; &#125; li:nth-child(2)&#123; /* 在主轴方向占4份 */ flex:4; &#125; li:nth-child(3)&#123; /* 在主轴方向占4份 */ flex:4; &#125; &lt;/style&gt;&lt;/head&gt;&lt;body&gt; &lt;ul&gt; &lt;li&gt;1&lt;/li&gt; &lt;li&gt;2&lt;/li&gt; &lt;li&gt;3&lt;/li&gt; &lt;/ul&gt;&lt;/body&gt;&lt;/html&gt;]]></content>
      <categories>
        <category>HTML/CSS</category>
        <category>HTML5/CSS3</category>
      </categories>
      <tags>
        <tag>HTML</tag>
        <tag>HTML5</tag>
        <tag>CSS3</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[35-单独设置某个子元素在副轴排列]]></title>
    <url>%2Fposts%2F20fa5a2b%2F</url>
    <content type="text"><![CDATA[单独设置某个子元素在副轴排列 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354&lt;!DOCTYPE html&gt;&lt;html lang="en"&gt;&lt;head&gt; &lt;meta charset="UTF-8"&gt; &lt;meta name="viewport" content="width=device-width, initial-scale=1.0"&gt; &lt;meta http-equiv="X-UA-Compatible" content="ie=edge"&gt; &lt;title&gt;Document&lt;/title&gt; &lt;!-- 本文件知识点： align-self：单独设置某个子元素在副轴的排列 它的取值跟align-items是一样的 也就是说也有 stretch flex-start flex-end center --&gt; &lt;style&gt; ul&#123; padding: 0; list-style: none; width: 600px; height: 600px; border: 1px solid #000; display: flex; /* 统一设置所有子元素在副轴排列方式 */ /* align-items: center; */ &#125; li&#123; width: 150px; height: 150px; background-color: yellowgreen; &#125; li:nth-child(2)&#123; /* 单独设置自己在副轴的排列 */ /* 这个属性的取值跟align-items是一样的，区别在于，align-self仅仅只是设置某一个子元素 */ align-self: center; &#125; &lt;/style&gt;&lt;/head&gt;&lt;body&gt; &lt;ul&gt; &lt;li&gt;1&lt;/li&gt; &lt;li&gt;2&lt;/li&gt; &lt;li&gt;3&lt;/li&gt; &lt;/ul&gt;&lt;/body&gt;&lt;/html&gt;]]></content>
      <categories>
        <category>HTML/CSS</category>
        <category>HTML5/CSS3</category>
      </categories>
      <tags>
        <tag>HTML</tag>
        <tag>HTML5</tag>
        <tag>CSS3</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[34-弹性布局中的换行]]></title>
    <url>%2Fposts%2F6a30895e%2F</url>
    <content type="text"><![CDATA[弹性布局中的换行 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950&lt;!DOCTYPE html&gt;&lt;html lang="en"&gt;&lt;head&gt; &lt;meta charset="UTF-8"&gt; &lt;meta name="viewport" content="width=device-width, initial-scale=1.0"&gt; &lt;meta http-equiv="X-UA-Compatible" content="ie=edge"&gt; &lt;title&gt;Document&lt;/title&gt; &lt;style&gt; ul &#123; padding: 0; list-style: none; width: 600px; height: 600px; border: 1px solid #000; display: flex; /* 允许换行 开启换行后，弹性布局会计算出你一共有多少行 例如计算出有2行，那么它会把父元素的大小平分成2块区域 */ flex-wrap: wrap; /* 设置在副轴方向的排列 设置的是在自己区域的副轴排列 */ /*align-items: center;*/ &#125; li &#123; width: 250px; height: 150px; background-color: yellowgreen; &#125; &lt;/style&gt;&lt;/head&gt;&lt;body&gt; &lt;ul&gt; &lt;li&gt;1&lt;/li&gt; &lt;li&gt;2&lt;/li&gt; &lt;li&gt;3&lt;/li&gt; &lt;/ul&gt;&lt;/body&gt;&lt;/html&gt;]]></content>
      <categories>
        <category>HTML/CSS</category>
        <category>HTML5/CSS3</category>
      </categories>
      <tags>
        <tag>HTML</tag>
        <tag>HTML5</tag>
        <tag>CSS3</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[33-弹性布局统一设置子元素在副轴排列]]></title>
    <url>%2Fposts%2F4db84cfc%2F</url>
    <content type="text"><![CDATA[弹性布局统一设置子元素在副轴排列 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465&lt;!DOCTYPE html&gt;&lt;html lang="en"&gt;&lt;head&gt; &lt;meta charset="UTF-8"&gt; &lt;meta name="viewport" content="width=device-width, initial-scale=1.0"&gt; &lt;meta http-equiv="X-UA-Compatible" content="ie=edge"&gt; &lt;title&gt;Document&lt;/title&gt; &lt;!-- 弹性布局：相当于可以把子元素转为行内块元素 默认情况下：如果不给子元素副轴方向上的大小，它会占满父盒子的副轴方向 它的根本原因是：没有设置align-items，它的默认值是stretch --&gt; &lt;style&gt; ul&#123; padding: 0; list-style: none; width: 600px; height: 600px; border: 1px solid #000; /* 给谁加弹性布局，就是代表让子元素用弹性布局 */ display: flex; /* 设置在主轴居中 */ justify-content: center; /* 修改主轴方向 */ flex-direction: column; /* 设置在副轴的排列方式 主要用到的是三个： stretch：默认值，也是在副轴起点对齐，但是如果没有设置副轴大小，它会拉伸元素在副轴的方向铺满 flex-start：仅仅就是在副轴起点对齐，如果没有设置副轴大小，就用内容的大小 所以：如果有设置副轴上的大小，上面两个值是一样的 flex-end：在副轴终点对齐 center：在副轴居中 */ align-items: center; &#125; li&#123; width: 150px; height: 150px; background-color: yellowgreen; &#125; /* span&#123; width: 100px; height: 100px; background-color: #f00; &#125; */ &lt;/style&gt;&lt;/head&gt;&lt;body&gt; &lt;ul&gt; &lt;!-- &lt;span&gt;我是span&lt;/span&gt; --&gt; &lt;li&gt;1&lt;/li&gt; &lt;li&gt;2&lt;/li&gt; &lt;li&gt;3&lt;/li&gt; &lt;/ul&gt;&lt;/body&gt;&lt;/html&gt;]]></content>
      <categories>
        <category>HTML/CSS</category>
        <category>HTML5/CSS3</category>
      </categories>
      <tags>
        <tag>HTML</tag>
        <tag>HTML5</tag>
        <tag>CSS3</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[32-弹性布局基本使用]]></title>
    <url>%2Fposts%2F522c85ef%2F</url>
    <content type="text"><![CDATA[弹性布局基本使用 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273&lt;!DOCTYPE html&gt;&lt;html lang="en"&gt;&lt;head&gt; &lt;meta charset="UTF-8"&gt; &lt;meta name="viewport" content="width=device-width, initial-scale=1.0"&gt; &lt;meta http-equiv="X-UA-Compatible" content="ie=edge"&gt; &lt;title&gt;Document&lt;/title&gt; &lt;!-- 弹性布局：会让子元素在主轴方向依次排列 justify-content:设置元素在主轴方向的排列方式 flex-start:在主轴起点对齐 flex-end：在主轴终点对齐 center：在主轴居中 space-around：元素和元素之间有间距，两边也有间距 space-between：元素和元素之间有间距，两边没有间距 flex-direction：设置主轴为哪个轴 row：默认值，代表x轴为主轴 column：代表y为主轴 row-reverse：还是以x为主轴，起点和终点会调换 一般不会用 column-reverse：还是以y为主轴，起点和终点会调换 一般不会用 --&gt; &lt;style&gt; ul&#123; list-style: none; padding: 0; width: 600px; height: 550px; border: 1px solid #000; /* 让子元素用弹性布局 */ display: flex; /* 设置子元素在主轴方向上的排列方式（对齐方式） flex-start：默认值，在主轴起点对齐 center：在主轴居中 flex-end：在主轴终点对齐 space-around:元素和元素之间有间距，并且两边也有间距 space-between：元素和元素之间有间距，但是两边没有间距 */ justify-content: flex-start; /* 修改主轴方向 row:默认值，就是以x轴为主轴 column：用y轴为主轴 row-reverse：还是以x为主轴，起点和终点会调换 一般不会用 column-reverse：还是以y为主轴，起点和终点会调换 一般不会用 */ flex-direction: column; &#125; li&#123; width: 150px; height: 150px; background: yellowgreen; &#125; &lt;/style&gt;&lt;/head&gt;&lt;body&gt; &lt;ul&gt; &lt;li&gt;1&lt;/li&gt; &lt;li&gt;2&lt;/li&gt; &lt;li&gt;3&lt;/li&gt; &lt;/ul&gt;&lt;/body&gt;&lt;/html&gt;]]></content>
      <categories>
        <category>HTML/CSS</category>
        <category>HTML5/CSS3</category>
      </categories>
      <tags>
        <tag>HTML</tag>
        <tag>HTML5</tag>
        <tag>CSS3</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[31-弹性布局介绍]]></title>
    <url>%2Fposts%2F5299ef1f%2F</url>
    <content type="text"><![CDATA[弹性布局介绍 12345678910111213141516171819202122232425262728293031323334353637383940414243444546&lt;!DOCTYPE html&gt;&lt;html lang="en"&gt;&lt;head&gt; &lt;meta charset="UTF-8"&gt; &lt;meta name="viewport" content="width=device-width, initial-scale=1.0"&gt; &lt;meta http-equiv="X-UA-Compatible" content="ie=edge"&gt; &lt;title&gt;Document&lt;/title&gt; &lt;!-- 弹性布局：也叫伸缩布局 体现在“弹性两个字” 特点：如果用了弹性布局，子元素绝对不会超出父元素的主轴方向，如果你设置的值超出了，会自动缩小子元素 主要可以用在移动端，因为移动端的屏幕有大有小 --&gt; &lt;style&gt; ul&#123; list-style: none; padding: 0; width: 600px; height: 550px; border: 1px solid #000; /* 让子元素用弹性布局 */ display: flex; justify-content: center; &#125; li&#123; width: 250px; height: 150px; background: yellowgreen; &#125; &lt;/style&gt;&lt;/head&gt;&lt;body&gt; &lt;ul&gt; &lt;li&gt;1&lt;/li&gt; &lt;li&gt;2&lt;/li&gt; &lt;li&gt;3&lt;/li&gt; &lt;/ul&gt;&lt;/body&gt;&lt;/html&gt;]]></content>
      <categories>
        <category>HTML/CSS</category>
        <category>HTML5/CSS3</category>
      </categories>
      <tags>
        <tag>HTML</tag>
        <tag>HTML5</tag>
        <tag>CSS3</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[30-animation详解]]></title>
    <url>%2Fposts%2F7f95cd09%2F</url>
    <content type="text"><![CDATA[animation详解 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182&lt;!DOCTYPE html&gt;&lt;html lang="en"&gt;&lt;head&gt; &lt;meta charset="UTF-8"&gt; &lt;meta name="viewport" content="width=device-width, initial-scale=1.0"&gt; &lt;meta http-equiv="X-UA-Compatible" content="ie=edge"&gt; &lt;title&gt;Document&lt;/title&gt; &lt;!-- alternate:代表让元素复原时也有动画， 它占用一次动画效果 forwords：停在动画最终效果上 running:默认值，播放动画 paused：暂停动画 --&gt; &lt;style&gt; .box&#123; width: 100px; height: 100px; background-color: #f00; /* 参数1：剧本的名字（动画名） 参数2：动画时长 参数3：延迟时间 参数4：运动曲线 linear匀速 steps()分步骤 参数5：动画次数，如果为infinite代表无限次 参数6：默认动画结束后会复原，forwards代表停留在动画最终效果上 参数7：如果动画次数有N次的时候，在动画完了进行下一次动画之前会闪现回原来的样子没有动画效果 加一个alternate可以让复原时也有动画效果，但是它会占用动画次数 参数8：代表动画播放状态，默认是running（播放动画） 以上参数不用特意去记顺序，因为它们随便写顺序都可以，但是先写的时间一定是动画时长，后写的是延迟时间 因为它们没有顺序，所以以后需要什么效果，想到什么就写什么 例如：我想无限，我就写一个infinite 我想复原时也有动画，就写一个alternat reverse：代表反转（先闪现到动画最终样子，然后用动画效果复原到自己本身的值） alternate-reverse：还是反转，只是如果有多次动画，返回时也会有动画效果 normal：默认值，就是动画该怎样就怎样，相当于你没写参数 我想最终停在动画最终的效果，就写一个forwards */ animation: bigger 1s 0.5s linear 2 forwards alternate; /* animation-name: 动画名 */ /* animation-duration: 动画时长 */ /* animation-delay: 延迟时间 */ /* animation-timing-function: 运动曲线 */ /* animation-iteration-count: 动画次数 */ /* animation-fill-mode: 填充模式，只要记住，代表动画要不要以最终动画效果显示 */ /* animation-direction: 设置复原时要不要有动画效果 */ /* animation-play-state: 播放状态 */ /* animation: alternate forwards 2s bigger 5 .5s; */ /*animation:bigger 2s;*/ &#125; @keyframes bigger&#123; /* 我希望让元素以什么样子开始动画，就在from里写,如果不写就是以元素自身的样式开始 */ from&#123; /* width: 600px; height: 600px; background-color: #0f0; */ &#125; to&#123; width: 300px; height: 300px; &#125; &#125; &lt;/style&gt;&lt;/head&gt;&lt;body&gt; &lt;div class="box"&gt;&lt;/div&gt;&lt;/body&gt;&lt;/html&gt;]]></content>
      <categories>
        <category>HTML/CSS</category>
        <category>HTML5/CSS3</category>
      </categories>
      <tags>
        <tag>HTML</tag>
        <tag>HTML5</tag>
        <tag>CSS3</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[29-3D盒子]]></title>
    <url>%2Fposts%2Fb98edd7c%2F</url>
    <content type="text"><![CDATA[3D盒子 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107&lt;!DOCTYPE html&gt;&lt;html lang="en"&gt;&lt;head&gt; &lt;meta charset="UTF-8"&gt; &lt;meta name="viewport" content="width=device-width, initial-scale=1.0"&gt; &lt;meta http-equiv="X-UA-Compatible" content="ie=edge"&gt; &lt;title&gt;Document&lt;/title&gt; &lt;!-- 视距要加在不会动的那个父元素上要好一点 最简单的办法：一级一级往上加，直到可以就行了 --&gt; &lt;style&gt; body&#123; perspective: 1100px; &#125; ul &#123; padding: 0; list-style: none; width: 200px; height: 200px; border: 1px solid #000; margin: 220px auto; position: relative; /* 浏览器默认没有开启元素的3D显示，要开启3D */ transform-style: preserve-3d; transition: all 50s; &#125; li &#123; width: 100%; height: 100%; position: absolute; background: url(img/girl1.jpg) no-repeat left top/cover; &#125; li:nth-child(1) &#123; left: -200px; background-color: red; transform-origin: right; transform: rotateY(90deg); &#125; li:nth-child(2) &#123; top: -200px; background-color: #0f0; transform-origin: bottom; transform: rotateX(-90deg); &#125; li:nth-child(3) &#123; right: -200px; background-color: #00f; transform-origin: left; transform: rotateY(-90deg); &#125; li:nth-child(4) &#123; bottom: -200px; background-color: hotpink; transform-origin: top; transform: rotateX(90deg); &#125; li:nth-child(5) &#123; background-color: black; &#125; li:nth-child(6) &#123; background-color: purple; transform: translateZ(200px); &#125; ul:hover&#123; transform: rotateX(3600deg) rotateY(3600deg); &#125; &lt;/style&gt;&lt;/head&gt;&lt;body&gt; &lt;ul&gt; &lt;li&gt;&lt;/li&gt; &lt;li&gt;&lt;/li&gt; &lt;li&gt;&lt;/li&gt; &lt;li&gt;&lt;/li&gt; &lt;li&gt;&lt;/li&gt; &lt;li&gt;&lt;/li&gt; &lt;/ul&gt;&lt;/body&gt;&lt;/html&gt;]]></content>
      <categories>
        <category>HTML/CSS</category>
        <category>HTML5/CSS3</category>
      </categories>
      <tags>
        <tag>HTML</tag>
        <tag>HTML5</tag>
        <tag>CSS3</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[28-视距加在自身和加在父元素的区别]]></title>
    <url>%2Fposts%2F1cab4822%2F</url>
    <content type="text"><![CDATA[视距加在自身和加在父元素的区别 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576&lt;!DOCTYPE html&gt;&lt;html lang="en"&gt;&lt;head&gt; &lt;meta charset="UTF-8"&gt; &lt;meta name="viewport" content="width=device-width, initial-scale=1.0"&gt; &lt;meta http-equiv="X-UA-Compatible" content="ie=edge"&gt; &lt;title&gt;Document&lt;/title&gt; &lt;!-- 总结：视距要加在父元素身上会更像真实看到的场景 --&gt; &lt;style&gt; ul&#123; width: 600px; height: 200px; list-style: none; padding: 0; margin: 50px auto; border: 1px solid #000; &#125; li&#123; width: 180px; height: 180px; background-color: yellowgreen; margin-left: 15px; margin-top: 10px; float: left; transition: all 1s; &#125; /* 先给第一个ul里所有的li加默认视距 视距加在子元素上 , 哪么就相当于每个子元素都有一个前面都有一双眼睛 */ ul:nth-child(1) li&#123; transform: perspective(600px); &#125; /* 当第一个ul在hover的时候，改它里面的li */ ul:nth-child(1):hover li&#123; transform: perspective(600px) rotateY(90deg); &#125; /* 第二个ul是把视距加在父元素的Ul上 哪么就相当于,一双眼睛在ul中,看到周围物体就是通过余光看的 */ ul:nth-child(2)&#123; /* 如果视距是加在父元素身上，不能用transform加，而应该直接用perspetive加视距 */ perspective: 600px; &#125; ul:nth-child(2):hover li&#123; transform: rotateY(90deg); &#125; &lt;/style&gt;&lt;/head&gt;&lt;body&gt; &lt;!-- 每个li都加一个视距 --&gt; &lt;ul&gt; &lt;li&gt;&lt;/li&gt; &lt;li&gt;&lt;/li&gt; &lt;li&gt;&lt;/li&gt; &lt;/ul&gt; &lt;!-- 把视距加在这个ul身上 --&gt; &lt;ul&gt; &lt;li&gt;&lt;/li&gt; &lt;li&gt;&lt;/li&gt; &lt;li&gt;&lt;/li&gt; &lt;/ul&gt;&lt;/body&gt;&lt;/html&gt;]]></content>
      <categories>
        <category>HTML/CSS</category>
        <category>HTML5/CSS3</category>
      </categories>
      <tags>
        <tag>HTML</tag>
        <tag>HTML5</tag>
        <tag>CSS3</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[27-视距是什么]]></title>
    <url>%2Fposts%2F89984939%2F</url>
    <content type="text"><![CDATA[视距是什么 12345678910111213141516171819202122232425262728&lt;!DOCTYPE html&gt;&lt;html lang="en"&gt;&lt;head&gt; &lt;meta charset="UTF-8"&gt; &lt;meta name="viewport" content="width=device-width, initial-scale=1.0"&gt; &lt;meta http-equiv="X-UA-Compatible" content="ie=edge"&gt; &lt;title&gt;Document&lt;/title&gt; &lt;!-- 视距：其实就是相当于模拟出一个“眼睛”到物体的距离，所以距离越大，证明你的眼睛到物体的距离就远，远的话效果就小，近的话效果就大 验证一下视距就是模拟眼睛到物体的距离 所以加一个视距就相当于加一个“眼睛”去看它 --&gt; &lt;style&gt; img&#123; display: block; margin: 100px auto; transform: perspective(1000px) translateZ(0px); &#125; &lt;/style&gt;&lt;/head&gt;&lt;body&gt; &lt;img src="img/dog2.jpg" alt=""&gt;&lt;/body&gt;&lt;/html&gt;]]></content>
      <categories>
        <category>HTML/CSS</category>
        <category>HTML5/CSS3</category>
      </categories>
      <tags>
        <tag>HTML</tag>
        <tag>HTML5</tag>
        <tag>CSS3</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[26-三维旋转]]></title>
    <url>%2Fposts%2F1117735f%2F</url>
    <content type="text"><![CDATA[三维旋转 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374&lt;!DOCTYPE html&gt;&lt;html lang="en"&gt;&lt;head&gt; &lt;meta charset="UTF-8"&gt; &lt;meta name="viewport" content="width=device-width, initial-scale=1.0"&gt; &lt;meta http-equiv="X-UA-Compatible" content="ie=edge"&gt; &lt;title&gt;Document&lt;/title&gt; &lt;!-- 不管是三维还是二维，改的都是transform 如果想要效果明显一点就要加一个视距，而且视距遵循近大远小的特点，距离越近，效果越明显，距离越远效果越不明显 X轴旋转：上下旋转，想到单杠 Y轴旋转：左右旋转，想到钢管舞 Z轴旋转：顺时针或者逆时针旋转，想到大风车 --&gt; &lt;style&gt; ul&#123; width: 600px; height: 200px; padding: 0; list-style: none; border: 1px solid #000; margin: 100px auto; &#125; li&#123; width: 180px; height: 180px; margin-left: 15px; margin-top: 10px; float: left; background-color: yellowgreen; transition: all 1s; /* 默认也加一个视距 因为如果不加,哪么在过渡的时候视距也会从0到响应的值,可能出现bug */ transform: perspective(300px); &#125; li:nth-child(1):hover&#123; /* 沿着x轴旋转 */ transform: perspective(300px) rotateX(45deg); &#125; li:nth-child(2):hover&#123; /* 沿着y轴旋转 */ transform:perspective(300px) rotateY(45deg); &#125; li:nth-child(3):hover&#123; /* 沿着z轴旋转 */ transform:perspective(600px) rotate(45deg); /* 其实rotate就是沿着z轴旋转 */ /* transform: rotateZ(45deg); */ &#125; &lt;/style&gt;&lt;/head&gt;&lt;body&gt; &lt;ul&gt; &lt;li&gt;x轴旋转&lt;/li&gt; &lt;li&gt;y轴旋转&lt;/li&gt; &lt;li&gt;z轴旋转&lt;/li&gt; &lt;/ul&gt;&lt;/body&gt;&lt;/html&gt;]]></content>
      <categories>
        <category>HTML/CSS</category>
        <category>HTML5/CSS3</category>
      </categories>
      <tags>
        <tag>HTML</tag>
        <tag>HTML5</tag>
        <tag>CSS3</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[25-三维坐标系]]></title>
    <url>%2Fposts%2F6bd1e7e7%2F</url>
    <content type="text"><![CDATA[三维坐标系 123456二维坐标：x和y轴三维坐标：x和y,z轴，三个轴 x：水平方向（左右） 平移就是左右平移 y：垂直方向（上下） 平移就是上下平移 z：前后方向（远近） 平移就是前后平移]]></content>
      <categories>
        <category>HTML/CSS</category>
        <category>HTML5/CSS3</category>
      </categories>
      <tags>
        <tag>HTML</tag>
        <tag>HTML5</tag>
        <tag>CSS3</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[24-拖拽图片到浏览器并预览]]></title>
    <url>%2Fposts%2F759712a5%2F</url>
    <content type="text"><![CDATA[拖拽图片到浏览器并预览 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960&lt;!DOCTYPE html&gt;&lt;html lang="en"&gt;&lt;head&gt; &lt;meta charset="UTF-8"&gt; &lt;meta name="viewport" content="width=device-width, initial-scale=1.0"&gt; &lt;meta http-equiv="X-UA-Compatible" content="ie=edge"&gt; &lt;title&gt;Document&lt;/title&gt; &lt;style&gt; html,body&#123; height:100%; &#125; body&#123; border:10px dashed black; &#125; &lt;/style&gt;&lt;/head&gt;&lt;body&gt; &lt;h1&gt;拖拽图片到虚线内&lt;/h1&gt;&lt;/body&gt;&lt;/html&gt;&lt;!-- 网页有一个默认的drop事件的行为，默认drop事件的行为就是打开这个文件 --&gt;&lt;script&gt; //要用drop还必须先要用dragover事件 document.body.ondragover = function(e)&#123; e = e || window.event; e.preventDefault(); &#125; //给网页加一个drop（可以给body也可以给document） document.body.ondrop = function(e)&#123; e = e || window.event; // console.log('...'); //这个事件它有没有默认的行为？？有 //什么行为？是打开你拖拽的文件（相对于要离开你的网页） e.preventDefault(); //咱们要把拖拽进来的图片给预览一下 //首先就要找到这个图片，然后转成URL //拖拽进来的图片在事件对象的dataTransfer属性的files里面，取下标0就是我们那个图片 // console.log(e.dataTransfer.files[0]); //转成临时URL var url = URL.createObjectURL(e.dataTransfer.files[0]); //给body document.body.style.background = "url(" + url +") no-repeat"; //如果要拖拽上传文件，其实就是把文件加到FormData里，再用ajax提交到服务器就可以了 // var fm = new FormData(); // fm.append('icon',e.dataTransfer.files[0]); &#125;&lt;/script&gt;]]></content>
      <categories>
        <category>HTML/CSS</category>
        <category>HTML5/CSS3</category>
      </categories>
      <tags>
        <tag>HTML</tag>
        <tag>HTML5</tag>
        <tag>CSS3</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[23-跟目标元素（容器元素）有关的拖拽]]></title>
    <url>%2Fposts%2F55ec7be6%2F</url>
    <content type="text"><![CDATA[跟目标元素（容器元素）有关的拖拽 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990&lt;!DOCTYPE html&gt;&lt;html lang="en"&gt;&lt;head&gt; &lt;meta charset="UTF-8"&gt; &lt;meta name="viewport" content="width=device-width, initial-scale=1.0"&gt; &lt;meta http-equiv="X-UA-Compatible" content="ie=edge"&gt; &lt;title&gt;Document&lt;/title&gt; &lt;!-- 跟目标元素有关的事件： ondragenter：代表有元素拖进来触发，只触发一次，进来一次触发一次 ondragleave：代表有元素从我这离开触发，只触发一次，出去一次触发一次 ondragover： 代表有元素在我的范围内不断触发（一般用这个事件只是为了配合ondrop使用，在里面阻止事件默认行为让元素允许能被拖进来） ondrop：有元素拖拽到我的范围内松手触发的事件。但是这个事件要想能被触发，必须先写ondragover事件，并且再over事件里阻止事件默认行为 --&gt; &lt;style&gt; .box&#123; width: 100px; height: 100px; background-color: #f00; &#125; .container&#123; width: 400px; height: 500px; border: 1px solid #000; position: absolute; right:20px; top:10px; &#125; &lt;/style&gt;&lt;/head&gt;&lt;body&gt; &lt;div class="box" draggable="true"&gt;&lt;/div&gt; &lt;div class="container"&gt;&lt;/div&gt;&lt;/body&gt;&lt;/html&gt;&lt;script&gt; //找到两个div var box = document.querySelector('.box'); var container = document.querySelector('.container'); //给红div加一个拖拽结束事件 // box.ondragend = function()&#123; // //把box加到container里面 // container.appendChild(box); // &#125; //当有元素拖拽到我的范围内触发的事件 拖拽进来触发的事件 container.ondragenter = function()&#123; console.log('有元素进来了'); // container.appendChild(box); &#125; //当有元素拖拽离开时触发 container.ondragleave = function()&#123; console.log('有元素出去了'); &#125; container.ondragover = function(e)&#123; //只要有元素拖拽到我的范围内而且还没松手时不断触发的事件 console.log('over'); e.preventDefault(); &#125; //这个事件是当有元素拖进来，并且在我的范围内松开才触发的事件 //这个事件有点特殊：如果想它能被触发，还要先写另外一个事件叫ondragover事件，并且在dragover这个事件里阻止事件的默认行为 //原因：是因为容器（目标元素）默认都不允许别的元素拖拽进来，所以你要在范围内里先阻止这个默认行为，才能触发我们这个drop事件 container.ondrop = function()&#123; // console.log('....'); container.appendChild(box); &#125;&lt;/script&gt;]]></content>
      <categories>
        <category>HTML/CSS</category>
        <category>HTML5/CSS3</category>
      </categories>
      <tags>
        <tag>HTML</tag>
        <tag>HTML5</tag>
        <tag>CSS3</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[22-计算相对于自身的x和y]]></title>
    <url>%2Fposts%2F29d3571a%2F</url>
    <content type="text"><![CDATA[计算相对于自身的x和y 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566&lt;!DOCTYPE html&gt;&lt;html lang="en"&gt;&lt;head&gt; &lt;meta charset="UTF-8"&gt; &lt;meta name="viewport" content="width=device-width, initial-scale=1.0"&gt; &lt;meta http-equiv="X-UA-Compatible" content="ie=edge"&gt; &lt;title&gt;Document&lt;/title&gt; &lt;!-- 最新计算相对于自身左上角的x和y的算法是 先获取盒子相对于可视区域的x和y 怎么获取？ 元素.getBoundingClientRect(); 算法是： x = e.clientX - 盒子可视区域的x - 左边框宽度 y = e.clientY - 盒子可视区域的y - 上边框宽度 --&gt; &lt;style&gt; .box&#123; width: 100px; height: 100px; background-color: #f00; /* border:10px solid black; */ position: absolute; left:0; top:1500px; background:radial-gradient() &#125; &lt;/style&gt;&lt;/head&gt;&lt;body&gt; &lt;div class="father"&gt; &lt;div class="box" &gt;&lt;/div&gt; &lt;/div&gt;&lt;/body&gt;&lt;/html&gt;&lt;script&gt; var box = document.querySelector('.box'); box.onmousedown = function(e)&#123; //offsetLeft是获取到自身左外边框到定位父级元素的内边框的位置 // var x = e.pageX - box.offsetLeft; // var y = e.pageY - box.offsetTop; // console.log(x,y); e = e || window.event; // console.log(e.screenX,e.screenY); // console.log(e.pageX,e.pageY); // // 获取可视区域的x和y // console.log(e.clientX,e.clientY); //获得自身盒子到可视区域的一个距离（但是得到的是一个对象） var rect = box.getBoundingClientRect(); console.log(rect); var x = e.clientX - rect.x - box.clientLeft; var y = e.clientY - rect.y - box.clientTop; console.log(x,y); &#125;&lt;/script&gt;]]></content>
      <categories>
        <category>HTML/CSS</category>
        <category>HTML5/CSS3</category>
      </categories>
      <tags>
        <tag>HTML</tag>
        <tag>HTML5</tag>
        <tag>CSS3</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[21-拖拽]]></title>
    <url>%2Fposts%2F5f0b1282%2F</url>
    <content type="text"><![CDATA[拖拽 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980&lt;!DOCTYPE html&gt;&lt;html lang="en"&gt;&lt;head&gt; &lt;meta charset="UTF-8"&gt; &lt;meta name="viewport" content="width=device-width, initial-scale=1.0"&gt; &lt;meta http-equiv="X-UA-Compatible" content="ie=edge"&gt; &lt;title&gt;Document&lt;/title&gt; &lt;!-- 元素不是你想拖，想拖就能拖 强行拖：给元素加一个draggable属性，值等于true就可以了 拖拽的三个事件： ondragstart 拖拽开始 ondrag 拖拽中 ondragend 拖拽结束 --&gt; &lt;style&gt; img&#123; width: 200px; height: 300px; &#125; .box&#123; width: 100px; height: 100px; background-color: #f00; position: absolute; &#125; &lt;/style&gt;&lt;/head&gt;&lt;body&gt; &lt;img src="img/girl1.jpg" alt=""&gt; &lt;div class="box" draggable="true"&gt;&lt;/div&gt;&lt;/body&gt;&lt;/html&gt;&lt;script&gt; var box = document.querySelector('.box'); //拖拽开始事件 box.ondragstart = function()&#123; console.log('start'); &#125; //拖拽中触发的事件 box.ondrag = function()&#123; console.log('拖拽ing'); &#125; //拖拽结束的事件:所有事件触发时的信息都在事件对象里面 box.ondragend = function(e)&#123; // console.log('end'); e = e || window.event; // console.log(e); box.style.left = e.pageX -x + "px"; box.style.top = e.pageY -y + "px"; &#125; var x,y; //鼠标按下事件 box.onmousedown = function(e)&#123; //不建议使用，因为不是标准语法，可能有bug 测试可用 console.log(e.offsetX,e.offsetY); x = e.offsetX; y = e.offsetY; &#125;&lt;/script&gt;]]></content>
      <categories>
        <category>HTML/CSS</category>
        <category>HTML5/CSS3</category>
      </categories>
      <tags>
        <tag>HTML</tag>
        <tag>HTML5</tag>
        <tag>CSS3</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[20-sessionStorage]]></title>
    <url>%2Fposts%2F7dd67539%2F</url>
    <content type="text"><![CDATA[sessionStorage 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354&lt;!DOCTYPE html&gt;&lt;html lang="en"&gt;&lt;head&gt; &lt;meta charset="UTF-8"&gt; &lt;meta name="viewport" content="width=device-width, initial-scale=1.0"&gt; &lt;meta http-equiv="X-UA-Compatible" content="ie=edge"&gt; &lt;title&gt;Document&lt;/title&gt; &lt;!-- sessionStorage跟session没有半毛钱关系，它们仅仅是名字很像 sessionStorage的用法跟localStorage的用法是一样一样的！ sessionStorage可以理解为是一个短命版的localStorage localStorage是只要自己不删就一直存在，而sessionStroage是关掉浏览器就没有了 有一些数据如果需要临时保存一下就可以用sessionStorage --&gt;&lt;/head&gt;&lt;body&gt; &lt;input type="button" value="保存数据" id="btn1"&gt; &lt;input type="button" value="读取数据" id="btn2"&gt; &lt;input type="button" value="删除数据" id="btn3"&gt; &lt;input type="button" value="清空数据" id="btn4"&gt;&lt;/body&gt;&lt;/html&gt;&lt;script&gt; document.getElementById('btn1').onclick = function()&#123; sessionStorage.setItem('name','jack'); sessionStorage.setItem('age',16); sessionStorage.setItem('height',160); &#125; document.getElementById('btn2').onclick = function()&#123; var res = sessionStorage.getItem('name'); console.log(res); &#125; document.getElementById('btn3').onclick = function()&#123; sessionStorage.removeItem('name'); &#125; document.getElementById('btn4').onclick = function()&#123; sessionStorage.clear(); &#125;&lt;/script&gt;]]></content>
      <categories>
        <category>HTML/CSS</category>
        <category>HTML5/CSS3</category>
      </categories>
      <tags>
        <tag>HTML</tag>
        <tag>HTML5</tag>
        <tag>CSS3</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[19-localStorage本地存储]]></title>
    <url>%2Fposts%2F5e986dca%2F</url>
    <content type="text"><![CDATA[localStorage本地存储 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126&lt;!DOCTYPE html&gt;&lt;html lang="en"&gt;&lt;head&gt; &lt;meta charset="UTF-8"&gt; &lt;meta name="viewport" content="width=device-width, initial-scale=1.0"&gt; &lt;meta http-equiv="X-UA-Compatible" content="ie=edge"&gt; &lt;title&gt;Document&lt;/title&gt; &lt;!-- localStorage：本地存储 把数据存储在浏览器端的技术 它没有有效期，也就是说只要你自己不手动删除（包括自己清浏览器数据，自己写代码删除），它就会一直存在 它不会自动发送给服务器，除非你自己写代码取出来 localStorage是按域名来存的，所以不同的网站之间不能访问到彼此的本地存储 cookie也是存在浏览器端 cookie存在有效期，有效期一到就自动删除 如果浏览器端存的是cookie，那么每次访问这个网站，都会自动把cookie发送给服务器 使用的方法 setItem() 存储一个数据，要传入key和value getItem() 读取一个数据，要传入key removerItem() 删除一个数据，要传入key clear() 清空所有数据，毛都不传 localStorage只能存储基本数据类型，如果传入的是复杂类型，它会先调用复杂类型的toString()方法，然后再存储 这样不好，所以如果要存复杂类型，那么可以先把复杂类型转成JSON字符串再来保存 取出来的时候，就可以把这个JSON字符串再转成JS的复杂类型就行了 它可以做本地缓存，有些数据就没必要存在服务器了，直接存在每个浏览器里做一个缓存了 --&gt;&lt;/head&gt;&lt;body&gt; &lt;input type="button" value="存储一个数据" id="btn1"&gt; &lt;input type="button" value="读取一个数据" id="btn2"&gt; &lt;input type="button" value="删除一个数据" id="btn3"&gt; &lt;input type="button" value="清空所有数据" id="btn4"&gt; &lt;input type="button" value="存储一个数组" id="btn5"&gt; &lt;input type="button" value="读取一个数组" id="btn6"&gt; &lt;input type="button" value="存储一个对象" id="btn7"&gt; &lt;input type="button" value="读取一个对象" id="btn8"&gt;&lt;/body&gt;&lt;/html&gt;&lt;script&gt; //当我点击这个按钮，我就存储一个数据到localStorage document.getElementById('btn1').onclick = function()&#123; //存储一个数据 //参数1：key //参数2：value localStorage.setItem('name','jack'); localStorage.setItem('age','16'); localStorage.setItem('height','1765'); localStorage.setItem('width','40kg'); &#125; //读取出数据 document.getElementById('btn2').onclick = function()&#123; //读取出的数据会当返回值返回 var res = localStorage.getItem('name'); console.log(res); &#125; //删除数据 document.getElementById('btn3').onclick = function()&#123; //根据key来删 localStorage.removeItem('name'); &#125; //清空数据 document.getElementById('btn4').onclick = function()&#123; localStorage.clear(); &#125; //存数组 document.getElementById('btn5').onclick = function()&#123; var arr = [10,20,30,40,50]; // console.log(arr.toString()); //先转成JSON再存储 var json = JSON.stringify(arr); localStorage.setItem('arr',json); &#125; //取数组 document.getElementById('btn6').onclick = function()&#123; var res = localStorage.getItem('arr'); var arr = JSON.parse(res); console.log(arr); &#125; //存对象 document.getElementById('btn7').onclick = function()&#123; var obj = &#123; name:"jack",age:16 &#125;; // console.log(obj.toString()); var json = JSON.stringify(obj); localStorage.setItem('obj',json); &#125; //取对象 document.getElementById('btn8').onclick = function()&#123; var res = localStorage.getItem('obj'); var obj = JSON.parse(res); console.log(obj); &#125;&lt;/script&gt;]]></content>
      <categories>
        <category>HTML/CSS</category>
        <category>HTML5/CSS3</category>
      </categories>
      <tags>
        <tag>HTML</tag>
        <tag>HTML5</tag>
        <tag>CSS3</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[18-地理定位]]></title>
    <url>%2Fposts%2Fee64ee8c%2F</url>
    <content type="text"><![CDATA[地理定位 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354&lt;!DOCTYPE html&gt;&lt;html lang="en"&gt;&lt;head&gt; &lt;meta charset="UTF-8"&gt; &lt;meta name="viewport" content="width=device-width, initial-scale=1.0"&gt; &lt;meta http-equiv="X-UA-Compatible" content="ie=edge"&gt; &lt;title&gt;Document&lt;/title&gt; &lt;!-- 地理定位：获取你当前在地球上的经纬度 究竟JS里如何获取经纬度？ 定位的技术： GPS定位： 首先设备上要装GPS模块，然后如果有这个模块就可以连接卫星，连接卫星，卫星就可以定位到你这个信号源所在的经纬度 它的精确度是最高的 电脑没有GPS模块 WIFI定位： 利用的是服务器的大数据。 例：有一天你在星巴克喝了咖啡，刚好又连了星巴克的wifi，再然后刚好你又打开了百度地图。那么这个时候百度地图会收集到你当前的定位位置，和这个星巴克WIFI的MAC地址，就把这些信息记录到服务器了 那么下一次，假如说李四带着笔记本来这家星巴克上网，连了wifi，虽然它的笔记本没有GPS，但是百度依然知道它在哪。 WIFI定位其实也可以用来辅助GPS定位，让定位更精确。 你只要打开wifi功能后，就会搜索附近的wifi信号，而信号有强有弱，它就根据你这些wifi信号大致推断你在哪个位置 网络基站定位： 只要你能联网，都要通过运营商的基站去上网。 因为类似于WIFI定位，服务器上存了你基站的位置，然后发现你上网的时候是通过这个基站发出的上网请求，所以就能够推断你大致在哪 因为一个片区都是用基站上网，所以它获取经纬度的误差是最大的 --&gt;&lt;/head&gt;&lt;body&gt; &lt;/body&gt;&lt;/html&gt;&lt;script&gt; // 获取经纬度 // 如果获取到经纬度了，那么会调用这个回调函数，而且会把经纬度的信息当做形参传进来 navigator.geolocation.getCurrentPosition(function(loc)&#123; console.log("纬度是：" + loc.coords.latitude + "经度是:" + loc.coords.longitude); &#125;);&lt;/script&gt;]]></content>
      <categories>
        <category>HTML/CSS</category>
        <category>HTML5/CSS3</category>
      </categories>
      <tags>
        <tag>HTML</tag>
        <tag>HTML5</tag>
        <tag>CSS3</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[17-先旋转后平移的影响]]></title>
    <url>%2Fposts%2F87ba6748%2F</url>
    <content type="text"><![CDATA[先旋转后平移的影响 1234567891011121314151617181920212223242526272829303132333435363738&lt;!DOCTYPE html&gt;&lt;html lang="en"&gt;&lt;head&gt; &lt;meta charset="UTF-8"&gt; &lt;meta name="viewport" content="width=device-width, initial-scale=1.0"&gt; &lt;meta http-equiv="X-UA-Compatible" content="ie=edge"&gt; &lt;title&gt;Document&lt;/title&gt; &lt;!-- 如果要写多个形变，用空格隔开，千万不能用逗号，用逗号不会生效 如果先旋转再平移，那么坐标轴会发生变化，你平移的位置也是旋转后的位置来平移的 建议先平移后接旋转,比较符合常规坐标 --&gt; &lt;style&gt; .box&#123; width: 200px; height: 200px; background-color: yellowgreen; margin: 100px auto; transition: all 1s; &#125; .box:hover&#123; /* 代表先旋转45度，再往右平移400像素 */ transform: rotate(45deg) translate(400px); &#125; &lt;/style&gt;&lt;/head&gt;&lt;body&gt; &lt;div class="box"&gt;&lt;/div&gt;&lt;/body&gt;&lt;/html&gt;]]></content>
      <categories>
        <category>HTML/CSS</category>
        <category>HTML5/CSS3</category>
      </categories>
      <tags>
        <tag>HTML</tag>
        <tag>HTML5</tag>
        <tag>CSS3</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[16-2D变换]]></title>
    <url>%2Fposts%2Ff5cd5b38%2F</url>
    <content type="text"><![CDATA[2D变换 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879&lt;!DOCTYPE html&gt;&lt;html lang="en"&gt;&lt;head&gt; &lt;meta charset="UTF-8"&gt; &lt;meta name="viewport" content="width=device-width, initial-scale=1.0"&gt; &lt;meta http-equiv="X-UA-Compatible" content="ie=edge"&gt; &lt;title&gt;Document&lt;/title&gt; &lt;style&gt; /* 任何变换都是改的transform属性，哪怕后天我们要学的3D变换也是改transform属性 */ ul&#123; width: 300px; height: 300px; padding: 0; list-style: none; margin: 100px auto; &#125; li&#123; width: 140px; height: 140px; background-color: yellowgreen; float: left; margin-left: 10px; margin-top:10px; transition: all 1s; &#125; li:nth-child(1):hover&#123; /* 传入角度单位是deg，给正是顺时针旋转，给负是逆时针旋转 */ transform: rotate(-45deg); &#125; li:nth-child(2):hover&#123; /* 参数1：x轴方向的平移,正往右，负往左 参数2：y轴方向的平移，正往下，负往上 如果只给一个参数，那么只平移x轴 */ transform: translate(-200px,-200px); &#125; li:nth-child(3):hover&#123; /* 传的是倍数，不用带单位 参数1：x轴方向缩放（宽度的缩放） 参数2：y轴方向缩放（高度的缩放） */ /* transform: scale(.2,2.5); */ /* 如果只给一个参数：宽高都影响 */ transform: scale(1.5); &#125; li:nth-child(4):hover&#123; /* 倾斜(平行四边形) 传入的也是角度 */ transform: skew(-15deg); &#125; &lt;/style&gt;&lt;/head&gt;&lt;body&gt; &lt;ul&gt; &lt;li&gt;旋转&lt;/li&gt; &lt;li&gt;平移&lt;/li&gt; &lt;li&gt;缩放&lt;/li&gt; &lt;li&gt;扭曲（倾斜）&lt;/li&gt; &lt;/ul&gt;&lt;/body&gt;&lt;/html&gt;]]></content>
      <categories>
        <category>HTML/CSS</category>
        <category>HTML5/CSS3</category>
      </categories>
      <tags>
        <tag>HTML</tag>
        <tag>HTML5</tag>
        <tag>CSS3</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[15-径向渐变]]></title>
    <url>%2Fposts%2Fed1f2a00%2F</url>
    <content type="text"><![CDATA[径向渐变 1234567891011121314151617181920212223242526272829303132333435&lt;!DOCTYPE html&gt;&lt;html lang="en"&gt;&lt;head&gt; &lt;meta charset="UTF-8"&gt; &lt;meta name="viewport" content="width=device-width, initial-scale=1.0"&gt; &lt;meta http-equiv="X-UA-Compatible" content="ie=edge"&gt; &lt;title&gt;Document&lt;/title&gt; &lt;style&gt; .box&#123; width: 300px; height: 300px; border: 1px solid #000; margin: 100px auto; /* 不管是线性渐变还是径向渐变，都是相当于当做背景图片来处理的 */ /* 参数1：指定圆的大小和圆心的位置 参数2：颜色1 参数3：颜色2 至少需要2个颜色，多了不限。 圆的大小外面部分是用最后一个颜色填充 第一个颜色给百分比代表什么位置结束 后面每个颜色给百分比代表什么位置开始，如果需要给后面的颜色结束位置，需要再写一个颜色，指定百分比，这个百分比就是结束的位置 */ background-image: radial-gradient(100px at center,red 30%,green 30%,green 60%,blue 60%); &#125; &lt;/style&gt;&lt;/head&gt;&lt;body&gt; &lt;div class="box"&gt;&lt;/div&gt;&lt;/body&gt;&lt;/html&gt;]]></content>
      <categories>
        <category>HTML/CSS</category>
        <category>HTML5/CSS3</category>
      </categories>
      <tags>
        <tag>HTML</tag>
        <tag>HTML5</tag>
        <tag>CSS3</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[14-线性渐变]]></title>
    <url>%2Fposts%2F3264c222%2F</url>
    <content type="text"><![CDATA[线性渐变 12345678910111213141516171819202122232425262728293031323334353637383940414243444546&lt;!DOCTYPE html&gt;&lt;html lang="en"&gt;&lt;head&gt; &lt;meta charset="UTF-8"&gt; &lt;meta name="viewport" content="width=device-width, initial-scale=1.0"&gt; &lt;meta http-equiv="X-UA-Compatible" content="ie=edge"&gt; &lt;title&gt;Document&lt;/title&gt; &lt;style&gt; .box&#123; width: 300px; height: 200px; border: 1px solid #000; /* 把渐变色不是当背景颜色，而是当背景图片，所以要给background属性 参数1：渐变的方向 to right： 从左到右 to top： 从下到上 to bottom： 从上到下 to left： 从右到左 to right top： 从左下到右上 to right bottom： 从左上到右下 to left top： 从右下到左上 to left bottom： 从右上到左下 除了可以写上面的方向，也可以传入角度,0deg是从下面开始 越大，就越顺时针旋转方向 参数2：第一个颜色 可以写一个百分比，意思是代表在哪个位置结束 参数3：第二个颜色 写可以写一个百分比，代表在哪个位置开始 如果要指定第二个颜色在哪结束，那么就需要再写一个这样的颜色,然后写一个百分比就代表它在哪个位置结束了 至少2个颜色，最多有n个颜色 只有第一个颜色写百分比是代表结束，后面每个颜色写百分比都代表开始，如果要让后面的颜色指定结束，就需要写一个相同的颜色再写一个百分比，指定它的结束位置 */ /* background-image: linear-gradient(to left bottom,red,blue,green,hotpink,orange); */ /* background-image: linear-gradient(0deg,red,blue,green,hotpink,orange); */ background-image: linear-gradient(to right,red 30%,blue 30%, blue 60%, green 60%); &#125; &lt;/style&gt;&lt;/head&gt;&lt;body&gt; &lt;div class="box"&gt;&lt;/div&gt;&lt;/body&gt;&lt;/html&gt;]]></content>
      <categories>
        <category>HTML/CSS</category>
        <category>HTML5/CSS3</category>
      </categories>
      <tags>
        <tag>HTML</tag>
        <tag>HTML5</tag>
        <tag>CSS3</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[13-background详解]]></title>
    <url>%2Fposts%2F723cb6d3%2F</url>
    <content type="text"><![CDATA[background详解 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566&lt;!DOCTYPE html&gt;&lt;html lang="en"&gt;&lt;head&gt; &lt;meta charset="UTF-8"&gt; &lt;meta name="viewport" content="width=device-width, initial-scale=1.0"&gt; &lt;meta http-equiv="X-UA-Compatible" content="ie=edge"&gt; &lt;title&gt;Document&lt;/title&gt; &lt;style&gt; .box&#123; width: 1000px; height: 1000px; border: 1px solid #000; margin: 100px auto; /* 参数1：背景图片的路径，路径包不包引号都无所谓 参数2：是否平铺，默认是repeat代表水平和垂直都平铺 no-repeat：代表不平铺，常用 repeat-x：水平方向平铺 repeat-y：垂直方向平铺 参数3：背景图片偏移位置 它需要写两个，第一个代表水平对齐，第二个代表垂直对齐 水平对齐：left,right,center 垂直对齐：top,bottom,center 如果希望水平和垂直都居中，可以只写一个center 除了写这几个单词外，还可以写偏移的像素位置 水平写负代表向左，写正代表向右 垂直写负代表向上，写正代表向下 除了写像素外，还可以写百分比,用的少 写正百分比代表向左和向上，给负代表向右和向下 写百分比跟像素的方向是相反的 参数4：指定图片的大小，它一定要写在参数3的后面，而且要加一个/ 可以给具体的像素，也可以给盒子的百分比，第一个代表宽，第二个代表高 还有特殊的两个值： cover：它一定会让图片覆盖整个盒子，图片可能会超出 contain：它一定会让盒子包含住图片，图片不会超出 图片一定不会变形，都是按比例缩放 参数5：背景颜色：注意，如果是多张背景图片，那么颜色一定要写在最后 如果多张背景图片，用逗号隔开，另外，最先写的背景图片层级最高，越后面写的层级越低 */ /* background: url("images/dog3.jpg") no-repeat 0px 0px / contain , url(images/lq.png) no-repeat 0px 0px / 100px 100px red; /* background: red; */ /* background-image: 图片路径 */ /* background-repeat: 是否平铺 */ /* background-position-x: 图片偏移位置 background-position-y: 图片偏移位置 */ /* background-size: 图片大小 */ &#125; &lt;/style&gt;&lt;/head&gt;&lt;body&gt; &lt;div class="box"&gt;&lt;/div&gt;&lt;/body&gt;&lt;/html&gt;]]></content>
      <categories>
        <category>HTML/CSS</category>
        <category>HTML5/CSS3</category>
      </categories>
      <tags>
        <tag>HTML</tag>
        <tag>HTML5</tag>
        <tag>CSS3</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[12-文字阴影]]></title>
    <url>%2Fposts%2Fe5399d92%2F</url>
    <content type="text"><![CDATA[文字阴影 12345678910111213141516171819202122232425262728293031323334353637383940&lt;!DOCTYPE html&gt;&lt;html lang="en"&gt;&lt;head&gt; &lt;meta charset="UTF-8"&gt; &lt;meta name="viewport" content="width=device-width, initial-scale=1.0"&gt; &lt;meta http-equiv="X-UA-Compatible" content="ie=edge"&gt; &lt;title&gt;Document&lt;/title&gt; &lt;style&gt; body&#123; background-color: #000; &#125; p&#123; color:white; font-size: 200px; text-align: center; transition: all 1.5s; &#125; p:hover&#123; /* 参数1：水平偏移 参数2：垂直偏移 参数3：模糊度 参数4：阴影颜色 它的阴影大小是跟文字一样大的！不可以改阴影大小，除非改文字大小 */ text-shadow: -5px -5px 10px green,-10px -10px 10px red,-15px -15px 10px yellow; &#125; &lt;/style&gt;&lt;/head&gt;&lt;body&gt; &lt;p&gt;抽利群&lt;/p&gt;&lt;/body&gt;&lt;/html&gt;]]></content>
      <categories>
        <category>HTML/CSS</category>
        <category>HTML5/CSS3</category>
      </categories>
      <tags>
        <tag>HTML</tag>
        <tag>HTML5</tag>
        <tag>CSS3</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[11-盒子阴影]]></title>
    <url>%2Fposts%2Fcd49cd03%2F</url>
    <content type="text"><![CDATA[盒子阴影 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647&lt;!DOCTYPE html&gt;&lt;html lang="en"&gt;&lt;head&gt; &lt;meta charset="UTF-8"&gt; &lt;meta name="viewport" content="width=device-width, initial-scale=1.0"&gt; &lt;meta http-equiv="X-UA-Compatible" content="ie=edge"&gt; &lt;title&gt;Document&lt;/title&gt; &lt;style&gt; body&#123; background-color: #000; &#125; .box&#123; width: 200px; height: 300px; background-color: #f00; margin: 50px auto; /* 盒子阴影 参数1：水平偏移位置 参数2：垂直偏移位置 参数3：模糊度，值越大越模糊 参数4：阴影的宽度,哪怕宽度为0其实阴影也有宽度，只不过是跟盒子一样宽，这个宽度其实是设置阴影四周再加多少宽度 参数5：阴影的颜色 参数6：是否为内阴影，加一个inset就是内阴影，不加就是外阴影 inset也可以加在最前面，建议加最后 多个阴影之间，用逗号隔开，先写的阴影，层级最高 */ box-shadow: 0px 0px 10px 10px gold,0px 0px 10px 20px blue; &#125; img&#123; display: block; margin: 20px auto; box-shadow: 0px 0px 10px 10px white; &#125; &lt;/style&gt;&lt;/head&gt;&lt;body&gt; &lt;div class="box"&gt;&lt;/div&gt; &lt;img src="images/lq.png" alt=""&gt;&lt;/body&gt;&lt;/html&gt;]]></content>
      <categories>
        <category>HTML/CSS</category>
        <category>HTML5/CSS3</category>
      </categories>
      <tags>
        <tag>HTML</tag>
        <tag>HTML5</tag>
        <tag>CSS3</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[10-伪类选择器之xxx-of-type]]></title>
    <url>%2Fposts%2F12c0de6f%2F</url>
    <content type="text"><![CDATA[伪类选择器之xxx-of-type 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778&lt;!DOCTYPE html&gt;&lt;html lang="en"&gt;&lt;head&gt; &lt;meta charset="UTF-8"&gt; &lt;meta name="viewport" content="width=device-width, initial-scale=1.0"&gt; &lt;meta http-equiv="X-UA-Compatible" content="ie=edge"&gt; &lt;title&gt;Document&lt;/title&gt; &lt;!-- :xxx-of-type： 用法跟xxx-child是一样一样的 但是xxx-child必须满足在父元素中也是第几个子元素 而xxx-of-type就是找到第几个，不要求满足在父元素中是第几个 --&gt; &lt;style&gt; /* 在那个区域里找到第一个li,不需要是在父元素中是第一个子元素 */ li:first-of-type&#123; color:red; &#125; /* 找到最后一个li，不需要在父元素中是最后一个子元素 */ li:last-of-type&#123; color:blue; &#125; /* 你写3，它就是找到第三个li，不要求是父元素中的第三个子元素 */ li:nth-of-type(3)&#123; color:green; &#125; /*从第五个li开始，但是要除掉第八个以外的li */ li:nth-of-type(n+5):not(:nth-of-type(8))&#123; /* even odd 都可以，7n可以 n也可以，跟nth-child用法是一样的，只是效果略微不一样 */ font-size: 20px; &#125; &lt;/style&gt;&lt;/head&gt;&lt;body&gt; &lt;ul&gt; &lt;span&gt;我是span&lt;/span&gt; &lt;li&gt;隔壁老王1&lt;/li&gt; &lt;li&gt;隔壁老王2&lt;/li&gt; &lt;li&gt;隔壁老王3&lt;/li&gt; &lt;li&gt;隔壁老王4&lt;/li&gt; &lt;li&gt;隔壁老王5&lt;/li&gt; &lt;li&gt;隔壁老王6&lt;/li&gt; &lt;li&gt;隔壁老王7&lt;/li&gt; &lt;li&gt;隔壁老王8&lt;/li&gt; &lt;li&gt;隔壁老王9&lt;/li&gt; &lt;li&gt;隔壁老王10&lt;/li&gt; &lt;span&gt;我在最后&lt;/span&gt; &lt;/ul&gt; &lt;ul&gt; &lt;li&gt;隔壁老周1&lt;/li&gt; &lt;li&gt;隔壁老周2&lt;/li&gt; &lt;li&gt;隔壁老周3&lt;/li&gt; &lt;li&gt;隔壁老周4&lt;/li&gt; &lt;li&gt;隔壁老周5&lt;/li&gt; &lt;li&gt;隔壁老周6&lt;/li&gt; &lt;li&gt;隔壁老周7&lt;/li&gt; &lt;li&gt;隔壁老周8&lt;/li&gt; &lt;li&gt;隔壁老周9&lt;/li&gt; &lt;li&gt;隔壁老周10&lt;/li&gt; &lt;/ul&gt;&lt;/body&gt;&lt;/html&gt;]]></content>
      <categories>
        <category>HTML/CSS</category>
        <category>HTML5/CSS3</category>
      </categories>
      <tags>
        <tag>HTML</tag>
        <tag>HTML5</tag>
        <tag>CSS3</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[09-伪类选择器]]></title>
    <url>%2Fposts%2F12c0de6f%2F</url>
    <content type="text"><![CDATA[伪类选择器 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101&lt;!DOCTYPE html&gt;&lt;html lang="en"&gt;&lt;head&gt; &lt;meta charset="UTF-8"&gt; &lt;meta name="viewport" content="width=device-width, initial-scale=1.0"&gt; &lt;meta http-equiv="X-UA-Compatible" content="ie=edge"&gt; &lt;title&gt;Document&lt;/title&gt; &lt;!-- :hover：悬停样式 :link：未点击时的样式 :active：点击时的样式 :visited：访问后的样式 这是a标签的四种状态样式，但是上面这四个伪类，一般都是给a用的，只有hover所有元素都用 伪类选择器前面一点有一个冒号 :xxx-child：必须保证在父元素中是第几个子元素 :first-child：找到第一个子元素，它在父元素中也必须是第一个子元素 :last-child：找到最后一个子元素，它在父元素中也必须是最后一个子元素 :nth-child：找到某个子元素 nth-child里可以写任意数字，就代表找到第几个 也可以写n：代表找到所有 还可以写n+m：代表找到从m开始以及后面所有 例：n+3 从3开始 还可以写mn: 代表m的倍数 3n 代表3的倍数 还可以写mn-1: 代表m的倍数前一位 3n-1 代表3的倍数的前一位 还可以写even：代表偶数 还可以写odd：代表奇数 --&gt; &lt;style&gt; li:first-child&#123; color:red; &#125; li:last-child&#123; color:blue; &#125; /* 找到第三个子元素li */ li:nth-child(3)&#123; font-style: italic; &#125; /* n就代表所有 */ li:nth-child(n)&#123; border:1px solid black; &#125; /* 3的倍数 */ li:nth-child(3n)&#123; color:hotpink; &#125; /* 3的倍数前一位 */ li:nth-child(3n-1)&#123; color:purple; &#125; /* 从3开始以及后面所有 */ li:nth-child(n+3)&#123; font-size: 20px; &#125; /* 偶数 */ li:nth-child(even)&#123; background-color: yellowgreen; &#125; /* 奇数 */ li:nth-child(odd)&#123; background-color: skyblue; &#125; &lt;/style&gt;&lt;/head&gt;&lt;body&gt; &lt;ul&gt; &lt;span&gt;我是span&lt;/span&gt; &lt;li&gt;隔壁老王1&lt;/li&gt; &lt;li&gt;隔壁老王2&lt;/li&gt; &lt;li&gt;隔壁老王3&lt;/li&gt; &lt;li&gt;隔壁老王4&lt;/li&gt; &lt;li&gt;隔壁老王5&lt;/li&gt; &lt;li&gt;隔壁老王6&lt;/li&gt; &lt;li&gt;隔壁老王7&lt;/li&gt; &lt;li&gt;隔壁老王8&lt;/li&gt; &lt;li&gt;隔壁老王9&lt;/li&gt; &lt;span&gt;我在最后&lt;/span&gt; &lt;/ul&gt;&lt;/body&gt;&lt;/html&gt;]]></content>
      <categories>
        <category>HTML/CSS</category>
        <category>HTML5/CSS3</category>
      </categories>
      <tags>
        <tag>HTML</tag>
        <tag>HTML5</tag>
        <tag>CSS3</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[08-box-sizing初见]]></title>
    <url>%2Fposts%2F84ffbeb1%2F</url>
    <content type="text"><![CDATA[box-sizing初见 123456789101112131415161718192021222324252627282930313233343536&lt;!DOCTYPE html&gt;&lt;html lang="en"&gt;&lt;head&gt; &lt;meta charset="UTF-8"&gt; &lt;meta name="viewport" content="width=device-width, initial-scale=1.0"&gt; &lt;meta http-equiv="X-UA-Compatible" content="ie=edge"&gt; &lt;title&gt;Document&lt;/title&gt; &lt;!-- 默认情况下，加边框和内边距都是往外扩，那么会增大盒子占的范围 美工出的设计图告诉你说盒子总共占100*100，而且有边框，那么如果你按照默认形式写，会超出。所以我们的解决办法是：把宽和高减去border的宽高 这样做很麻烦 所以有个属性叫box-sizing,可以让我们让边框和内边距不要往外扩 --&gt; &lt;style&gt; .box&#123; width: 100px; height: 100px; background-color: #f00; border:10px solid black; padding: 10px; /* border-box:让边框和内边距都是内聚，而不是外扩 content-box：默认值，代表外扩 */ box-sizing: border-box; &#125; &lt;/style&gt;&lt;/head&gt;&lt;body&gt; &lt;div class="box"&gt;&lt;/div&gt;&lt;/body&gt;&lt;/html&gt;]]></content>
      <categories>
        <category>HTML/CSS</category>
        <category>HTML5/CSS3</category>
      </categories>
      <tags>
        <tag>HTML</tag>
        <tag>HTML5</tag>
        <tag>CSS3</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[07-用JS加transition动画]]></title>
    <url>%2Fposts%2F8a12b85b%2F</url>
    <content type="text"><![CDATA[用JS加transition动画 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263&lt;!DOCTYPE html&gt;&lt;html lang="en"&gt;&lt;head&gt; &lt;meta charset="UTF-8"&gt; &lt;meta name="viewport" content="width=device-width, initial-scale=1.0"&gt; &lt;meta http-equiv="X-UA-Compatible" content="ie=edge"&gt; &lt;title&gt;Document&lt;/title&gt; &lt;!-- 以后如果要用纯JS代码做动画，一般都是先写好一个类，再用JS加上这个类就行了 --&gt; &lt;style&gt; .box&#123; width: 100px; height: 100px; background-color: #f00; &#125; .box.animation&#123; width: 300px; height: 300px; background-color: #0f0; transition: all 1s; &#125; &lt;/style&gt;&lt;/head&gt;&lt;body&gt; &lt;div class="box"&gt;&lt;/div&gt; &lt;input type="button" value="用动画变大" id="btn1"&gt; &lt;input type="button" value="复原" id="btn2"&gt; &lt;input type="button" value="切换" id="btn3"&gt;&lt;/body&gt;&lt;/html&gt;&lt;script&gt; var box = document.querySelector('.box'); //点击事件 document.getElementById('btn1').onclick = function()&#123; // box.style.width = "300px"; // box.style.height = "300px"; // box.style.transition = "all 1s"; box.classList.add('animation'); &#125; document.getElementById('btn2').onclick = function()&#123; box.classList.remove('animation'); &#125; document.getElementById('btn3').onclick = function()&#123; box.classList.toggle('animation'); &#125;&lt;/script&gt;]]></content>
      <categories>
        <category>HTML/CSS</category>
        <category>HTML5/CSS3</category>
      </categories>
      <tags>
        <tag>HTML</tag>
        <tag>HTML5</tag>
        <tag>CSS3</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[06-js中的classList属性]]></title>
    <url>%2Fposts%2F9f9158f6%2F</url>
    <content type="text"><![CDATA[js中的classList属性 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106&lt;!DOCTYPE html&gt;&lt;html lang="en"&gt;&lt;head&gt; &lt;meta charset="UTF-8"&gt; &lt;meta name="viewport" content="width=device-width, initial-scale=1.0"&gt; &lt;meta http-equiv="X-UA-Compatible" content="ie=edge"&gt; &lt;title&gt;Document&lt;/title&gt; &lt;!-- JS里新增了一个专门操作类的属性叫classList 能够让我们添加一个类、删除一个类、切换一个类没那么麻烦了 classList是一个伪数组，它可以获取到所有的类，每个类都是一个数组的一个元素 从取值的角度就比以前className要方便 add:添加一个类 remove:删除一个类 toggle：切换一个类：原来没有这个类就加上，原来有这个类就去掉 contains：判断是否有某个类，如果有返回true，如果没有返回false --&gt; &lt;style&gt; .box&#123; width: 100px; height: 100px; border: 1px solid #000; &#125; .red&#123; background-color: #f00; &#125; &lt;/style&gt;&lt;/head&gt;&lt;body&gt; &lt;div class="box test"&gt;&lt;/div&gt; &lt;input type="button" value="加颜色" id="btn1"&gt; &lt;input type="button" value="去掉颜色" id="btn2"&gt; &lt;input type="button" value="切换颜色" id="btn3"&gt; &lt;input type="button" value="打印classList" id="btn4"&gt; &lt;input type="button" value="判断是否存在red这个类" id="btn5"&gt;&lt;/body&gt;&lt;/html&gt;&lt;script&gt; //找到box var box = document.querySelector('.box'); document.getElementById('btn1').onclick = function()&#123; // 添加一个类的时候很麻烦：因为要用+=以外，还要记得加空格 // box.className += " red"; // 添加一个类 box.classList.add("red"); &#125; document.getElementById('btn2').onclick = function()&#123; // 去掉一个类的时候也麻烦：因为需要把原来的类在这里都写上 // box.className = "box test"; //删除一个类 box.classList.remove('red'); &#125; document.getElementById('btn3').onclick = function()&#123; // console.log(box.className); //如果原来没有red这个类，我就给你加上，否则就去掉 // if(box.className.indexOf('red') != -1)&#123; // box.className = "box"; // &#125;else&#123; // //代表没有 // box.className += " red"; // &#125; //如果没有red这个类就加上，有就去掉 box.classList.toggle('red'); &#125; document.getElementById('btn4').onclick = function()&#123; console.log(box.classList); console.log(box.classList[0]); &#125; document.getElementById('btn5').onclick = function()&#123; //判断有没有red这个类 console.log(box.classList.contains('red')); &#125;&lt;/script&gt;]]></content>
      <categories>
        <category>HTML/CSS</category>
        <category>HTML5/CSS3</category>
      </categories>
      <tags>
        <tag>HTML</tag>
        <tag>HTML5</tag>
        <tag>CSS3</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[05-transition初见]]></title>
    <url>%2Fposts%2Ff5d680d4%2F</url>
    <content type="text"><![CDATA[transition初见 123456789101112131415161718192021222324252627282930313233343536373839404142&lt;!DOCTYPE html&gt;&lt;html lang="en"&gt;&lt;head&gt; &lt;meta charset="UTF-8"&gt; &lt;meta name="viewport" content="width=device-width, initial-scale=1.0"&gt; &lt;meta http-equiv="X-UA-Compatible" content="ie=edge"&gt; &lt;title&gt;Document&lt;/title&gt; &lt;style&gt; .box&#123; width: 100px; height: 100px; background-color: #f00; /* 让元素变化的时候有动画效果（过渡效果） */ /* 参数1：参与过渡的属性，一般写all，代表所有属性都参与过渡，也可以写其他的，写什么就代表什么属性参与过渡 */ /* 参数2：过渡的持续时间，记得要加单位s代表多少秒 */ /* 参数3：代表延迟几秒执行（延迟时间） */ /* 参数4：运动曲线 linear匀速 steps(n):分n个步骤 如果需要用其他运动曲线,可以考虑配合easing插件使用*/ /* transition加在hover里代表只有悬停时才有过渡效果，写在默认样式里代表悬停和移出恢复时都有过渡效果 */ /* transition: all 2s .5s linear; */ /* 过渡其实是一个复合属性，由多个属性连写的 */ /* transition-property: 参与过渡的属性，写all之类的 */ /* transition-duration: 过渡的持续时间 */ /* transition-delay: 过渡的延迟时间 */ /* transition-timing-function: 运动曲线 */ &#125; .box:hover&#123; width: 300px; height: 300px; background-color: #0f0; &#125; &lt;/style&gt;&lt;/head&gt;&lt;body&gt; &lt;div class="box"&gt;&lt;/div&gt;&lt;/body&gt;&lt;/html&gt;]]></content>
      <categories>
        <category>HTML/CSS</category>
        <category>HTML5/CSS3</category>
      </categories>
      <tags>
        <tag>HTML</tag>
        <tag>HTML5</tag>
        <tag>CSS3</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[05-h5中的自定义属性]]></title>
    <url>%2Fposts%2F1ce648c9%2F</url>
    <content type="text"><![CDATA[h5中的自定义属性 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061&lt;!DOCTYPE html&gt;&lt;html lang="en"&gt;&lt;head&gt; &lt;meta charset="UTF-8"&gt; &lt;meta name="viewport" content="width=device-width, initial-scale=1.0"&gt; &lt;meta http-equiv="X-UA-Compatible" content="ie=edge"&gt; &lt;title&gt;Document&lt;/title&gt; &lt;!-- 什么叫自定义属性？ 就是标签原本没有的属性，你写上了，那么这个属性就是自定义属性 以前怎么用JS取到自定义属性？ 以前写自定义属性的缺点： 1.自定义属性在行内区分的不明显 2.用JS取值的时候太复杂 在H5里面解决了上述两个问题： 1.区分的更明显 2.用JS取值更方便 H5里面要求，你写自定义属性的时候，前面都要加一个前缀:data- 只要是按这种形式写的自定义属性，那么都可以在JS里通过 元素.dataset[属性名]取到 注意：属性名不用加data-了，它会自动去掉 如果data-后面还有-，会去掉-，并把-后面的首字母大写，但是data-后面的首字母不会大写 简单来说：就是从第二个-后面开始的每个首字母大写 遵循的是驼峰命名法 --&gt;&lt;/head&gt;&lt;body&gt; &lt;div id="box" data-shengao="185cm" data-tizhong="45kg" data-user-login-name="andy"&gt;&lt;/div&gt;&lt;/body&gt;&lt;/html&gt;&lt;script&gt; var box = document.getElementById('box'); // console.log(box.getAttribute('shengao')); // console.log(box.getAttribute('tizhong')); //只要你是按H5要求的形式写的自定义属性，那么你可以通过元素.dataset方便的取到每个自定义属性 console.log(box.dataset); console.log(box.dataset.shengao); console.log(box.dataset['shengao']); console.log(box.dataset['userLoginName']); //遍历方式 // for(var key in box.dataset)&#123; // console.log(box.dataset[key]); // &#125; &lt;/script&gt;]]></content>
      <categories>
        <category>HTML/CSS</category>
        <category>HTML5/CSS3</category>
      </categories>
      <tags>
        <tag>HTML</tag>
        <tag>HTML5</tag>
        <tag>CSS3</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[03-js做新标签兼容的原理]]></title>
    <url>%2Fposts%2Fccca7402%2F</url>
    <content type="text"><![CDATA[js做新标签兼容的原理 12345678910111213141516171819202122232425262728293031323334353637383940414243444546&lt;!DOCTYPE html&gt;&lt;html lang="en"&gt;&lt;head&gt; &lt;meta charset="UTF-8"&gt; &lt;meta name="viewport" content="width=device-width, initial-scale=1.0"&gt; &lt;meta http-equiv="X-UA-Compatible" content="ie=edge"&gt; &lt;title&gt;Document&lt;/title&gt; &lt;!-- 哪怕你写了一个非标准的标签，浏览器依然能够把它解析成dom元素 只不过，你写的如果不是标准标签，而是你自己瞎写的浏览器不认识的标签，那么浏览器会把它当做行内元素来解析（可以理解为当span来解析） 如果你写的标签，浏览器认识，会按这个标签本身的特点来解析 但如果浏览器不认识，会把它当行内元素(span)来解析 所以，你只要用JS创建一个header标签，这个标签在IE8和之前浏览器不认识，会解析成行内元素， 但是你只要继续把创建出来的标签的display改成block，就会变成块级元素， 那么这样子这段代码在任何浏览器里，都能得到一个块级的header标签内容 --&gt; &lt;style&gt; header&#123; width: 100px; height: 100px; border: 1px solid black; background-color: #f00; &#125; &lt;/style&gt;&lt;/head&gt;&lt;body&gt; &lt;!-- &lt;header&gt;这是一个&lt;/header&gt; --&gt; &lt;p&gt;Lorem ipsum, dolor sit amet consectetur adipisicing elit. Sit exercitationem unde, aliquam, voluptate repellendus sint ducimus incidunt, dolore dolorum quae sequi corporis consequuntur harum perspiciatis aliquid error cumque quod omnis.&lt;/p&gt;&lt;/body&gt;&lt;/html&gt;&lt;script&gt; //JS创建标签，谷歌认识，所以创建出来一个块级元素 //但是IE8不认识，会把它当做行内元素来解析 var header = document.createElement('header'); header.style.display = "block"; header.innerHTML = "我是header"; document.body.appendChild(header);&lt;/script&gt;]]></content>
      <categories>
        <category>HTML/CSS</category>
        <category>HTML5/CSS3</category>
      </categories>
      <tags>
        <tag>HTML</tag>
        <tag>HTML5</tag>
        <tag>CSS3</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[02-h5新标签的兼容]]></title>
    <url>%2Fposts%2Feab618be%2F</url>
    <content type="text"><![CDATA[h5新标签的兼容 1234567891011121314151617181920212223242526272829303132333435&lt;!DOCTYPE html&gt;&lt;html lang="en"&gt;&lt;head&gt; &lt;meta charset="UTF-8"&gt; &lt;meta name="viewport" content="width=device-width, initial-scale=1.0"&gt; &lt;meta http-equiv="X-UA-Compatible" content="ie=edge"&gt; &lt;title&gt;Document&lt;/title&gt; &lt;!-- 新标签在IE8和之前的浏览器里不支持 兼容方法：引入插件，就行了 但是：新浏览器，没必要导入，否则会造成流量的浪费，解决办法：用css hack技术，让它只在IE8和IE8之前的浏览器里导入就行了 快捷键：cc:ie --&gt; &lt;style&gt; header&#123; width: 100px; height: 100px; background-color: #f00; &#125; &lt;/style&gt; &lt;!--[if lte IE 8]&gt; &lt;script src="./html5shiv.js"&gt;&lt;/script&gt; &lt;![endif]--&gt; &lt;/head&gt;&lt;body&gt; &lt;header&gt;&lt;/header&gt;&lt;/body&gt;&lt;/html&gt;]]></content>
      <categories>
        <category>HTML/CSS</category>
        <category>HTML5/CSS3</category>
      </categories>
      <tags>
        <tag>HTML</tag>
        <tag>HTML5</tag>
        <tag>CSS3</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[01-html5新增了这些布局的标签]]></title>
    <url>%2Fposts%2F8b07fa81%2F</url>
    <content type="text"><![CDATA[html5新增了这些布局的标签 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139&lt;!DOCTYPE html&gt;&lt;html lang="en"&gt;&lt;head&gt; &lt;meta charset="UTF-8"&gt; &lt;meta name="viewport" content="width=device-width, initial-scale=1.0"&gt; &lt;meta http-equiv="X-UA-Compatible" content="ie=edge"&gt; &lt;title&gt;Document&lt;/title&gt; &lt;!-- 本文件知识点： header:头部区域 nav: 导航区域 main： 主体区域 section:小区域 aside：边栏 article：正文 footer： 页尾区域 以上标签其实就是div，只不过比div更加具备语义化，是H5中专门用来表示网页布局结构的标签 是HTML5的规范出来以后才有的，那么就意味着会有兼容性问题，IE8和之前的浏览器不支持 --&gt; &lt;style&gt; header &#123; height: 200px; background-color: #f00; &#125; nav &#123; height: 100px; background-color: orange; &#125; main &#123; margin-top: 10px; height: 600px; background-color: #0f0; &#125; section &#123; height: 180px; margin-top: 15px; background-color: purple; &#125; aside &#123; float: left; width: 30%; height: 100%; background-color: peru; &#125; article &#123; float: left; width: 70%; height: 100%; background-color: olivedrab; &#125; footer &#123; margin-top: 10px; height: 100px; background-color: #00f; &#125; /* div： 没有语义，不利于SEO（搜索引擎优化） 要让他们布局必须要给样式，为了区分每一个区域，我们给的是类名来区分，但是类名可以随便写，没有一套严格规定 H5新增了一些专门用来做网页布局结构的标签：它就是用来解决上述两个问题 1.这些标签语义化更强 2.解决了不能乱写的问题，可读性更强 除了上面这两个，这些新标签没有任何其他特点了，可以这么说，它其实就是一个div，只不过比div更加具备语义化，这些div是专门用来做区分网页布局结构的 */ &lt;/style&gt;&lt;/head&gt;&lt;body&gt; &lt;!-- 头部区域：又有导航区域 --&gt; &lt;header&gt; &lt;nav&gt;&lt;/nav&gt; &lt;/header&gt; &lt;!-- 主体区域：好多小区域 --&gt; &lt;main&gt; &lt;section&gt; &lt;!-- 边栏 --&gt; &lt;aside&gt;&lt;/aside&gt; &lt;!-- 正文 --&gt; &lt;article&gt;&lt;/article&gt; &lt;/section&gt; &lt;section&gt; &lt;!-- 边栏 --&gt; &lt;aside&gt;&lt;/aside&gt; &lt;!-- 正文 --&gt; &lt;article&gt;&lt;/article&gt; &lt;/section&gt; &lt;section&gt; &lt;!-- 边栏 --&gt; &lt;aside&gt;&lt;/aside&gt; &lt;!-- 正文 --&gt; &lt;article&gt;&lt;/article&gt; &lt;/section&gt; &lt;/main&gt; &lt;!-- 页尾区域 --&gt; &lt;footer&gt;&lt;/footer&gt;&lt;/body&gt;&lt;script&gt; for ( var i = 0 ; i &lt; arr.length - 1 ; i ++ ) &#123;//1.外层循环决定比较的轮数 for ( var j = 0 ; j &lt; arr.length - 1 - i ; j ++ ) &#123;//2.内层循环决定每一轮比较的次数 if ( arr[ j ] &gt; arr[ j + 1 ] ) &#123;//3.交换相邻元素：比较两个相邻数字的大小 var temp = arr[ j ]; arr[ j ] = arr[ j + 1 ]; arr[ j + 1 ] = temp; &#125; &#125; &#125;&lt;/script&gt;&lt;/html&gt;]]></content>
      <categories>
        <category>HTML/CSS</category>
        <category>HTML5/CSS3</category>
      </categories>
      <tags>
        <tag>HTML</tag>
        <tag>HTML5</tag>
        <tag>CSS3</tag>
      </tags>
  </entry>
</search>
